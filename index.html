<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>dGEN Town — Visual Collection for dGEN1</title>

<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#000000;
    --muted:#0f1112;
    --accent1:#00f0ff;
    --accent2:#b043ff;
    --glass: rgba(255,255,255,0.04);
    --text: rgba(255,255,255,0.9);
    --small: 12px;
  }
  html,body{
    height:100%;
    margin:0;
    background:var(--bg);
    color:var(--text);
    font-family: "Rajdhani", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  .stage {
    width:100vw;
    height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    box-sizing:border-box;
  }

  .frame {
    width:100%;
    height:100%;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    overflow:hidden;
    position:relative;
    border:none;
  }

  .grain {
    position:absolute;
    inset:0;
    pointer-events:none;
    background-image: radial-gradient(rgba(255,255,255,0.015) 1px, transparent 1px);
    background-size: 3px 3px;
    opacity:0.6;
    mix-blend-mode: overlay;
  }

  header {
    position:absolute;
    top:18px;
    left:20px;
    right:20px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    z-index:50;
    pointer-events:none;
  }

  .title {
    display:flex;
    align-items:center;
    gap:12px;
    pointer-events:auto;
  }

  .logo {
    font-family: "Orbitron", monospace;
    font-weight:700;
    color:var(--accent1);
    font-size:18px;
    letter-spacing:1px;
    opacity:0.95;
    text-shadow: 0 2px 18px rgba(0,240,255,0.06);
    background: linear-gradient(90deg, rgba(0,240,255,0.12), rgba(176,67,255,0.04));
    padding:6px 10px;
    border-radius:8px;
  }

  .title h1{
    margin:0;
    font-size:18px;
    color:rgba(255,255,255,0.92);
    letter-spacing:1px;
  }
  .title p{ margin:0; font-size:12px; color:rgba(255,255,255,0.35);}

  .controls {
    display:flex;
    gap:10px;
    align-items:center;
    pointer-events:auto;
  }

  .btn {
    background:var(--glass);
    border:1px solid rgba(255,255,255,0.03);
    padding:8px 10px;
    border-radius:8px;
    cursor:pointer;
    color:var(--text);
    font-size:13px;
    display:inline-flex;
    gap:8px;
    align-items:center;
    transition:transform .18s ease, box-shadow .18s ease;
    user-select:none;
  }
  .btn:hover{ transform:translateY(-4px); box-shadow: 0 8px 28px rgba(0,0,0,0.5); }
  .btn.toggled { background: linear-gradient(90deg, rgba(0,240,255,0.06), rgba(176,67,255,0.02)); }

  .gallery {
    padding:88px 36px 36px 36px;
    box-sizing:border-box;
    height:100%;
    display:grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    grid-auto-rows: minmax(180px, 1fr);
    gap:18px;
    z-index:10;
    overflow-y:auto;
  }

  .card {
    border-radius:8px;
    overflow:hidden;
    background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
    border:1px solid rgba(255,255,255,0.02);
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    cursor:pointer;
    transition:transform .25s ease, box-shadow .25s ease;
  }
  .card:hover { transform: translateY(-8px); box-shadow: 0 14px 40px rgba(0,0,0,0.7); }
  .card canvas { width:100%; height:100%; display:block; }

  .card .label {
    position:absolute;
    left:12px;
    bottom:8px;
    font-size:12px;
    color:rgba(255,255,255,0.9);
    background: linear-gradient(180deg, rgba(0,0,0,0.25), rgba(255,255,255,0.02));
    padding:6px 8px;
    border-radius:6px;
    backdrop-filter: blur(4px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.6);
  }

  .overlay {
    position:absolute;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    z-index:60;
    background: linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.65));
    backdrop-filter: blur(6px);
  }
  .overlay.active { display:flex; animation:overlayIn .35s ease both; }
  @keyframes overlayIn { from{opacity:0; transform:scale(.995);} to{opacity:1; transform:none;} }

  .canvas-wrap{
    width:100%;
    height:100%;
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
    background:transparent;
    cursor:pointer;
  }

  .overlay-ui {
    position:absolute;
    inset:18px;
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    pointer-events:none;
    transition: opacity 0.3s ease, transform 0.3s ease;
  }
  
  .overlay-ui.hidden {
    opacity:0;
    transform:translateY(-10px);
    pointer-events:none;
  }
  
  .overlay-left, .overlay-right {
    pointer-events:auto;
    display:flex;
    gap:10px;
    align-items:center;
  }
  .back-btn {
    background:transparent;
    border:1px solid rgba(255,255,255,0.06);
    color:var(--text);
    padding:8px 10px;
    border-radius:8px;
    cursor:pointer;
    backdrop-filter: blur(6px);
  }
  .small {
    font-size:12px;
    color:rgba(255,255,255,0.7);
    opacity:0.9;
  }

  .bubble {
    position:absolute;
    right:18px;
    bottom:18px;
    pointer-events:auto;
    display:flex;
    gap:10px;
    align-items:center;
  }
  .dot {
    width:10px;height:10px;border-radius:50%;
    background:var(--accent1);
    box-shadow:0 6px 20px rgba(0,240,255,0.08);
    opacity:0.9;
  }

  .micro {
    position:absolute;
    left:18px;
    bottom:18px;
    font-size:11px;
    color:rgba(255,255,255,0.28);
    pointer-events:auto;
  }

  .pic-controls {
    display:flex;
    gap:8px;
    align-items:center;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:8px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.03);
  }
  .input {
    background:transparent;border:1px dashed rgba(255,255,255,0.06);padding:6px;border-radius:6px;color:var(--text);font-size:12px;
  }

  @media (max-width:800px){
    .gallery{ grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); padding:80px 20px 20px 20px; }
  }

</style>
</head>
<body>
  <div class="stage">
    <div class="frame" role="application" aria-label="dGEN Town visual frame">
      <div class="grain" aria-hidden="true"></div>

      <header>
        <div class="title">
          <div class="logo">dGEN1</div>
          <div>
            <h1>dGEN Town</h1>
            <p style="margin-top:4px;">Visual Collection — Click card to enter</p>
          </div>
        </div>

        <div class="controls">
          <!-- <button id="autoplayToggle" class="btn" title="Toggle autoplay">Autoplay</button> -->
          <button id="randomBtn" class="btn" title="Random template">Random</button>
          <button id="helpBtn" class="btn" title="Help/Info">Info</button>
        </div>
      </header>

      <main class="gallery" id="gallery" aria-hidden="false"></main>

      <div class="micro">dGEN Town · © 2025</div>

      <div class="overlay" id="overlay" aria-hidden="true">
        <div class="canvas-wrap" id="canvasWrap"></div>

        <div class="overlay-ui" id="overlayUI" aria-hidden="false">
          <div class="overlay-left">
            <button id="backBtn" class="back-btn" title="Back to gallery">← Back</button>
            <div class="small" id="currentLabel">—</div>
          </div>
          <div class="overlay-right" style="align-items:center">
            <div id="picControlsContainer"></div>
            <div class="bubble">
              <div class="dot" id="autoplayDot" style="display:none"></div>
              <div class="small">Auto</div>
              <button id="nextBtn" class="btn" title="Next template">Next</button>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

<script>
const $ = sel => document.querySelector(sel);
const create = (tag, attrs={}, parent=null) => {
  const el = document.createElement(tag);
  Object.entries(attrs).forEach(([k,v])=>{
    if(k === 'class') el.className = v;
    else if(k === 'html') el.innerHTML = v;
    else el.setAttribute(k, v);
  });
  if(parent) parent.appendChild(el);
  return el;
};

const TEMPLATE_IDS = [
  'cyberMinimal','cryptoOrb','retroTerminal','zenSpace',
  'picFrame','liquidWaves','matrixRain','hexGridPulse',
  'clockSync','codeVerse','aiBloom','signatureLoop',
  'neonCity','glitchArt','vaporwave','hologram',
  'pixelStorm','scanlines','dataStream','particleNebula',
  'geometricDance','synthwave','digitalRain','cosmicVoid',
  'fractalTree','waveform','starfield','cyberpunkGrid'
];

const TEMPLATE_META = {
  cyberMinimal: {name:'Cyber Minimal'},
  cryptoOrb: {name:'Crypto Orb'},
  retroTerminal: {name:'Retro Terminal'},
  zenSpace: {name:'Zen Space'},
  picFrame: {name:'Pic Frame'},
  liquidWaves: {name:'Liquid Waves'},
  matrixRain: {name:'Matrix Rain'},
  hexGridPulse: {name:'Hex Grid Pulse'},
  clockSync: {name:'Clock Sync'},
  codeVerse: {name:'Code Verse'},
  aiBloom: {name:'AI Bloom'},
  signatureLoop: {name:'Signature Loop'},
  neonCity: {name:'Neon City'},
  glitchArt: {name:'Glitch Art'},
  vaporwave: {name:'Vaporwave'},
  hologram: {name:'Hologram'},
  pixelStorm: {name:'Pixel Storm'},
  scanlines: {name:'Scanlines'},
  dataStream: {name:'Data Stream'},
  particleNebula: {name:'Particle Nebula'},
  geometricDance: {name:'Geometric Dance'},
  synthwave: {name:'Synthwave'},
  digitalRain: {name:'Digital Rain'},
  cosmicVoid: {name:'Cosmic Void'},
  fractalTree: {name:'Fractal Tree'},
  waveform: {name:'Waveform'},
  starfield: {name:'Starfield'},
  cyberpunkGrid: {name:'Cyberpunk Grid'}
};

let autoplay = false;
let autoplayTimer = null;
let currentIndex = -1;
let activeInstance = null;
let uiVisible = true;

const gallery = $('#gallery');
TEMPLATE_IDS.forEach((id, i)=>{
  const card = create('div', {class:'card', id:'card-'+id}, gallery);
  const thumb = create('canvas', {width:300, height:300}, card);
  const label = create('div', {class:'label', html: TEMPLATE_META[id].name}, card);

  card.addEventListener('click', ()=> openTemplate(i));
  
  setTimeout(()=> {
    const ctx = thumb.getContext('2d');
    const w = thumb.width, h = thumb.height;
    
    ctx.fillStyle = '#0a0a0c';
    ctx.fillRect(0,0,w,h);
    
    ctx.save();
    ctx.translate(w/2, h/2);
    
    switch(id) {
      case 'cyberMinimal':
        ctx.strokeStyle = 'rgba(0,240,255,0.4)';
        ctx.lineWidth = 3;
        ctx.strokeRect(-60, -60, 120, 120);
        ctx.rotate(Math.PI/4);
        ctx.strokeStyle = 'rgba(176,67,255,0.3)';
        ctx.strokeRect(-50, -50, 100, 100);
        break;
        
      case 'cryptoOrb':
        const grd = ctx.createRadialGradient(0,0,10,0,0,80);
        grd.addColorStop(0, 'rgba(0,240,255,0.6)');
        grd.addColorStop(0.5, 'rgba(176,67,255,0.3)');
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd;
        ctx.fillRect(-100,-100,200,200);
        break;
        
      case 'retroTerminal':
        ctx.font = '14px monospace';
        ctx.fillStyle = 'rgba(0,255,140,0.6)';
        for(let j=0; j<8; j++) {
          ctx.fillText('> 0x' + Math.random().toString(16).substr(2,8), -120, -60 + j*20);
        }
        break;
        
      case 'zenSpace':
        ctx.beginPath();
        ctx.arc(0,0,80,0,Math.PI*2);
        ctx.fillStyle = 'rgba(176,67,255,0.25)';
        ctx.fill();
        break;
        
      case 'picFrame':
        ctx.strokeStyle = 'rgba(0,240,255,0.4)';
        ctx.lineWidth = 3;
        ctx.strokeRect(-80,-80,160,160);
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.font = '16px Rajdhani';
        ctx.fillText('📷', -12, 8);
        break;
        
      case 'liquidWaves':
        ctx.strokeStyle = 'rgba(0,240,255,0.4)';
        ctx.lineWidth = 2;
        for(let j=0; j<5; j++) {
          ctx.beginPath();
          for(let x=-120; x<=120; x+=10) {
            const y = Math.sin(x*0.05 + j*0.5)*20 + j*10 - 40;
            if(x===-120) ctx.moveTo(x,y);
            else ctx.lineTo(x,y);
          }
          ctx.stroke();
        }
        break;
        
      case 'matrixRain':
        ctx.font = '16px monospace';
        ctx.fillStyle = 'rgba(0,255,140,0.5)';
        for(let j=0; j<15; j++) {
          const x = (j-7)*20;
          const y = (j%3)*30 - 40;
          ctx.fillText(Math.random()>0.5?'1':'0', x, y);
        }
        break;
        
      case 'hexGridPulse':
        ctx.strokeStyle = 'rgba(0,240,255,0.3)';
        ctx.lineWidth = 2;
        for(let hx=-2; hx<=2; hx++) {
          for(let hy=-2; hy<=2; hy++) {
            const px = hx*30 + (hy%2?15:0);
            const py = hy*26;
            ctx.beginPath();
            for(let k=0; k<6; k++) {
              const ang = (Math.PI*2/6)*k;
              const x = px + Math.cos(ang)*15;
              const y = py + Math.sin(ang)*15;
              if(k===0) ctx.moveTo(x,y);
              else ctx.lineTo(x,y);
            }
            ctx.closePath();
            ctx.stroke();
          }
        }
        break;
        
      case 'clockSync':
        ctx.beginPath();
        ctx.arc(0,0,70,0,Math.PI*2);
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.strokeStyle = 'rgba(0,240,255,0.6)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(0,-50);
        ctx.stroke();
        break;
        
      case 'codeVerse':
        ctx.font = '12px monospace';
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        const snippets = ['function()', 'const x =', 'if (true)', '{ code }', 'return;'];
        snippets.forEach((s,j)=>{
          ctx.fillText(s, -60, -40 + j*20);
        });
        break;
        
      case 'aiBloom':
        for(let j=0; j<12; j++) {
          const ang = (j/12)*Math.PI*2;
          ctx.beginPath();
          ctx.moveTo(0,0);
          ctx.arc(Math.cos(ang)*40, Math.sin(ang)*40, 30, ang-0.5, ang+0.5);
          ctx.fillStyle = `rgba(176,67,255,${0.15 + j*0.01})`;
          ctx.fill();
        }
        break;
        
      case 'signatureLoop':
        ctx.strokeStyle = 'rgba(0,240,255,0.3)';
        ctx.lineWidth = 2;
        for(let j=0; j<4; j++) {
          ctx.beginPath();
          for(let t=0; t<=1; t+=0.05) {
            const x = (t-0.5)*200;
            const y = Math.sin(t*Math.PI*3 + j)*30 + j*15 - 30;
            if(t===0) ctx.moveTo(x,y);
            else ctx.lineTo(x,y);
          }
          ctx.stroke();
        }
        break;
        
      case 'neonCity':
        ctx.strokeStyle = 'rgba(255,0,255,0.5)';
        ctx.lineWidth = 2;
        for(let j=0; j<8; j++) {
          const h = 40 + Math.random()*60;
          ctx.strokeRect(-100 + j*25, 50-h, 20, h);
        }
        ctx.fillStyle = 'rgba(0,240,255,0.3)';
        ctx.fillRect(-120, 50, 240, 2);
        break;
        
      case 'glitchArt':
        for(let j=0; j<10; j++) {
          ctx.fillStyle = `rgba(${Math.random()*255},${Math.random()*255},255,0.3)`;
          ctx.fillRect(-100 + Math.random()*200, -100 + Math.random()*200, 40, 8);
        }
        break;
        
      case 'vaporwave':
        const grd2 = ctx.createLinearGradient(0,-100,0,100);
        grd2.addColorStop(0, 'rgba(255,0,255,0.3)');
        grd2.addColorStop(1, 'rgba(0,240,255,0.3)');
        ctx.fillStyle = grd2;
        ctx.fillRect(-100,-100,200,200);
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        for(let j=-5; j<=5; j++) {
          ctx.beginPath();
          ctx.moveTo(-100, j*20);
          ctx.lineTo(100, j*20);
          ctx.stroke();
        }
        break;
        
      case 'hologram':
        for(let j=0; j<5; j++) {
          ctx.beginPath();
          ctx.arc(0, 0, 20 + j*15, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(0,240,255,${0.4 - j*0.06})`;
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        break;
        
      case 'pixelStorm':
        for(let j=0; j<50; j++) {
          ctx.fillStyle = `rgba(${Math.random()*255},${Math.random()*255},255,0.5)`;
          ctx.fillRect(-100 + Math.random()*200, -100 + Math.random()*200, 6, 6);
        }
        break;
        
      case 'scanlines':
        ctx.strokeStyle = 'rgba(0,255,140,0.3)';
        ctx.lineWidth = 1;
        for(let j=-100; j<100; j+=4) {
          ctx.beginPath();
          ctx.moveTo(-100, j);
          ctx.lineTo(100, j);
          ctx.stroke();
        }
        ctx.fillStyle = 'rgba(0,240,255,0.2)';
        ctx.fillRect(-60, -60, 120, 120);
        break;
        
      case 'dataStream':
        ctx.font = '10px monospace';
        ctx.fillStyle = 'rgba(0,240,255,0.4)';
        for(let j=0; j<20; j++) {
          ctx.fillText(Math.random().toString(2).substr(2,8), -100 + (j%5)*50, -80 + Math.floor(j/5)*40);
        }
        break;
        
      case 'particleNebula':
        for(let j=0; j<100; j++) {
          const x = (Math.random()-0.5)*200;
          const y = (Math.random()-0.5)*200;
          const size = Math.random()*3;
          ctx.fillStyle = `rgba(176,67,255,${Math.random()*0.5})`;
          ctx.fillRect(x, y, size, size);
        }
        break;
        
      case 'geometricDance':
        for(let j=0; j<6; j++) {
          ctx.save();
          ctx.rotate((j/6)*Math.PI*2);
          ctx.strokeStyle = `rgba(0,240,255,${0.3 + j*0.05})`;
          ctx.lineWidth = 2;
          ctx.strokeRect(30, -10, 40, 20);
          ctx.restore();
        }
        break;
        
      case 'synthwave':
        const grd3 = ctx.createLinearGradient(0,-100,0,100);
        grd3.addColorStop(0, 'rgba(255,0,128,0.4)');
        grd3.addColorStop(0.5, 'rgba(128,0,255,0.3)');
        grd3.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd3;
        ctx.fillRect(-100,-100,200,200);
        ctx.strokeStyle = 'rgba(255,0,255,0.3)';
        for(let j=-5; j<=5; j++) {
          ctx.beginPath();
          ctx.moveTo(j*20, -100);
          ctx.lineTo(j*20, 100);
          ctx.stroke();
        }
        break;
        
      case 'digitalRain':
        ctx.font = '14px monospace';
        for(let j=0; j<12; j++) {
          ctx.fillStyle = `rgba(0,255,140,${0.2 + Math.random()*0.4})`;
          ctx.fillText(String.fromCharCode(0x30A0 + Math.random()*96), -100 + j*20, -80 + (j%4)*50);
        }
        break;
        
      case 'cosmicVoid':
        const grd4 = ctx.createRadialGradient(0,0,0,0,0,120);
        grd4.addColorStop(0, 'rgba(128,0,255,0.4)');
        grd4.addColorStop(0.7, 'rgba(0,0,128,0.2)');
        grd4.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd4;
        ctx.fillRect(-120,-120,240,240);
        for(let j=0; j<30; j++) {
          ctx.fillStyle = 'rgba(255,255,255,0.6)';
          ctx.fillRect((Math.random()-0.5)*200, (Math.random()-0.5)*200, 2, 2);
        }
        break;
        
      case 'fractalTree':
        ctx.strokeStyle = 'rgba(0,240,255,0.4)';
        ctx.lineWidth = 2;
        function drawBranch(x, y, len, angle, depth) {
          if(depth === 0) return;
          const x2 = x + Math.cos(angle) * len;
          const y2 = y + Math.sin(angle) * len;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          drawBranch(x2, y2, len*0.7, angle-0.5, depth-1);
          drawBranch(x2, y2, len*0.7, angle+0.5, depth-1);
        }
        drawBranch(0, 80, 40, -Math.PI/2, 4);
        break;
        
      case 'waveform':
        ctx.strokeStyle = 'rgba(0,240,255,0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let x=-120; x<=120; x+=4) {
          const y = Math.sin(x*0.1)*30 + Math.cos(x*0.05)*20;
          if(x===-120) ctx.moveTo(x,y);
          else ctx.lineTo(x,y);
        }
        ctx.stroke();
        break;
        
      case 'starfield':
        for(let j=0; j<80; j++) {
          const x = (Math.random()-0.5)*200;
          const y = (Math.random()-0.5)*200;
          const size = Math.random()*2 + 0.5;
          ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.8 + 0.2})`;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'cyberpunkGrid':
        ctx.strokeStyle = 'rgba(255,0,255,0.3)';
        ctx.lineWidth = 1;
        for(let j=-5; j<=5; j++) {
          ctx.beginPath();
          ctx.moveTo(-100, j*20);
          ctx.lineTo(100, j*20);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(j*20, -100);
          ctx.lineTo(j*20, 100);
          ctx.stroke();
        }
        ctx.fillStyle = 'rgba(0,240,255,0.2)';
        ctx.fillRect(-40, -40, 80, 80);
        break;
    }
    
    ctx.restore();
    
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(0, h-40, w, 40);
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.font = '14px Rajdhani, sans-serif';
    ctx.fillText(TEMPLATE_META[id].name, 12, h-16);
  }, 50 + i*20);
});

const overlay = $('#overlay');
const canvasWrap = $('#canvasWrap');
const overlayUI = $('#overlayUI');
const backBtn = $('#backBtn');
const currentLabel = $('#currentLabel');
const autoplayToggle = $('#autoplayToggle');
const nextBtn = $('#nextBtn');
const autoplayDot = $('#autoplayDot');
const picControlsContainer = $('#picControlsContainer');
const randomBtn = $('#randomBtn');
const helpBtn = $('#helpBtn');

canvasWrap.addEventListener('click', (e)=> {
  if(e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
  uiVisible = !uiVisible;
  if(uiVisible) {
    overlayUI.classList.remove('hidden');
  } else {
    overlayUI.classList.add('hidden');
  }
});

backBtn.addEventListener('click', closeOverlay);
autoplayToggle.addEventListener('click', ()=> {
  autoplay = !autoplay;
  autoplayToggle.classList.toggle('toggled', autoplay);
  autoplayDot.style.display = autoplay ? 'block' : 'none';
  if(autoplay) startAutoplay(); else stopAutoplay();
});
nextBtn.addEventListener('click', ()=> nextTemplate());
randomBtn.addEventListener('click', ()=> {
  const idx = Math.floor(Math.random()*TEMPLATE_IDS.length);
  openTemplate(idx);
});
helpBtn.addEventListener('click', ()=> {
  alert(`dGEN Town — ${TEMPLATE_IDS.length} templates for dGEN1. Click cards to view. Click canvas to hide/show controls. Autoplay switches every 20s.`);
});

function startAutoplay(){
  stopAutoplay();
  autoplayTimer = setInterval(()=> {
    nextTemplate();
  }, 20000);
}
function stopAutoplay(){
  if(autoplayTimer){ clearInterval(autoplayTimer); autoplayTimer = null; }
}

function openTemplate(index){
  index = (index + TEMPLATE_IDS.length) % TEMPLATE_IDS.length;
  currentIndex = index;
  const id = TEMPLATE_IDS[index];
  currentLabel.textContent = TEMPLATE_META[id].name;
  overlay.classList.add('active');
  overlay.setAttribute('aria-hidden','false');
  uiVisible = true;
  overlayUI.classList.remove('hidden');

  canvasWrap.innerHTML = '';
  const canvas = create('canvas', {width:window.innerWidth, height:window.innerHeight});
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  canvasWrap.appendChild(canvas);

  const tmpl = templates[id];
  if(!tmpl) return;
  activeInstance = tmpl.mount(canvas, {onExit: closeOverlay});
  picControlsContainer.innerHTML = '';
  if(id === 'picFrame'){
    const el = createPicControls(activeInstance);
    picControlsContainer.appendChild(el);
  }
}

function closeOverlay(){
  overlay.classList.remove('active');
  overlay.setAttribute('aria-hidden','true');
  if(activeInstance && typeof activeInstance.unmount === 'function') {
    activeInstance.unmount();
    activeInstance = null;
  }
  canvasWrap.innerHTML = '';
}

function nextTemplate(){
  const idx = (currentIndex + 1) % TEMPLATE_IDS.length;
  if(overlay.classList.contains('active')){
    if(activeInstance && typeof activeInstance.unmount === 'function') activeInstance.unmount();
    currentIndex = idx;
    const id = TEMPLATE_IDS[idx];
    currentLabel.textContent = TEMPLATE_META[id].name;
    canvasWrap.innerHTML = '';
    const canvas = create('canvas', {width:window.innerWidth, height:window.innerHeight});
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvasWrap.appendChild(canvas);
    const tmpl = templates[id];
    activeInstance = tmpl.mount(canvas, {onExit: closeOverlay});
    picControlsContainer.innerHTML = '';
    if(id === 'picFrame'){
      const el = createPicControls(activeInstance);
      picControlsContainer.appendChild(el);
    }
  } else {
    openTemplate(idx);
  }
}

function makeRunner(renderFn){
  let running = true;
  let rafId = null;
  function loop(t){
    if(!running) return;
    renderFn(t);
    rafId = requestAnimationFrame(loop);
  }
  rafId = requestAnimationFrame(loop);
  return {
    stop(){ running = false; if(rafId) cancelAnimationFrame(rafId); }
  };
}

function cyberMinimalMount(canvas){
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (t - t0)/1000;
    ctx.clearRect(0,0,w,h);
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, 'rgba(0,0,0,0.9)');
    g.addColorStop(1, 'rgba(10,10,12,0.95)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
    ctx.save();
    ctx.translate(w/2, h/2);
    ctx.rotate(tt*0.18);
    ctx.strokeStyle = 'rgba(0,240,255,0.14)';
    ctx.lineWidth = 6;
    for(let i=0;i<4;i++){
      const s = 220 + Math.sin(tt*0.9 + i)*10;
      ctx.strokeRect(-s/2, -s/2, s, s);
    }
    ctx.restore();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(176,67,255,0.06)';
    ctx.beginPath();
    for(let i=0;i<6;i++){
      const y = h*(i+1)/7 + Math.sin(tt*0.6 + i)*6;
      ctx.moveTo(40, y); ctx.lineTo(w-40, y);
    }
    ctx.stroke();
  });
  return { unmount(){ runner.stop(); } };
}

function cryptoOrbMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const N = 220;
  const pts = new Array(N).fill(0).map((_,i)=>({
    a: Math.random()*Math.PI*2,
    r: 60 + Math.random()*220,
    s: 0.4 + Math.random()*1.4,
    phase: Math.random()*10
  }));
  const runner = makeRunner((t)=>{
    const tsec = (performance.now() - t0)/1000;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = 'rgba(0,0,0,0.96)';
    ctx.fillRect(0,0,W,H);
    const cx = W/2, cy = H/2;
    const grd = ctx.createRadialGradient(cx,cy,10,cx,cy,260);
    grd.addColorStop(0, 'rgba(0,200,255,0.08)');
    grd.addColorStop(0.45, 'rgba(176,67,255,0.03)');
    grd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grd; ctx.fillRect(0,0,W,H);
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0;i<N;i++){
      const p = pts[i];
      const a = p.a + tsec*0.2*(0.6 + p.s*0.3);
      const r = p.r + Math.sin(tsec*0.9 + p.phase)*6;
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r;
      const size = 0.8 + p.s*1.8;
      ctx.beginPath();
      ctx.fillStyle = `rgba(0,240,255,${0.02 + p.s*0.06})`;
      ctx.arc(x,y,size,0,Math.PI*2);
      ctx.fill();
    }
    ctx.globalCompositeOperation = 'source-over';
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,240,255,0.06)';
    ctx.arc(cx, cy, 62 + Math.sin(tsec*0.8)*6, 0, Math.PI*2);
    ctx.fill();
  });
  return { unmount(){ runner.stop(); } };
}

function retroTerminalMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const lines = Array.from({length:30}, ()=> '');
  const ch = 18;
  function randomLine(){
    const hex = '0123456789abcdef';
    let s = '';
    if(Math.random() < 0.2){
      s = 'block ' + Math.floor(Math.random()*999999) + ' detected';
    } else {
      for(let i=0;i<40;i++) s += hex[Math.floor(Math.random()*16)];
    }
    return s;
  }
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.98)';
    ctx.fillRect(0,0,W,H);
    if(Math.random() < 0.28){
      lines.pop();
      lines.unshift(randomLine());
    }
    ctx.font = '16px "Courier New", monospace';
    for(let i=0;i<lines.length;i++){
      const y = 60 + i*ch;
      ctx.fillStyle = (i===0)? 'rgba(0,255,140,0.85)' : 'rgba(0,255,140,0.22)';
      ctx.fillText(lines[i], 22, y);
    }
  });
  return { unmount(){ runner.stop(); } };
}

function zenSpaceMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let s = 0;
  const runner = makeRunner((t)=>{
    const tt = t/1000;
    s = Math.sin(tt*0.12)*0.5 + 0.5;
    const g = ctx.createLinearGradient(0,0,W,H);
    g.addColorStop(0, `rgba(34,36,40,${0.16 + s*0.04})`);
    g.addColorStop(1, `rgba(8,10,12,0.98)`);
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
    ctx.beginPath();
    ctx.fillStyle = `rgba(176,67,255,${0.04 + s*0.06})`;
    ctx.arc(W/2, H/2 - 20, 220 + s*20, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.02)';
    ctx.lineWidth = 1.2;
    for(let i=0;i<5;i++){
      ctx.beginPath();
      const off = Math.sin(tt*0.3 + i)*18;
      ctx.ellipse(W/2, H/2 + off, 200 - i*30, 60, Math.PI/6, 0, Math.PI*2);
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function picFrameMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let running = true;
  let img = null;
  let fitMode = 'cover';
  const runner = makeRunner((t)=>{
    if(!running) return;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#070708';
    ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(36,36,W-72,H-72);
    ctx.restore();
    if(img && img.complete){
      const iw = img.width, ih = img.height;
      let sx=0,sy=0,sw=iw,sh=ih;
      if(fitMode === 'cover'){
        const scale = Math.max((W-120)/iw, (H-120)/ih);
        const dw = iw*scale, dh = ih*scale;
        const dx = (W - dw)/2, dy = (H - dh)/2;
        ctx.drawImage(img, 0,0,iw,ih, dx, dy, dw, dh);
      } else {
        const scale = Math.min((W-120)/iw, (H-120)/ih);
        const dw = iw*scale, dh = ih*scale;
        const dx = (W - dw)/2, dy = (H - dh)/2;
        ctx.drawImage(img, 0,0,iw,ih, dx, dy, dw, dh);
      }
    } else {
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.fillRect(90, 120, W-180, H-240);
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.font = '16px Rajdhani';
      ctx.fillText('Pic Frame', W/2 - 36, H/2 - 6);
      ctx.font = '12px Rajdhani';
      ctx.fillStyle = 'rgba(255,255,255,0.04)';
      ctx.fillText('Upload image or enter image URL', W/2 - 110, H/2 + 16);
    }
    ctx.strokeStyle = 'rgba(0,240,255,0.06)';
    ctx.lineWidth = 2;
    ctx.strokeRect(30,30,W-60,H-60);
  });

  return {
    unmount(){ running=false; runner.stop(); },
    setImageFromFile(file){
      const reader = new FileReader();
      reader.onload = e=>{
        const im = new Image();
        im.onload = ()=> { img = im; };
        im.src = e.target.result;
      };
      reader.readAsDataURL(file);
    },
    setImageFromURL(url){
      const im = new Image();
      im.crossOrigin = 'anonymous';
      im.onload = ()=> { img = im; };
      im.onerror = ()=> { alert('Unable to load image, please check URL or CORS policy'); };
      im.src = url;
    },
    toggleFit(){
      fitMode = (fitMode === 'cover') ? 'contain' : 'cover';
    }
  };
}

function liquidWavesMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now() - t0)/1000;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#040405'; ctx.fillRect(0,0,W,H);
    for(let k=0;k<4;k++){
      ctx.beginPath();
      const amp = 12 + k*8;
      ctx.moveTo(0, H/2);
      for(let x=0;x<=W;x+=6){
        const y = H/2 + Math.sin((x*0.02) + tt*(0.6 + k*0.12) + k)*amp*Math.cos(k*0.2);
        ctx.lineTo(x,y + k*8);
      }
      ctx.strokeStyle = `rgba(0,240,255,${0.04 + k*0.02})`;
      ctx.lineWidth = 1.8;
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function matrixRainMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const cols = Math.floor(W/14);
  const drops = new Array(cols).fill(0).map(()=>Math.floor(Math.random()*H));
  const letters = '01';
  let running = true;
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(0,0,W,H);
    ctx.font = '14px monospace';
    for(let i=0;i<cols;i++){
      const x = i*14;
      ctx.fillStyle = 'rgba(0,255,140,0.08)';
      const text = letters[Math.floor(Math.random()*letters.length)];
      ctx.fillText(text, x, drops[i]);
      drops[i] += 14 + Math.random()*10;
      if(drops[i] > H + 20) drops[i] = -20*Math.random();
    }
  });
  return { unmount(){ running=false; runner.stop(); } };
}

function hexGridPulseMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const size = 36;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#070708'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    const cols = Math.ceil(W/size)+4;
    for(let x=-cols;x<cols;x++){
      for(let y=-cols;y<cols;y++){
        const px = x*size*0.86 + (y%2? size*0.43:0);
        const py = y*(size*0.75);
        const d = Math.hypot(px,py);
        const pulse = 0.6 + 0.4*Math.sin(d*0.06 - tt*2);
        const a = 0.03 + 0.06*(1-pulse);
        ctx.beginPath();
        ctx.moveTo(px + size*0.5, py);
        for(let k=1;k<6;k++){
          const ang = (Math.PI*2/6)*k;
          ctx.lineTo(px + Math.cos(ang)*size*0.5, py + Math.sin(ang)*size*0.5);
        }
        ctx.closePath();
        ctx.fillStyle = `rgba(0,240,255,${a})`;
        ctx.fill();
      }
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function clockSyncMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let running = true;
  const runner = makeRunner((t)=>{
    ctx.fillStyle = '#010101'; ctx.fillRect(0,0,W,H);
    const now = new Date();
    const s = now.getSeconds(), m = now.getMinutes(), hr = now.getHours()%12;
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.beginPath(); ctx.arc(0,0,220,0,Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.02)'; ctx.fill();
    for(let i=0;i<60;i++){
      const ang = i*(Math.PI*2/60) - Math.PI/2;
      const r1 = 200, r2 = (i%5===0 ? 190 : 194);
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.lineWidth = (i%5===0)?2:1;
      ctx.beginPath();
      ctx.moveTo(Math.cos(ang)*r1, Math.sin(ang)*r1);
      ctx.lineTo(Math.cos(ang)*r2, Math.sin(ang)*r2);
      ctx.stroke();
    }
    const angS = s*(Math.PI*2/60) - Math.PI/2;
    const angM = (m + s/60)*(Math.PI*2/60) - Math.PI/2;
    const angH = (hr + m/60)*(Math.PI*2/12) - Math.PI/2;
    ctx.strokeStyle = 'rgba(176,67,255,0.9)'; ctx.lineWidth=6;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(angH)*110, Math.sin(angH)*110); ctx.stroke();
    ctx.strokeStyle = 'rgba(0,240,255,0.96)'; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(angM)*150, Math.sin(angM)*150); ctx.stroke();
    ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth=1.6;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(angS)*180, Math.sin(angS)*180); ctx.stroke();
    ctx.restore();
  });
  return { unmount(){ running=false; runner.stop(); } };
}

function codeVerseMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const snippets = [
    'function syncBlock(){ /* destiny */ }',
    'const tx = broadcast(wallet.sign(tx))',
    'for await (const block of chain) { /* listen */ }',
    'if (nonce++ > 100) { revive(); }',
    'let entropy = crypto.getRandomValues(new Uint8Array(32))'
  ];
  let lines = new Array(24).fill('');
  const runner = makeRunner((t)=>{
    ctx.fillStyle = '#040405'; ctx.fillRect(0,0,W,H);
    if(Math.random() < 0.35){
      lines.pop();
      lines.unshift(snippets[Math.floor(Math.random()*snippets.length)]);
    }
    ctx.font = '14px "Courier New", monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    for(let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], 22, 60 + i*20);
    }
  });
  return { unmount(){ runner.stop(); } };
}

function aiBloomMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#050507'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let k=0;k<18;k++){
      const ang = (k/18)*Math.PI*2 + tt*0.06;
      const r = 80 + Math.sin(tt*0.9 + k)*80;
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(Math.cos(ang)*r/2, Math.sin(ang)*r/2, r*0.6, ang-0.8, ang+0.8);
      ctx.fillStyle = `rgba(176,67,255,${0.03 + k*0.002})`;
      ctx.fill();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function signatureLoopMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const lines = [];
  for(let i=0;i<6;i++){
    const pts = [];
    for(let j=0;j<30;j++){
      pts.push({x: Math.random()*W, y: Math.random()*H});
    }
    lines.push(pts);
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#020202'; ctx.fillRect(0,0,W,H);
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0;i<lines.length;i++){
      const pts = lines[i];
      ctx.beginPath();
      for(let j=0;j<pts.length;j++){
        const p = pts[j];
        const nx = p.x + Math.sin(tt*0.6 + i + j)*12;
        const ny = p.y + Math.cos(tt*0.4 + i - j)*12;
        if(j===0) ctx.moveTo(nx, ny); else ctx.lineTo(nx, ny);
      }
      ctx.strokeStyle = `rgba(0,240,255,${0.03 + i*0.03})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.globalCompositeOperation = 'source-over';
  });
  return { unmount(){ runner.stop(); } };
}

function neonCityMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const buildings = Array.from({length:20}, ()=>({
    x: Math.random()*W,
    h: 100 + Math.random()*300,
    w: 40 + Math.random()*60,
    color: Math.random() > 0.5 ? 'rgba(255,0,255,0.6)' : 'rgba(0,240,255,0.6)'
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    for(let i=0;i<buildings.length;i++){
      const b = buildings[i];
      const flicker = 0.8 + Math.sin(tt*3 + i)*0.2;
      ctx.fillStyle = b.color.replace('0.6', (0.3*flicker).toString());
      ctx.fillRect(b.x, H-b.h, b.w, b.h);
      ctx.strokeStyle = b.color;
      ctx.lineWidth = 2;
      ctx.strokeRect(b.x, H-b.h, b.w, b.h);
      for(let j=0;j<5;j++){
        if(Math.random() > 0.3){
          ctx.fillStyle = 'rgba(255,255,200,0.4)';
          ctx.fillRect(b.x + 10, H-b.h + 20 + j*40, 10, 10);
        }
      }
    }
    ctx.fillStyle = 'rgba(255,0,255,0.3)';
    ctx.fillRect(0, H-10, W, 10);
  });
  return { unmount(){ runner.stop(); } };
}

function glitchArtMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    if(Math.random() > 0.7){
      const slices = 10 + Math.floor(Math.random()*20);
      for(let i=0;i<slices;i++){
        const y = Math.random()*H;
        const h = 5 + Math.random()*30;
        const offset = (Math.random()-0.5)*50;
        ctx.fillStyle = `rgba(${Math.random()*255},${Math.random()*255},255,0.3)`;
        ctx.fillRect(offset, y, W, h);
      }
    }
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = 'rgba(255,0,0,0.1)';
    ctx.fillRect(W/2 - 100 + Math.sin(tt*2)*10, H/2 - 100, 200, 200);
    ctx.fillStyle = 'rgba(0,255,0,0.1)';
    ctx.fillRect(W/2 - 100, H/2 - 100 + Math.cos(tt*2)*10, 200, 200);
    ctx.fillStyle = 'rgba(0,0,255,0.1)';
    ctx.fillRect(W/2 - 100 - Math.sin(tt*2)*10, H/2 - 100, 200, 200);
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function vaporwaveMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    const grd = ctx.createLinearGradient(0,0,0,H);
    grd.addColorStop(0, '#ff00ff');
    grd.addColorStop(0.5, '#00ffff');
    grd.addColorStop(1, '#000');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H*0.7);
    ctx.rotate(-0.3);
    ctx.strokeStyle = 'rgba(255,0,255,0.3)';
    ctx.lineWidth = 2;
    for(let i=-10;i<=10;i++){
      const y = i*40;
      const scale = 1 + y*0.002;
      ctx.beginPath();
      ctx.moveTo(-W*scale, y);
      ctx.lineTo(W*scale, y);
      ctx.stroke();
    }
    for(let i=-10;i<=10;i++){
      ctx.beginPath();
      ctx.moveTo(i*60, -200);
      ctx.lineTo(i*60*1.5, 400);
      ctx.stroke();
    }
    ctx.restore();
    const sunY = H*0.3 + Math.sin(tt*0.5)*20;
    const grd2 = ctx.createRadialGradient(W/2,sunY,0,W/2,sunY,150);
    grd2.addColorStop(0, 'rgba(255,200,0,0.8)');
    grd2.addColorStop(0.5, 'rgba(255,0,255,0.4)');
    grd2.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grd2;
    ctx.fillRect(0,0,W,H);
  });
  return { unmount(){ runner.stop(); } };
}

function hologramMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0;i<8;i++){
      const r = 50 + i*40 + Math.sin(tt + i)*10;
      const alpha = 0.4 - i*0.04;
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(0,240,255,${alpha})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    for(let i=0;i<12;i++){
      const ang = (i/12)*Math.PI*2 + tt*0.5;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(Math.cos(ang)*300, Math.sin(ang)*300);
      ctx.strokeStyle = `rgba(0,240,255,${0.1 + Math.sin(tt + i)*0.05})`;
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function pixelStormMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const pixels = Array.from({length:200}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    vx: (Math.random()-0.5)*4,
    vy: (Math.random()-0.5)*4,
    size: 4 + Math.random()*8,
    color: `rgb(${Math.random()*255},${Math.random()*255},255)`
  }));
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    for(let i=0;i<pixels.length;i++){
      const p = pixels[i];
      p.x += p.vx;
      p.y += p.vy;
      if(p.x < 0 || p.x > W) p.vx *= -1;
      if(p.y < 0 || p.y > H) p.vy *= -1;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    }
  });
  return { unmount(){ runner.stop(); } };
}

function scanlinesMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = 'rgba(0,255,140,0.2)';
    ctx.lineWidth = 1;
    for(let y=0;y<H;y+=3){
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }
    const scanY = (tt*100) % H;
    ctx.fillStyle = 'rgba(0,255,140,0.3)';
    ctx.fillRect(0, scanY, W, 20);
    ctx.fillStyle = 'rgba(0,240,255,0.2)';
    ctx.fillRect(W/2-150, H/2-150, 300, 300);
    ctx.strokeStyle = 'rgba(0,240,255,0.6)';
    ctx.lineWidth = 2;
    ctx.strokeRect(W/2-150, H/2-150, 300, 300);
  });
  return { unmount(){ runner.stop(); } };
}

function dataStreamMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const streams = Array.from({length:30}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    speed: 2 + Math.random()*5,
    data: Array.from({length:10}, ()=>Math.random().toString(2).substr(2,8))
  }));
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    ctx.font = '12px monospace';
    for(let i=0;i<streams.length;i++){
      const s = streams[i];
      s.y += s.speed;
      if(s.y > H) s.y = -100;
      for(let j=0;j<s.data.length;j++){
        const alpha = 0.8 - j*0.08;
        ctx.fillStyle = `rgba(0,240,255,${alpha})`;
        ctx.fillText(s.data[j], s.x, s.y + j*15);
      }
    }
  });
  return { unmount(){ runner.stop(); } };
}

function particleNebulaMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const particles = Array.from({length:500}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    vx: (Math.random()-0.5)*0.5,
    vy: (Math.random()-0.5)*0.5,
    size: Math.random()*3,
    alpha: Math.random()
  }));
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0;i<particles.length;i++){
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      if(p.x < 0) p.x = W;
      if(p.x > W) p.x = 0;
      if(p.y < 0) p.y = H;
      if(p.y > H) p.y = 0;
      ctx.fillStyle = `rgba(176,67,255,${p.alpha*0.5})`;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    }
    ctx.globalCompositeOperation = 'source-over';
  });
  return { unmount(){ runner.stop(); } };
}

function geometricDanceMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0;i<8;i++){
      ctx.save();
      ctx.rotate((i/8)*Math.PI*2 + tt*0.5);
      ctx.translate(150 + Math.sin(tt + i)*50, 0);
      ctx.rotate(tt*2);
      const size = 40 + Math.sin(tt*3 + i)*20;
      ctx.strokeStyle = `rgba(0,240,255,${0.4 + Math.sin(tt + i)*0.2})`;
      ctx.lineWidth = 3;
      if(i % 2 === 0){
        ctx.strokeRect(-size/2, -size/2, size, size);
      } else {
        ctx.beginPath();
        ctx.arc(0, 0, size/2, 0, Math.PI*2);
        ctx.stroke();
      }
      ctx.restore();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function synthwaveMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    const grd = ctx.createLinearGradient(0,0,0,H);
    grd.addColorStop(0, '#1a0033');
    grd.addColorStop(0.5, '#330066');
    grd.addColorStop(1, '#000');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H*0.8);
    ctx.scale(1, 0.5);
    ctx.strokeStyle = 'rgba(255,0,255,0.4)';
    ctx.lineWidth = 2;
    for(let i=-15;i<=15;i++){
      const y = i*30 - (tt*50 % 30);
      ctx.beginPath();
      ctx.moveTo(-W, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }
    for(let i=-10;i<=10;i++){
      ctx.beginPath();
      ctx.moveTo(i*60, -300);
      ctx.lineTo(i*60, 300);
      ctx.stroke();
    }
    ctx.restore();
    ctx.fillStyle = 'rgba(255,0,128,0.3)';
    ctx.beginPath();
    ctx.moveTo(0, H*0.6);
    for(let x=0;x<=W;x+=20){
      const y = H*0.6 - Math.sin(x*0.01 + tt)*50 - Math.cos(x*0.02)*30;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(W, H);
    ctx.lineTo(0, H);
    ctx.fill();
  });
  return { unmount(){ runner.stop(); } };
}

function digitalRainMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const cols = Math.floor(W/20);
  const drops = Array.from({length:cols}, ()=>({
    y: Math.random()*H,
    speed: 3 + Math.random()*7,
    chars: Array.from({length:15}, ()=>String.fromCharCode(0x30A0 + Math.random()*96))
  }));
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    ctx.font = '16px monospace';
    for(let i=0;i<cols;i++){
      const d = drops[i];
      d.y += d.speed;
      if(d.y > H + 200) d.y = -200;
      for(let j=0;j<d.chars.length;j++){
        const alpha = 0.8 - j*0.05;
        ctx.fillStyle = `rgba(0,255,140,${alpha})`;
        ctx.fillText(d.chars[j], i*20, d.y + j*20);
      }
    }
  });
  return { unmount(){ runner.stop(); } };
}

function cosmicVoidMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const stars = Array.from({length:200}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    z: Math.random()*1000,
    size: Math.random()*2
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    for(let i=0;i<stars.length;i++){
      const s = stars[i];
      s.z -= 5;
      if(s.z <= 0) s.z = 1000;
      const x = (s.x - W/2) * (1000/s.z) + W/2;
      const y = (s.y - H/2) * (1000/s.z) + H/2;
      const size = s.size * (1000/s.z);
      const alpha = 1 - s.z/1000;
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.fillRect(x, y, size, size);
    }
    const grd = ctx.createRadialGradient(W/2,H/2,0,W/2,H/2,200);
    grd.addColorStop(0, 'rgba(128,0,255,0.3)');
    grd.addColorStop(0.5, 'rgba(0,0,128,0.1)');
    grd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,W,H);
  });
  return { unmount(){ runner.stop(); } };
}

function fractalTreeMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  function drawBranch(x, y, len, angle, depth, t) {
    if(depth === 0) return;
    const x2 = x + Math.cos(angle) * len;
    const y2 = y + Math.sin(angle) * len;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x2, y2);
    const alpha = 0.6 - depth*0.08;
    ctx.strokeStyle = `rgba(0,240,255,${alpha})`;
    ctx.lineWidth = depth;
    ctx.stroke();
    const angleOffset = Math.sin(t + depth)*0.2;
    drawBranch(x2, y2, len*0.7, angle-0.5+angleOffset, depth-1, t);
    drawBranch(x2, y2, len*0.7, angle+0.5+angleOffset, depth-1, t);
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    drawBranch(W/2, H-50, 100, -Math.PI/2, 8, tt);
  });
  return { unmount(){ runner.stop(); } };
}

function waveformMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    for(let layer=0;layer<5;layer++){
      ctx.beginPath();
      ctx.moveTo(0, H/2);
      for(let x=0;x<=W;x+=5){
        const y = H/2 + 
          Math.sin((x*0.01) + tt*(1 + layer*0.2))*30 +
          Math.cos((x*0.02) + tt*(0.5 + layer*0.1))*20 +
          layer*15;
        if(x===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.strokeStyle = `rgba(0,240,255,${0.5 - layer*0.08})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.fillStyle = 'rgba(176,67,255,0.3)';
    for(let i=0;i<50;i++){
      const h = 50 + Math.sin(tt*3 + i*0.5)*40 + Math.random()*20;
      ctx.fillRect(i*(W/50), H-h, W/50-2, h);
    }
  });
  return { unmount(){ runner.stop(); } };
}

function starfieldMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const stars = Array.from({length:300}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    size: Math.random()*2 + 0.5,
    speed: Math.random()*0.5 + 0.1,
    brightness: Math.random()
  }));
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,5,0.2)'; ctx.fillRect(0,0,W,H);
    for(let i=0;i<stars.length;i++){
      const s = stars[i];
      s.y += s.speed;
      if(s.y > H) {
        s.y = 0;
        s.x = Math.random()*W;
      }
      s.brightness = 0.3 + Math.sin(t*0.001 + i)*0.7;
      ctx.fillStyle = `rgba(255,255,255,${s.brightness})`;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
      ctx.fill();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function cyberpunkGridMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = 'rgba(255,0,255,0.2)';
    ctx.lineWidth = 1;
    const gridSize = 40;
    for(let x=0;x<W;x+=gridSize){
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, H);
      ctx.stroke();
    }
    for(let y=0;y<H;y+=gridSize){
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }
    for(let i=0;i<10;i++){
      const x = ((tt*50 + i*100) % W);
      const y = ((tt*30 + i*80) % H);
      const grd = ctx.createRadialGradient(x,y,0,x,y,60);
      grd.addColorStop(0, 'rgba(0,240,255,0.4)');
      grd.addColorStop(1, 'rgba(0,240,255,0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x-60, y-60, 120, 120);
    }
    ctx.fillStyle = 'rgba(255,0,255,0.2)';
    ctx.fillRect(W/2-100, H/2-100, 200, 200);
    ctx.strokeStyle = 'rgba(0,240,255,0.8)';
    ctx.lineWidth = 3;
    ctx.strokeRect(W/2-100, H/2-100, 200, 200);
  });
  return { unmount(){ runner.stop(); } };
}

const templates = {
  cyberMinimal: { mount: cyberMinimalMount },
  cryptoOrb: { mount: cryptoOrbMount },
  retroTerminal: { mount: retroTerminalMount },
  zenSpace: { mount: zenSpaceMount },
  picFrame: { mount: picFrameMount },
  liquidWaves: { mount: liquidWavesMount },
  matrixRain: { mount: matrixRainMount },
  hexGridPulse: { mount: hexGridPulseMount },
  clockSync: { mount: clockSyncMount },
  codeVerse: { mount: codeVerseMount },
  aiBloom: { mount: aiBloomMount },
  signatureLoop: { mount: signatureLoopMount },
  neonCity: { mount: neonCityMount },
  glitchArt: { mount: glitchArtMount },
  vaporwave: { mount: vaporwaveMount },
  hologram: { mount: hologramMount },
  pixelStorm: { mount: pixelStormMount },
  scanlines: { mount: scanlinesMount },
  dataStream: { mount: dataStreamMount },
  particleNebula: { mount: particleNebulaMount },
  geometricDance: { mount: geometricDanceMount },
  synthwave: { mount: synthwaveMount },
  digitalRain: { mount: digitalRainMount },
  cosmicVoid: { mount: cosmicVoidMount },
  fractalTree: { mount: fractalTreeMount },
  waveform: { mount: waveformMount },
  starfield: { mount: starfieldMount },
  cyberpunkGrid: { mount: cyberpunkGridMount }
};

function createPicControls(instance){
  const box = create('div', {class:'pic-controls'});
  const fileBtn = create('input', {type:'file', class:'input'});
  fileBtn.accept = 'image/*';
  fileBtn.addEventListener('change', (e)=>{
    const f = e.target.files && e.target.files[0];
    if(f) instance.setImageFromFile(f);
  });
  box.appendChild(fileBtn);

  const urlInput = create('input', {type:'text', placeholder:'Enter image URL', class:'input'});
  urlInput.style.width = '220px';
  urlInput.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter'){
      const url = urlInput.value.trim();
      if(url) instance.setImageFromURL(url);
    }
  });
  box.appendChild(urlInput);

  const fitBtn = create('button', {class:'btn', html:'Toggle Fit'});
  fitBtn.addEventListener('click', ()=>{
    if(typeof instance.toggleFit === 'function') instance.toggleFit();
  });
  box.appendChild(fitBtn);

  const clearBtn = create('button', {class:'btn', html:'Clear'});
  clearBtn.addEventListener('click', ()=> {
    if(activeInstance && activeInstance.unmount) activeInstance.unmount();
    const canvas = create('canvas', {width:window.innerWidth, height:window.innerHeight});
    canvas.style.width='100%'; canvas.style.height='100%';
    canvasWrap.innerHTML = '';
    canvasWrap.appendChild(canvas);
    const id = TEMPLATE_IDS[currentIndex];
    activeInstance = templates[id].mount(canvas);
    picControlsContainer.innerHTML = '';
    picControlsContainer.appendChild(createPicControls(activeInstance));
  });
  box.appendChild(clearBtn);

  return box;
}

window.addEventListener('beforeunload', ()=>{
  stopAutoplay();
  if(activeInstance && typeof activeInstance.unmount === 'function') activeInstance.unmount();
});

window.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape') closeOverlay();
  if(e.key === 'ArrowRight') nextTemplate();
  if(e.key === 'ArrowLeft') {
    const idx = (currentIndex - 1 + TEMPLATE_IDS.length) % TEMPLATE_IDS.length;
    openTemplate(idx);
  }
});

autoplayToggle.classList.toggle('toggled', autoplay);

</script>
</body>
</html>
