<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LumaGEN</title>
<link rel="icon" href="https://purple-payable-felidae-371.mypinata.cloud/ipfs/bafybeigds36kzucrp4uzxvyf2q2oqmda2od2i62h3ld4pcz62tqq5ox3wy" type="image/png" />

<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#000000;
    --muted:#0f1112;
    --accent1:#00f0ff;
    --accent2:#b043ff;
    --glass: rgba(255,255,255,0.04);
    --text: rgba(255,255,255,0.9);
    --small: 12px;
  }
  html,body{
    height:100%;
    margin:0;
    background:var(--bg);
    color:var(--text);
    font-family: "Rajdhani", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  .stage {
    width:100vw;
    height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    box-sizing:border-box;
  }

  .frame {
    width:100%;
    height:100%;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    overflow:hidden;
    position:relative;
    border:none;
  }

  .grain {
    position:absolute;
    inset:0;
    pointer-events:none;
    background-image: radial-gradient(rgba(255,255,255,0.015) 1px, transparent 1px);
    background-size: 3px 3px;
    opacity:0.6;
    mix-blend-mode: overlay;
  }

  header {
    position:absolute;
    top:18px;
    left:20px;
    right:20px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    z-index:50;
    pointer-events:none;
  }

  .title {
    display:flex;
		flex-direction: column;
    align-items:center;
    gap:4px;
    pointer-events:auto;
  }

  .logo {
    font-family: "Orbitron", monospace;
    font-weight:700;
    color:var(--accent1);
    font-size:18px;
    letter-spacing:1px;
    opacity:0.95;
    text-shadow: 0 2px 18px rgba(0,240,255,0.06);
    background: linear-gradient(90deg, rgba(0,240,255,0.12), rgba(176,67,255,0.04));
    padding:6px 10px;
    border-radius:8px;
  }

  .title h1{
    margin:0;
    font-size:18px;
    color:rgba(255,255,255,0.92);
    letter-spacing:1px;
  }
  .title p{ margin:0; font-size:12px; color:rgba(255,255,255,0.35);}

  .controls {
    display:flex;
    gap:10px;
    align-items:center;
    pointer-events:auto;
  }

  .btn {
    background:var(--glass);
    border:1px solid rgba(255,255,255,0.03);
    padding:8px 10px;
    border-radius:8px;
    cursor:pointer;
    color:var(--text);
    font-size:13px;
    display:inline-flex;
    gap:8px;
    align-items:center;
    transition:transform .18s ease, box-shadow .18s ease;
    user-select:none;
  }
  .btn:hover{ transform:translateY(-4px); box-shadow: 0 8px 28px rgba(0,0,0,0.5); }
  .btn.toggled { background: linear-gradient(90deg, rgba(0,240,255,0.06), rgba(176,67,255,0.02)); }

  .gallery {
    padding:88px 36px 36px 36px;
    box-sizing:border-box;
    height:100%;
    display:grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    grid-auto-rows: minmax(180px, 1fr);
    gap:18px;
    z-index:10;
    overflow-y:auto;
  }

  .card {
    border-radius:8px;
    overflow:hidden;
    background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
    border:1px solid rgba(255,255,255,0.02);
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    cursor:pointer;
    transition:transform .25s ease, box-shadow .25s ease;
  }
  .card:hover { transform: translateY(-8px); box-shadow: 0 14px 40px rgba(0,0,0,0.7); }
  .card canvas { width:100%; height:100%; display:block; }

  .card .label {
    position:absolute;
    left:12px;
    bottom:8px;
    font-size:12px;
    color:rgba(255,255,255,0.9);
    background: linear-gradient(180deg, rgba(0,0,0,0.25), rgba(255,255,255,0.02));
    padding:6px 8px;
    border-radius:6px;
    backdrop-filter: blur(4px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.6);
  }

  .overlay {
    position:absolute;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    z-index:60;
    background: linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.65));
    backdrop-filter: blur(6px);
  }
  .overlay.active { display:flex; animation:overlayIn .35s ease both; }
  @keyframes overlayIn { from{opacity:0; transform:scale(.995);} to{opacity:1; transform:none;} }

  .canvas-wrap{
    width:100%;
    height:100%;
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
    background:transparent;
    cursor:pointer;
  }

  .overlay-ui {
    position:absolute;
    inset:18px;
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    pointer-events:none;
    transition: opacity 0.3s ease, transform 0.3s ease;
  }
  
  .overlay-ui.hidden {
    opacity:0;
    transform:translateY(-10px);
    pointer-events:none;
  }
  
  .overlay-left, .overlay-right {
    pointer-events:auto;
    display:flex;
    gap:10px;
    align-items:center;
  }
  .back-btn {
    background:transparent;
    border:1px solid rgba(255,255,255,0.06);
    color:var(--text);
    padding:8px 10px;
    border-radius:8px;
    cursor:pointer;
    backdrop-filter: blur(6px);
  }
  .small {
    font-size:12px;
    color:rgba(255,255,255,0.7);
    opacity:0.9;
  }

  .bubble {
    position:absolute;
    right:18px;
    bottom:18px;
    pointer-events:auto;
    display:flex;
    gap:10px;
    align-items:center;
  }
  .dot {
    width:10px;height:10px;border-radius:50%;
    background:var(--accent1);
    box-shadow:0 6px 20px rgba(0,240,255,0.08);
    opacity:0.9;
  }

  .micro {
    position:absolute;
    left:18px;
    bottom:18px;
    font-size:11px;
    color:rgba(255,255,255,0.28);
    pointer-events:auto;
  }

  .pic-controls {
    display:flex;
    gap:8px;
    align-items:center;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:8px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.03);
  }
  .input {
    background:transparent;border:1px dashed rgba(255,255,255,0.06);padding:6px;border-radius:6px;color:var(--text);font-size:12px;
  }

  @media (max-width:800px){
    .gallery{ grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); padding:80px 20px 20px 20px; }
  }

</style>
</head>
<body>
  <div class="stage">
    <div class="frame" role="application" aria-label="dGEN Town visual frame">
      <div class="grain" aria-hidden="true"></div>

      <header>
        <div class="title">
          <div class="logo">LumaGEN</div>
          <div>
            <p style="margin-top:4px;">Where dGEN1s come to shine</p>
          </div>
        </div>

        <div class="controls">
          <button id="autoplayToggle" class="btn" title="Toggle autoplay">Autoplay</button>
					<select id="autoplayInterval">
						<option value="5000">5s</option>
						<option value="10000">10s</option>
						<option value="20000" selected>20s</option>
						<option value="60000">60s</option>
					</select>
          <button id="randomBtn" class="btn" title="Random template">Random</button>
          <button id="helpBtn" class="btn" title="Help/Info">Info</button>
        </div>
      </header>

      <main class="gallery" id="gallery" aria-hidden="false"></main>

      <div class="micro">LumaGEN · © 2025</div>

      <div class="overlay" id="overlay" aria-hidden="true">
        <div class="canvas-wrap" id="canvasWrap"></div>

        <div class="overlay-ui" id="overlayUI" aria-hidden="false">
          <div class="overlay-left">
            <button id="backBtn" class="back-btn" title="Back to gallery">← Back</button>
            <div class="small" id="currentLabel">—</div>
          </div>
          <div class="overlay-right" style="align-items:center">
            <div id="picControlsContainer"></div>
            <div class="bubble">
              <div class="dot" id="autoplayDot" style="display:none"></div>
              <div class="small">Auto</div>
              <button id="nextBtn" class="btn" title="Next template">Next</button>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

<script>
const $ = sel => document.querySelector(sel);
const create = (tag, attrs={}, parent=null) => {
  const el = document.createElement(tag);
  Object.entries(attrs).forEach(([k,v])=>{
    if(k === 'class') el.className = v;
    else if(k === 'html') el.innerHTML = v;
    else el.setAttribute(k, v);
  });
  if(parent) parent.appendChild(el);
  return el;
};

const TEMPLATE_IDS = [
  'cyberMinimal','cryptoOrb','retroTerminal','zenSpace',
  'liquidWaves','matrixRain','hexGridPulse',
  'clockSync','codeVerse','aiBloom','signatureLoop',
  'neonCity','glitchArt','vaporwave','hologram',
  'pixelStorm','scanlines','dataStream','particleNebula',
  'geometricDance','synthwave','digitalRain','cosmicVoid',
  'fractalTree','waveform','starfield','cyberpunkGrid',
  'dnaHelix','liquidMetal','quantumEntangle','neuralNet',
  'crystalGrowth','radarScan','energyShield','spectrumAnalyzer',
  'particleExplosion','rippleEffect','nebulaSwirl','binaryClock',
  'magneticField','fiberNetwork','quantumWave','cyberEye',
  'pulseWave','mandelbrotSet','kaleidoscope','laserShow',
  'blackHole','circuitBoard','audioVisualizer','timeTunnel','plasmaStorm'
];

const TEMPLATE_META = {
  cyberMinimal: {name:'Cyber Minimal'},
  cryptoOrb: {name:'Crypto Orb'},
  retroTerminal: {name:'Retro Terminal'},
  zenSpace: {name:'Zen Space'},
  liquidWaves: {name:'Liquid Waves'},
  matrixRain: {name:'Matrix Rain'},
  hexGridPulse: {name:'Hex Grid Pulse'},
  clockSync: {name:'Clock Sync'},
  codeVerse: {name:'Code Verse'},
  aiBloom: {name:'AI Bloom'},
  signatureLoop: {name:'Signature Loop'},
  neonCity: {name:'Neon City'},
  glitchArt: {name:'Glitch Art'},
  vaporwave: {name:'Vaporwave'},
  hologram: {name:'Hologram'},
  pixelStorm: {name:'Pixel Storm'},
  scanlines: {name:'Scanlines'},
  dataStream: {name:'Data Stream'},
  particleNebula: {name:'Particle Nebula'},
  geometricDance: {name:'Geometric Dance'},
  synthwave: {name:'Synthwave'},
  digitalRain: {name:'Digital Rain'},
  cosmicVoid: {name:'Cosmic Void'},
  fractalTree: {name:'Fractal Tree'},
  waveform: {name:'Waveform'},
  starfield: {name:'Starfield'},
  cyberpunkGrid: {name:'Cyberpunk Grid'},
  dnaHelix: {name:'DNA Helix'},
  liquidMetal: {name:'Liquid Metal'},
  quantumEntangle: {name:'Quantum Entangle'},
  neuralNet: {name:'Neural Network'},
  crystalGrowth: {name:'Crystal Growth'},
  radarScan: {name:'Radar Scan'},
  energyShield: {name:'Energy Shield'},
  spectrumAnalyzer: {name:'Spectrum Analyzer'},
  particleExplosion: {name:'Particle Explosion'},
  rippleEffect: {name:'Ripple Effect'},
  nebulaSwirl: {name:'Nebula Swirl'},
  binaryClock: {name:'Binary Clock'},
  magneticField: {name:'Magnetic Field'},
  fiberNetwork: {name:'Fiber Network'},
  quantumWave: {name:'Quantum Wave'},
  cyberEye: {name:'Cyber Eye'},
  pulseWave: {name:'Pulse Wave'},
  mandelbrotSet: {name:'Mandelbrot Set'},
  kaleidoscope: {name:'Kaleidoscope'},
  laserShow: {name:'Laser Show'},
  blackHole: {name:'Black Hole'},
  circuitBoard: {name:'Circuit Board'},
  audioVisualizer: {name:'Audio Visualizer'},
  timeTunnel: {name:'Time Tunnel'},
  plasmaStorm: {name:'Plasma Storm'}
};

let autoplay = false;
let autoplayTimer = null;
let currentIndex = -1;
let activeInstance = null;
let uiVisible = true;

const gallery = $('#gallery');
TEMPLATE_IDS.forEach((id, i)=>{
  const card = create('div', {class:'card', id:'card-'+id}, gallery);
  const thumb = create('canvas', {width:300, height:300}, card);
  const label = create('div', {class:'label', html: TEMPLATE_META[id].name}, card);

  card.addEventListener('click', ()=> openTemplate(i));
  
  setTimeout(()=> {
    const ctx = thumb.getContext('2d');
    const w = thumb.width, h = thumb.height;
    
    ctx.fillStyle = '#0a0a0c';
    ctx.fillRect(0,0,w,h);
    
    ctx.save();
    ctx.translate(w/2, h/2);
    
    switch(id) {
      case 'cyberMinimal':
        ctx.strokeStyle = 'rgba(0,240,255,0.4)';
        ctx.lineWidth = 3;
        ctx.strokeRect(-60, -60, 120, 120);
        ctx.rotate(Math.PI/4);
        ctx.strokeStyle = 'rgba(176,67,255,0.3)';
        ctx.strokeRect(-50, -50, 100, 100);
        break;
        
      case 'cryptoOrb':
        const grd = ctx.createRadialGradient(0,0,10,0,0,80);
        grd.addColorStop(0, 'rgba(0,240,255,0.6)');
        grd.addColorStop(0.5, 'rgba(176,67,255,0.3)');
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd;
        ctx.fillRect(-100,-100,200,200);
        break;
        
      case 'retroTerminal':
        ctx.font = '14px monospace';
        ctx.fillStyle = 'rgba(0,255,140,0.6)';
        for(let j=0; j<8; j++) {
          ctx.fillText('> 0x' + Math.random().toString(16).substr(2,8), -120, -60 + j*20);
        }
        break;
        
      case 'zenSpace':
        ctx.beginPath();
        ctx.arc(0,0,80,0,Math.PI*2);
        ctx.fillStyle = 'rgba(176,67,255,0.25)';
        ctx.fill();
        break;
        
      case 'liquidWaves':
        ctx.strokeStyle = 'rgba(0,240,255,0.4)';
        ctx.lineWidth = 2;
        for(let j=0; j<5; j++) {
          ctx.beginPath();
          for(let x=-120; x<=120; x+=10) {
            const y = Math.sin(x*0.05 + j*0.5)*20 + j*10 - 40;
            if(x===-120) ctx.moveTo(x,y);
            else ctx.lineTo(x,y);
          }
          ctx.stroke();
        }
        break;
        
      case 'matrixRain':
        ctx.font = '16px monospace';
        ctx.fillStyle = 'rgba(0,255,140,0.5)';
        for(let j=0; j<15; j++) {
          const x = (j-7)*20;
          const y = (j%3)*30 - 40;
          ctx.fillText(Math.random()>0.5?'1':'0', x, y);
        }
        break;
        
      case 'hexGridPulse':
        ctx.strokeStyle = 'rgba(0,240,255,0.3)';
        ctx.lineWidth = 2;
        for(let hx=-2; hx<=2; hx++) {
          for(let hy=-2; hy<=2; hy++) {
            const px = hx*30 + (hy%2?15:0);
            const py = hy*26;
            ctx.beginPath();
            for(let k=0; k<6; k++) {
              const ang = (Math.PI*2/6)*k;
              const x = px + Math.cos(ang)*15;
              const y = py + Math.sin(ang)*15;
              if(k===0) ctx.moveTo(x,y);
              else ctx.lineTo(x,y);
            }
            ctx.closePath();
            ctx.stroke();
          }
        }
        break;
        
      case 'clockSync':
        ctx.beginPath();
        ctx.arc(0,0,70,0,Math.PI*2);
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.strokeStyle = 'rgba(0,240,255,0.6)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(0,-50);
        ctx.stroke();
        break;
        
      case 'codeVerse':
        ctx.font = '12px monospace';
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        const snippets = ['function()', 'const x =', 'if (true)', '{ code }', 'return;'];
        snippets.forEach((s,j)=>{
          ctx.fillText(s, -60, -40 + j*20);
        });
        break;
        
      case 'aiBloom':
        for(let j=0; j<12; j++) {
          const ang = (j/12)*Math.PI*2;
          ctx.beginPath();
          ctx.moveTo(0,0);
          ctx.arc(Math.cos(ang)*40, Math.sin(ang)*40, 30, ang-0.5, ang+0.5);
          ctx.fillStyle = `rgba(176,67,255,${0.15 + j*0.01})`;
          ctx.fill();
        }
        break;
        
      case 'signatureLoop':
        ctx.strokeStyle = 'rgba(0,240,255,0.3)';
        ctx.lineWidth = 2;
        for(let j=0; j<4; j++) {
          ctx.beginPath();
          for(let t=0; t<=1; t+=0.05) {
            const x = (t-0.5)*200;
            const y = Math.sin(t*Math.PI*3 + j)*30 + j*15 - 30;
            if(t===0) ctx.moveTo(x,y);
            else ctx.lineTo(x,y);
          }
          ctx.stroke();
        }
        break;
        
      case 'neonCity':
        ctx.strokeStyle = 'rgba(255,0,255,0.5)';
        ctx.lineWidth = 2;
        for(let j=0; j<8; j++) {
          const h = 40 + Math.random()*60;
          ctx.strokeRect(-100 + j*25, 50-h, 20, h);
        }
        ctx.fillStyle = 'rgba(0,240,255,0.3)';
        ctx.fillRect(-120, 50, 240, 2);
        break;
        
      case 'glitchArt':
        for(let j=0; j<10; j++) {
          ctx.fillStyle = `rgba(${Math.random()*255},${Math.random()*255},255,0.3)`;
          ctx.fillRect(-100 + Math.random()*200, -100 + Math.random()*200, 40, 8);
        }
        break;
        
      case 'vaporwave':
        const grd2 = ctx.createLinearGradient(0,-100,0,100);
        grd2.addColorStop(0, 'rgba(255,0,255,0.3)');
        grd2.addColorStop(1, 'rgba(0,240,255,0.3)');
        ctx.fillStyle = grd2;
        ctx.fillRect(-100,-100,200,200);
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        for(let j=-5; j<=5; j++) {
          ctx.beginPath();
          ctx.moveTo(-100, j*20);
          ctx.lineTo(100, j*20);
          ctx.stroke();
        }
        break;
        
      case 'hologram':
        for(let j=0; j<5; j++) {
          ctx.beginPath();
          ctx.arc(0, 0, 20 + j*15, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(0,240,255,${0.4 - j*0.06})`;
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        break;
        
      case 'pixelStorm':
        for(let j=0; j<50; j++) {
          ctx.fillStyle = `rgba(${Math.random()*255},${Math.random()*255},255,0.5)`;
          ctx.fillRect(-100 + Math.random()*200, -100 + Math.random()*200, 6, 6);
        }
        break;
        
      case 'scanlines':
        ctx.strokeStyle = 'rgba(0,255,140,0.3)';
        ctx.lineWidth = 1;
        for(let j=-100; j<100; j+=4) {
          ctx.beginPath();
          ctx.moveTo(-100, j);
          ctx.lineTo(100, j);
          ctx.stroke();
        }
        ctx.fillStyle = 'rgba(0,240,255,0.2)';
        ctx.fillRect(-60, -60, 120, 120);
        break;
        
      case 'dataStream':
        ctx.font = '10px monospace';
        ctx.fillStyle = 'rgba(0,240,255,0.4)';
        for(let j=0; j<20; j++) {
          ctx.fillText(Math.random().toString(2).substr(2,8), -100 + (j%5)*50, -80 + Math.floor(j/5)*40);
        }
        break;
        
      case 'particleNebula':
        for(let j=0; j<100; j++) {
          const x = (Math.random()-0.5)*200;
          const y = (Math.random()-0.5)*200;
          const size = Math.random()*3;
          ctx.fillStyle = `rgba(176,67,255,${Math.random()*0.5})`;
          ctx.fillRect(x, y, size, size);
        }
        break;
        
      case 'geometricDance':
        for(let j=0; j<6; j++) {
          ctx.save();
          ctx.rotate((j/6)*Math.PI*2);
          ctx.strokeStyle = `rgba(0,240,255,${0.3 + j*0.05})`;
          ctx.lineWidth = 2;
          ctx.strokeRect(30, -10, 40, 20);
          ctx.restore();
        }
        break;
        
      case 'synthwave':
        const grd3 = ctx.createLinearGradient(0,-100,0,100);
        grd3.addColorStop(0, 'rgba(255,0,128,0.4)');
        grd3.addColorStop(0.5, 'rgba(128,0,255,0.3)');
        grd3.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd3;
        ctx.fillRect(-100,-100,200,200);
        ctx.strokeStyle = 'rgba(255,0,255,0.3)';
        for(let j=-5; j<=5; j++) {
          ctx.beginPath();
          ctx.moveTo(j*20, -100);
          ctx.lineTo(j*20, 100);
          ctx.stroke();
        }
        break;
        
      case 'digitalRain':
        ctx.font = '14px monospace';
        for(let j=0; j<12; j++) {
          ctx.fillStyle = `rgba(0,255,140,${0.2 + Math.random()*0.4})`;
          ctx.fillText(String.fromCharCode(0x30A0 + Math.random()*96), -100 + j*20, -80 + (j%4)*50);
        }
        break;
        
      case 'cosmicVoid':
        const grd4 = ctx.createRadialGradient(0,0,0,0,0,120);
        grd4.addColorStop(0, 'rgba(128,0,255,0.4)');
        grd4.addColorStop(0.7, 'rgba(0,0,128,0.2)');
        grd4.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd4;
        ctx.fillRect(-120,-120,240,240);
        for(let j=0; j<30; j++) {
          ctx.fillStyle = 'rgba(255,255,255,0.6)';
          ctx.fillRect((Math.random()-0.5)*200, (Math.random()-0.5)*200, 2, 2);
        }
        break;
        
      case 'fractalTree':
        ctx.strokeStyle = 'rgba(0,240,255,0.4)';
        ctx.lineWidth = 2;
        function drawBranch(x, y, len, angle, depth) {
          if(depth === 0) return;
          const x2 = x + Math.cos(angle) * len;
          const y2 = y + Math.sin(angle) * len;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          drawBranch(x2, y2, len*0.7, angle-0.5, depth-1);
          drawBranch(x2, y2, len*0.7, angle+0.5, depth-1);
        }
        drawBranch(0, 80, 40, -Math.PI/2, 4);
        break;
        
      case 'waveform':
        ctx.strokeStyle = 'rgba(0,240,255,0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let x=-120; x<=120; x+=4) {
          const y = Math.sin(x*0.1)*30 + Math.cos(x*0.05)*20;
          if(x===-120) ctx.moveTo(x,y);
          else ctx.lineTo(x,y);
        }
        ctx.stroke();
        break;
        
      case 'starfield':
        for(let j=0; j<80; j++) {
          const x = (Math.random()-0.5)*200;
          const y = (Math.random()-0.5)*200;
          const size = Math.random()*2 + 0.5;
          ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.8 + 0.2})`;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'cyberpunkGrid':
        ctx.strokeStyle = 'rgba(255,0,255,0.3)';
        ctx.lineWidth = 1;
        for(let j=-5; j<=5; j++) {
          ctx.beginPath();
          ctx.moveTo(-100, j*20);
          ctx.lineTo(100, j*20);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(j*20, -100);
          ctx.lineTo(j*20, 100);
          ctx.stroke();
        }
        ctx.fillStyle = 'rgba(0,240,255,0.2)';
        ctx.fillRect(-40, -40, 80, 80);
        break;
        
      case 'dnaHelix':
        ctx.strokeStyle = 'rgba(0,240,255,0.5)';
        ctx.lineWidth = 2;
        for(let j=0; j<10; j++) {
          const y = -80 + j*16;
          const x1 = Math.sin(j*0.5)*40;
          const x2 = Math.sin(j*0.5 + Math.PI)*40;
          ctx.beginPath();
          ctx.arc(x1, y, 5, 0, Math.PI*2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x2, y, 5, 0, Math.PI*2);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(x1, y);
          ctx.lineTo(x2, y);
          ctx.stroke();
        }
        break;
        
      case 'liquidMetal':
        const grd5 = ctx.createRadialGradient(-20,-20,0,0,0,100);
        grd5.addColorStop(0, 'rgba(200,200,255,0.6)');
        grd5.addColorStop(0.5, 'rgba(100,100,200,0.4)');
        grd5.addColorStop(1, 'rgba(50,50,100,0.2)');
        ctx.fillStyle = grd5;
        ctx.beginPath();
        for(let j=0; j<8; j++) {
          const ang = (j/8)*Math.PI*2;
          const r = 60 + Math.sin(j*2)*20;
          if(j===0) ctx.moveTo(Math.cos(ang)*r, Math.sin(ang)*r);
          else ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r);
        }
        ctx.closePath();
        ctx.fill();
        break;
        
      case 'quantumEntangle':
        for(let j=0; j<6; j++) {
          const x1 = (Math.random()-0.5)*120;
          const y1 = (Math.random()-0.5)*120;
          const x2 = (Math.random()-0.5)*120;
          const y2 = (Math.random()-0.5)*120;
          ctx.strokeStyle = `rgba(176,67,255,${0.3 + Math.random()*0.3})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          ctx.fillStyle = 'rgba(0,240,255,0.6)';
          ctx.beginPath();
          ctx.arc(x1, y1, 4, 0, Math.PI*2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x2, y2, 4, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'neuralNet':
        const nodes = [];
        for(let j=0; j<12; j++) {
          nodes.push({x: (Math.random()-0.5)*180, y: (Math.random()-0.5)*180});
        }
        ctx.strokeStyle = 'rgba(0,240,255,0.2)';
        ctx.lineWidth = 1;
        for(let j=0; j<nodes.length; j++) {
          for(let k=j+1; k<nodes.length; k++) {
            const d = Math.hypot(nodes[j].x-nodes[k].x, nodes[j].y-nodes[k].y);
            if(d < 100) {
              ctx.beginPath();
              ctx.moveTo(nodes[j].x, nodes[j].y);
              ctx.lineTo(nodes[k].x, nodes[k].y);
              ctx.stroke();
            }
          }
        }
        ctx.fillStyle = 'rgba(176,67,255,0.6)';
        nodes.forEach(n => {
          ctx.beginPath();
          ctx.arc(n.x, n.y, 5, 0, Math.PI*2);
          ctx.fill();
        });
        break;
        
      case 'crystalGrowth':
        ctx.strokeStyle = 'rgba(0,240,255,0.4)';
        ctx.lineWidth = 2;
        for(let j=0; j<6; j++) {
          const ang = (j/6)*Math.PI*2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(ang)*80, Math.sin(ang)*80);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(Math.cos(ang)*40, Math.sin(ang)*40);
          ctx.lineTo(Math.cos(ang+0.5)*60, Math.sin(ang+0.5)*60);
          ctx.stroke();
        }
        break;
        
      case 'radarScan':
        ctx.beginPath();
        ctx.arc(0, 0, 80, 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(0,255,140,0.4)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(0, 0, 50, 0, Math.PI*2);
        ctx.stroke();
        const grd6 = ctx.createLinearGradient(0,0,60,60);
        grd6.addColorStop(0, 'rgba(0,255,140,0.6)');
        grd6.addColorStop(1, 'rgba(0,255,140,0)');
        ctx.fillStyle = grd6;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, 80, -Math.PI/4, Math.PI/4);
        ctx.closePath();
        ctx.fill();
        break;
        
      case 'energyShield':
        for(let j=0; j<4; j++) {
          ctx.beginPath();
          ctx.arc(0, 0, 40 + j*15, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(0,240,255,${0.5 - j*0.1})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        ctx.strokeStyle = 'rgba(176,67,255,0.3)';
        for(let j=0; j<6; j++) {
          const ang = (j/6)*Math.PI*2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(ang)*90, Math.sin(ang)*90);
          ctx.stroke();
        }
        break;
        
      case 'spectrumAnalyzer':
        const colors = ['rgba(255,0,0,0.5)', 'rgba(255,127,0,0.5)', 'rgba(255,255,0,0.5)', 
                       'rgba(0,255,0,0.5)', 'rgba(0,0,255,0.5)', 'rgba(75,0,130,0.5)', 'rgba(148,0,211,0.5)'];
        for(let j=0; j<7; j++) {
          ctx.fillStyle = colors[j];
          ctx.fillRect(-70 + j*20, -60, 18, 120);
        }
        break;
        
      case 'particleExplosion':
        for(let j=0; j<30; j++) {
          const ang = (j/30)*Math.PI*2;
          const r = 20 + Math.random()*60;
          const x = Math.cos(ang)*r;
          const y = Math.sin(ang)*r;
          ctx.fillStyle = `rgba(255,${100 + Math.random()*155},0,${0.4 + Math.random()*0.4})`;
          ctx.beginPath();
          ctx.arc(x, y, 2 + Math.random()*4, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'rippleEffect':
        for(let j=0; j<5; j++) {
          ctx.beginPath();
          ctx.arc(0, 0, 20 + j*20, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(0,240,255,${0.6 - j*0.1})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        break;
        
      case 'nebulaSwirl':
        for(let j=0; j<50; j++) {
          const ang = (j/50)*Math.PI*4;
          const r = j*1.5;
          const x = Math.cos(ang)*r;
          const y = Math.sin(ang)*r;
          ctx.fillStyle = `rgba(${100 + j*2},${50 + j},255,${0.3 + Math.random()*0.3})`;
          ctx.beginPath();
          ctx.arc(x, y, 2, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'binaryClock':
        ctx.font = '12px monospace';
        ctx.fillStyle = 'rgba(0,255,140,0.6)';
        for(let j=0; j<6; j++) {
          for(let k=0; k<4; k++) {
            const bit = Math.random() > 0.5 ? '1' : '0';
            ctx.fillText(bit, -60 + j*24, -40 + k*24);
          }
        }
        break;
        
      case 'magneticField':
        ctx.strokeStyle = 'rgba(176,67,255,0.4)';
        ctx.lineWidth = 2;
        for(let j=-3; j<=3; j++) {
          ctx.beginPath();
          for(let t=0; t<=1; t+=0.05) {
            const x = (t-0.5)*200;
            const y = j*20 + Math.sin(t*Math.PI*2)*30;
            if(t===0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
        ctx.fillStyle = 'rgba(255,0,0,0.6)';
        ctx.beginPath();
        ctx.arc(-60, 0, 10, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = 'rgba(0,0,255,0.6)';
        ctx.beginPath();
        ctx.arc(60, 0, 10, 0, Math.PI*2);
        ctx.fill();
        break;
        
      case 'fiberNetwork':
        ctx.strokeStyle = 'rgba(0,240,255,0.3)';
        ctx.lineWidth = 1;
        for(let j=0; j<8; j++) {
          const x1 = (Math.random()-0.5)*160;
          const y1 = (Math.random()-0.5)*160;
          const x2 = (Math.random()-0.5)*160;
          const y2 = (Math.random()-0.5)*160;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.bezierCurveTo(x1, (y1+y2)/2, x2, (y1+y2)/2, x2, y2);
          ctx.stroke();
        }
        break;
        
      case 'quantumWave':
        ctx.strokeStyle = 'rgba(176,67,255,0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let x=-120; x<=120; x+=4) {
          const y = Math.sin(x*0.1)*30 * Math.exp(-Math.abs(x)*0.005);
          if(x===-120) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.fillStyle = 'rgba(176,67,255,0.2)';
        ctx.beginPath();
        for(let x=-120; x<=120; x+=4) {
          const y = Math.sin(x*0.1)*30 * Math.exp(-Math.abs(x)*0.005);
          if(x===-120) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.lineTo(120, 0);
        ctx.lineTo(-120, 0);
        ctx.closePath();
        ctx.fill();
        break;
        
      case 'cyberEye':
        ctx.beginPath();
        ctx.ellipse(0, 0, 80, 50, 0, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,240,255,0.6)';
        ctx.lineWidth = 2;
        ctx.stroke();
        const grd7 = ctx.createRadialGradient(0,0,0,0,0,30);
        grd7.addColorStop(0, 'rgba(0,240,255,0.8)');
        grd7.addColorStop(0.5, 'rgba(176,67,255,0.6)');
        grd7.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd7;
        ctx.beginPath();
        ctx.arc(0, 0, 30, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.arc(-5, -5, 8, 0, Math.PI*2);
        ctx.fill();
        break;
        
      case 'pulseWave':
        for(let j=0; j<4; j++) {
          ctx.strokeStyle = `rgba(0,240,255,${0.6 - j*0.12})`;
          ctx.lineWidth = 3;
          ctx.beginPath();
          for(let x=-120; x<=120; x+=8) {
            let y = 0;
            if(Math.abs(x) < 40) {
              y = Math.sin((x + j*10)*0.2)*40;
            }
            if(x===-120) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
        break;
        
      case 'mandelbrotSet':
        for(let px=-100; px<100; px+=4) {
          for(let py=-100; py<100; py+=4) {
            const x0 = px/50;
            const y0 = py/50;
            let x = 0, y = 0, iteration = 0;
            while(x*x + y*y <= 4 && iteration < 20) {
              const xtemp = x*x - y*y + x0;
              y = 2*x*y + y0;
              x = xtemp;
              iteration++;
            }
            const color = iteration < 20 ? iteration*12 : 0;
            ctx.fillStyle = `rgba(${color},${color*2},255,0.6)`;
            ctx.fillRect(px, py, 4, 4);
          }
        }
        break;
        
      case 'kaleidoscope':
        for(let j=0; j<8; j++) {
          ctx.save();
          ctx.rotate((j/8)*Math.PI*2);
          ctx.fillStyle = `rgba(${Math.random()*255},${Math.random()*255},255,0.4)`;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(60, 20);
          ctx.lineTo(50, 60);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
        break;
        
      case 'laserShow':
        for(let j=0; j<6; j++) {
          const ang = (j/6)*Math.PI*2;
          const grd8 = ctx.createLinearGradient(0,0,Math.cos(ang)*100,Math.sin(ang)*100);
          grd8.addColorStop(0, `rgba(${Math.random()*255},${Math.random()*255},255,0.8)`);
          grd8.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.strokeStyle = grd8;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(ang)*100, Math.sin(ang)*100);
          ctx.stroke();
        }
        break;
        
      case 'blackHole':
        for(let j=0; j<10; j++) {
          const r = 20 + j*10;
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(176,67,255,${0.6 - j*0.05})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        const grd9 = ctx.createRadialGradient(0,0,0,0,0,40);
        grd9.addColorStop(0, 'rgba(0,0,0,1)');
        grd9.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd9;
        ctx.beginPath();
        ctx.arc(0, 0, 40, 0, Math.PI*2);
        ctx.fill();
        break;
        
      case 'circuitBoard':
        ctx.strokeStyle = 'rgba(0,255,140,0.4)';
        ctx.lineWidth = 2;
        for(let j=0; j<5; j++) {
          const x1 = -80 + Math.random()*160;
          const y1 = -80 + Math.random()*160;
          const x2 = -80 + Math.random()*160;
          const y2 = -80 + Math.random()*160;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x1, (y1+y2)/2);
          ctx.lineTo(x2, (y1+y2)/2);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          ctx.fillStyle = 'rgba(0,240,255,0.6)';
          ctx.beginPath();
          ctx.arc(x1, y1, 4, 0, Math.PI*2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x2, y2, 4, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'audioVisualizer':
        for(let j=0; j<20; j++) {
          const h = 20 + Math.random()*60;
          ctx.fillStyle = `rgba(${j*12},${255-j*10},255,0.6)`;
          ctx.fillRect(-100 + j*10, 40-h, 8, h);
        }
        break;
        
      case 'timeTunnel':
        for(let j=0; j<8; j++) {
          const r = 20 + j*15;
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(0,240,255,${0.6 - j*0.06})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        for(let j=0; j<12; j++) {
          const ang = (j/12)*Math.PI*2;
          ctx.beginPath();
          ctx.moveTo(Math.cos(ang)*20, Math.sin(ang)*20);
          ctx.lineTo(Math.cos(ang)*120, Math.sin(ang)*120);
          ctx.strokeStyle = 'rgba(176,67,255,0.3)';
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        break;
        
      case 'plasmaStorm':
        for(let j=0; j<40; j++) {
          const x = (Math.random()-0.5)*180;
          const y = (Math.random()-0.5)*180;
          const grd10 = ctx.createRadialGradient(x,y,0,x,y,15);
          grd10.addColorStop(0, `rgba(${100 + Math.random()*155},${Math.random()*100},255,0.6)`);
          grd10.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = grd10;
          ctx.fillRect(x-15, y-15, 30, 30);
        }
        break;
    }
    
    ctx.restore();
    
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(0, h-40, w, 40);
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.font = '14px Rajdhani, sans-serif';
    ctx.fillText(TEMPLATE_META[id].name, 12, h-16);
  }, 50 + i*20);
});

const overlay = $('#overlay');
const canvasWrap = $('#canvasWrap');
const overlayUI = $('#overlayUI');
const backBtn = $('#backBtn');
const currentLabel = $('#currentLabel');
const autoplayToggle = $('#autoplayToggle');
const autoplayIntervalSelect = $('#autoplayInterval');
const nextBtn = $('#nextBtn');
const autoplayDot = $('#autoplayDot');
const picControlsContainer = $('#picControlsContainer');
const randomBtn = $('#randomBtn');
const helpBtn = $('#helpBtn');

canvasWrap.addEventListener('click', (e)=> {
  if(e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
  uiVisible = !uiVisible;
  if(uiVisible) {
    overlayUI.classList.remove('hidden');
  } else {
    overlayUI.classList.add('hidden');
  }
});

backBtn.addEventListener('click', closeOverlay);
autoplayToggle.addEventListener('click', ()=> {
  autoplay = !autoplay;
  autoplayToggle.classList.toggle('toggled', autoplay);
  autoplayDot.style.display = autoplay ? 'block' : 'none';
  if(autoplay) startAutoplay(); else stopAutoplay();
});
nextBtn.addEventListener('click', ()=> nextTemplate());
randomBtn.addEventListener('click', ()=> {
  const idx = Math.floor(Math.random()*TEMPLATE_IDS.length);
  openTemplate(idx);
});
helpBtn.addEventListener('click', ()=> {
  alert(`LumaGEN — Nice templates for dGEN1. Click cards to view. Click canvas to hide/show controls. Autoplay switches every 20s.`);
});

function startAutoplay(){
  stopAutoplay();
	const interval = parseInt(autoplayIntervalSelect.value, 10);
	nextTemplate();
  autoplayTimer = setInterval(()=> {
    nextTemplate();
  }, interval);
}
function stopAutoplay(){
  if(autoplayTimer){ clearInterval(autoplayTimer); autoplayTimer = null; }
}

function openTemplate(index){
  index = (index + TEMPLATE_IDS.length) % TEMPLATE_IDS.length;
  currentIndex = index;
  const id = TEMPLATE_IDS[index];
  currentLabel.textContent = TEMPLATE_META[id].name;
  overlay.classList.add('active');
  overlay.setAttribute('aria-hidden','false');
  uiVisible = true;
  overlayUI.classList.remove('hidden');

  canvasWrap.innerHTML = '';
  const canvas = create('canvas', {width:window.innerWidth, height:window.innerHeight});
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  canvasWrap.appendChild(canvas);

  const tmpl = templates[id];
  if(!tmpl) return;
  activeInstance = tmpl.mount(canvas, {onExit: closeOverlay});
  picControlsContainer.innerHTML = '';
}

function closeOverlay(){
  if(autoplay) stopAutoplay();
	
  overlay.classList.remove('active');
  overlay.setAttribute('aria-hidden','true');
  if(activeInstance && typeof activeInstance.unmount === 'function') {
    activeInstance.unmount();
    activeInstance = null;
  }
  canvasWrap.innerHTML = '';
}

function nextTemplate(){
  const idx = (currentIndex + 1) % TEMPLATE_IDS.length;
  if(overlay.classList.contains('active')){
    if(activeInstance && typeof activeInstance.unmount === 'function') activeInstance.unmount();
    currentIndex = idx;
    const id = TEMPLATE_IDS[idx];
    currentLabel.textContent = TEMPLATE_META[id].name;
    canvasWrap.innerHTML = '';
    const canvas = create('canvas', {width:window.innerWidth, height:window.innerHeight});
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvasWrap.appendChild(canvas);
    const tmpl = templates[id];
    activeInstance = tmpl.mount(canvas, {onExit: closeOverlay});
    picControlsContainer.innerHTML = '';
  } else {
    openTemplate(idx);
  }
}

function makeRunner(renderFn){
  let running = true;
  let rafId = null;
  function loop(t){
    if(!running) return;
    renderFn(t);
    rafId = requestAnimationFrame(loop);
  }
  rafId = requestAnimationFrame(loop);
  return {
    stop(){ running = false; if(rafId) cancelAnimationFrame(rafId); }
  };
}

function cyberMinimalMount(canvas){
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (t - t0)/1000;
    ctx.clearRect(0,0,w,h);
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, 'rgba(0,0,0,0.9)');
    g.addColorStop(1, 'rgba(10,10,12,0.95)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
    ctx.save();
    ctx.translate(w/2, h/2);
    ctx.rotate(tt*0.18);
    ctx.strokeStyle = 'rgba(0,240,255,0.14)';
    ctx.lineWidth = 6;
    for(let i=0;i<4;i++){
      const s = 220 + Math.sin(tt*0.9 + i)*10;
      ctx.strokeRect(-s/2, -s/2, s, s);
    }
    ctx.restore();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(176,67,255,0.06)';
    ctx.beginPath();
    for(let i=0;i<6;i++){
      const y = h*(i+1)/7 + Math.sin(tt*0.6 + i)*6;
      ctx.moveTo(40, y); ctx.lineTo(w-40, y);
    }
    ctx.stroke();
  });
  return { unmount(){ runner.stop(); } };
}

function cryptoOrbMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const N = 220;
  const pts = new Array(N).fill(0).map((_,i)=>({
    a: Math.random()*Math.PI*2,
    r: 60 + Math.random()*220,
    s: 0.4 + Math.random()*1.4,
    phase: Math.random()*10
  }));
  const runner = makeRunner((t)=>{
    const tsec = (performance.now() - t0)/1000;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = 'rgba(0,0,0,0.96)';
    ctx.fillRect(0,0,W,H);
    const cx = W/2, cy = H/2;
    const grd = ctx.createRadialGradient(cx,cy,10,cx,cy,260);
    grd.addColorStop(0, 'rgba(0,200,255,0.08)');
    grd.addColorStop(0.45, 'rgba(176,67,255,0.03)');
    grd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grd; ctx.fillRect(0,0,W,H);
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0;i<N;i++){
      const p = pts[i];
      const a = p.a + tsec*0.2*(0.6 + p.s*0.3);
      const r = p.r + Math.sin(tsec*0.9 + p.phase)*6;
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r;
      const size = 0.8 + p.s*1.8;
      ctx.beginPath();
      ctx.fillStyle = `rgba(0,240,255,${0.02 + p.s*0.06})`;
      ctx.arc(x,y,size,0,Math.PI*2);
      ctx.fill();
    }
    ctx.globalCompositeOperation = 'source-over';
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,240,255,0.06)';
    ctx.arc(cx, cy, 62 + Math.sin(tsec*0.8)*6, 0, Math.PI*2);
    ctx.fill();
  });
  return { unmount(){ runner.stop(); } };
}

function retroTerminalMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const lines = Array.from({length:30}, ()=> '');
  const ch = 18;
  function randomLine(){
    const hex = '0123456789abcdef';
    let s = '';
    if(Math.random() < 0.2){
      s = 'block ' + Math.floor(Math.random()*999999) + ' detected';
    } else {
      for(let i=0;i<40;i++) s += hex[Math.floor(Math.random()*16)];
    }
    return s;
  }
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.98)';
    ctx.fillRect(0,0,W,H);
    if(Math.random() < 0.28){
      lines.pop();
      lines.unshift(randomLine());
    }
    ctx.font = '16px "Courier New", monospace';
    for(let i=0;i<lines.length;i++){
      const y = 60 + i*ch;
      ctx.fillStyle = (i===0)? 'rgba(0,255,140,0.85)' : 'rgba(0,255,140,0.22)';
      ctx.fillText(lines[i], 22, y);
    }
  });
  return { unmount(){ runner.stop(); } };
}

function zenSpaceMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let s = 0;
  const runner = makeRunner((t)=>{
    const tt = t/1000;
    s = Math.sin(tt*0.12)*0.5 + 0.5;
    const g = ctx.createLinearGradient(0,0,W,H);
    g.addColorStop(0, `rgba(34,36,40,${0.16 + s*0.04})`);
    g.addColorStop(1, `rgba(8,10,12,0.98)`);
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
    ctx.beginPath();
    ctx.fillStyle = `rgba(176,67,255,${0.04 + s*0.06})`;
    ctx.arc(W/2, H/2 - 20, 220 + s*20, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.02)';
    ctx.lineWidth = 1.2;
    for(let i=0;i<5;i++){
      ctx.beginPath();
      const off = Math.sin(tt*0.3 + i)*18;
      ctx.ellipse(W/2, H/2 + off, 200 - i*30, 60, Math.PI/6, 0, Math.PI*2);
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function liquidWavesMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now() - t0)/1000;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#040405'; ctx.fillRect(0,0,W,H);
    for(let k=0;k<4;k++){
      ctx.beginPath();
      const amp = 12 + k*8;
      ctx.moveTo(0, H/2);
      for(let x=0;x<=W;x+=6){
        const y = H/2 + Math.sin((x*0.02) + tt*(0.6 + k*0.12) + k)*amp*Math.cos(k*0.2);
        ctx.lineTo(x,y + k*8);
      }
      ctx.strokeStyle = `rgba(0,240,255,${0.8 - k*0.05})`;
      ctx.lineWidth = 1.8;
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function matrixRainMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const cols = Math.floor(W/14);
  const drops = new Array(cols).fill(0).map(()=>Math.floor(Math.random()*H));
  const letters = '01';
  let running = true;
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(0,0,W,H);
    ctx.font = '14px monospace';
    for(let i=0;i<cols;i++){
      const x = i*14;
      ctx.fillStyle = 'rgba(0,255,140,0.5)';
      const text = letters[Math.floor(Math.random()*letters.length)];
      ctx.fillText(text, x, drops[i]);
      drops[i] += 14 + Math.random()*10;
      if(drops[i] > H + 20) drops[i] = -20*Math.random();
    }
  });
  return { unmount(){ running=false; runner.stop(); } };
}

function hexGridPulseMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const size = 36;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#070708'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    const cols = Math.ceil(W/size)+4;
    for(let x=-cols;x<cols;x++){
      for(let y=-cols;y<cols;y++){
        const px = x*size*0.86 + (y%2? size*0.43:0);
        const py = y*(size*0.75);
        const d = Math.hypot(px,py);
        const pulse = 0.6 + 0.4*Math.sin(d*0.06 - tt*2);
        const a = 0.03 + 0.06*(1-pulse);
        ctx.beginPath();
        ctx.moveTo(px + size*0.5, py);
        for(let k=1;k<6;k++){
          const ang = (Math.PI*2/6)*k;
          ctx.lineTo(px + Math.cos(ang)*size*0.5, py + Math.sin(ang)*size*0.5);
        }
        ctx.closePath();
        ctx.fillStyle = `rgba(0,240,255,${a})`;
        ctx.fill();
      }
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function clockSyncMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let running = true;
  const runner = makeRunner((t)=>{
    ctx.fillStyle = '#010101'; ctx.fillRect(0,0,W,H);
    const now = new Date();
    const s = now.getSeconds(), m = now.getMinutes(), hr = now.getHours()%12;
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.beginPath(); ctx.arc(0,0,220,0,Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.02)'; ctx.fill();
    for(let i=0;i<60;i++){
      const ang = i*(Math.PI*2/60) - Math.PI/2;
      const r1 = 200, r2 = (i%5===0 ? 190 : 194);
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.lineWidth = (i%5===0)?2:1;
      ctx.beginPath();
      ctx.moveTo(Math.cos(ang)*r1, Math.sin(ang)*r1);
      ctx.lineTo(Math.cos(ang)*r2, Math.sin(ang)*r2);
      ctx.stroke();
    }
    const angS = s*(Math.PI*2/60) - Math.PI/2;
    const angM = (m + s/60)*(Math.PI*2/60) - Math.PI/2;
    const angH = (hr + m/60)*(Math.PI*2/12) - Math.PI/2;
    ctx.strokeStyle = 'rgba(176,67,255,0.9)'; ctx.lineWidth=6;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(angH)*110, Math.sin(angH)*110); ctx.stroke();
    ctx.strokeStyle = 'rgba(0,240,255,0.96)'; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(angM)*150, Math.sin(angM)*150); ctx.stroke();
    ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth=1.6;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(angS)*180, Math.sin(angS)*180); ctx.stroke();
    ctx.restore();
  });
  return { unmount(){ running=false; runner.stop(); } };
}

function codeVerseMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const snippets = [
    'function syncBlock(){ /* destiny */ }',
    'const tx = broadcast(wallet.sign(tx))',
    'for await (const block of chain) { /* listen */ }',
    'if (nonce++ > 100) { revive(); }',
    'let entropy = crypto.getRandomValues(new Uint8Array(32))'
  ];
  let lines = new Array(24).fill('');
  const runner = makeRunner((t)=>{
    ctx.fillStyle = '#040405'; ctx.fillRect(0,0,W,H);
    if(Math.random() < 0.35){
      lines.pop();
      lines.unshift(snippets[Math.floor(Math.random()*snippets.length)]);
    }
    ctx.font = '14px "Courier New", monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    for(let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], 22, 60 + i*20);
    }
  });
  return { unmount(){ runner.stop(); } };
}

function aiBloomMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#050507'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let k=0;k<18;k++){
      const ang = (k/18)*Math.PI*2 + tt*0.06;
      const r = 80 + Math.sin(tt*0.9 + k)*80;
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(Math.cos(ang)*r/2, Math.sin(ang)*r/2, r*0.6, ang-0.8, ang+0.8);
      ctx.fillStyle = `rgba(176,67,255,${0.03 + k*0.002})`;
      ctx.fill();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function signatureLoopMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const lines = [];
  for(let i=0;i<6;i++){
    const pts = [];
    for(let j=0;j<30;j++){
      pts.push({x: Math.random()*W, y: Math.random()*H});
    }
    lines.push(pts);
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#020202'; ctx.fillRect(0,0,W,H);
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0;i<lines.length;i++){
      const pts = lines[i];
      ctx.beginPath();
      for(let j=0;j<pts.length;j++){
        const p = pts[j];
        const nx = p.x + Math.sin(tt*0.6 + i + j)*12;
        const ny = p.y + Math.cos(tt*0.4 + i - j)*12;
        if(j===0) ctx.moveTo(nx, ny); else ctx.lineTo(nx, ny);
      }
      ctx.strokeStyle = `rgba(0,240,255,${0.03 + i*0.03})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.globalCompositeOperation = 'source-over';
  });
  return { unmount(){ runner.stop(); } };
}

function neonCityMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const buildings = Array.from({length:20}, ()=>({
    x: Math.random()*W,
    h: 100 + Math.random()*300,
    w: 40 + Math.random()*60,
    color: Math.random() > 0.5 ? 'rgba(255,0,255,0.6)' : 'rgba(0,240,255,0.6)'
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    for(let i=0;i<buildings.length;i++){
      const b = buildings[i];
      const flicker = 0.8 + Math.sin(tt*3 + i)*0.2;
      ctx.fillStyle = b.color.replace('0.6', (0.3*flicker).toString());
      ctx.fillRect(b.x, H-b.h, b.w, b.h);
      ctx.strokeStyle = b.color;
      ctx.lineWidth = 2;
      ctx.strokeRect(b.x, H-b.h, b.w, b.h);
      for(let j=0;j<5;j++){
        if(Math.random() > 0.3){
          ctx.fillStyle = 'rgba(255,255,200,0.4)';
          ctx.fillRect(b.x + 10, H-b.h + 20 + j*40, 10, 10);
        }
      }
    }
    ctx.fillStyle = 'rgba(255,0,255,0.3)';
    ctx.fillRect(0, H-10, W, 10);
  });
  return { unmount(){ runner.stop(); } };
}

function glitchArtMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    if(Math.random() > 0.7){
      const slices = 10 + Math.floor(Math.random()*20);
      for(let i=0;i<slices;i++){
        const y = Math.random()*H;
        const h = 5 + Math.random()*30;
        const offset = (Math.random()-0.5)*50;
        ctx.fillStyle = `rgba(${Math.random()*255},${Math.random()*255},255,0.3)`;
        ctx.fillRect(offset, y, W, h);
      }
    }
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = 'rgba(255,0,0,0.1)';
    ctx.fillRect(W/2 - 100 + Math.sin(tt*2)*10, H/2 - 100, 200, 200);
    ctx.fillStyle = 'rgba(0,255,0,0.1)';
    ctx.fillRect(W/2 - 100, H/2 - 100 + Math.cos(tt*2)*10, 200, 200);
    ctx.fillStyle = 'rgba(0,0,255,0.1)';
    ctx.fillRect(W/2 - 100 - Math.sin(tt*2)*10, H/2 - 100, 200, 200);
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function vaporwaveMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    const grd = ctx.createLinearGradient(0,0,0,H);
    grd.addColorStop(0, '#ff00ff');
    grd.addColorStop(0.5, '#00ffff');
    grd.addColorStop(1, '#000');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H*0.7);
    ctx.rotate(-0.3);
    ctx.strokeStyle = 'rgba(255,0,255,0.3)';
    ctx.lineWidth = 2;
    for(let i=-10;i<=10;i++){
      const y = i*40;
      const scale = 1 + y*0.002;
      ctx.beginPath();
      ctx.moveTo(-W*scale, y);
      ctx.lineTo(W*scale, y);
      ctx.stroke();
    }
    for(let i=-10;i<=10;i++){
      ctx.beginPath();
      ctx.moveTo(i*60, -200);
      ctx.lineTo(i*60*1.5, 400);
      ctx.stroke();
    }
    ctx.restore();
    const sunY = H*0.3 + Math.sin(tt*0.5)*20;
    const grd2 = ctx.createRadialGradient(W/2,sunY,0,W/2,sunY,150);
    grd2.addColorStop(0, 'rgba(255,200,0,0.8)');
    grd2.addColorStop(0.5, 'rgba(255,0,255,0.4)');
    grd2.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grd2;
    ctx.fillRect(0,0,W,H);
  });
  return { unmount(){ runner.stop(); } };
}

function hologramMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<8; i++){
      const r = 50 + i*40 + Math.sin(tt + i)*10;
      const alpha = 0.4 - i*0.04;
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(0,240,255,${alpha})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    for(let i=0; i<12; i++){
      const ang = (i/12)*Math.PI*2 + tt*0.5;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(Math.cos(ang)*300, Math.sin(ang)*300);
      ctx.strokeStyle = `rgba(0,240,255,${0.1 + Math.sin(tt + i)*0.05})`;
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function pixelStormMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const pixels = Array.from({length:200}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    vx: (Math.random()-0.5)*4,
    vy: (Math.random()-0.5)*4,
    size: 4 + Math.random()*8,
    color: `rgb(${Math.random()*255},${Math.random()*255},255)`
  }));
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    for(let i=0;i<pixels.length;i++){
      const p = pixels[i];
      p.x += p.vx;
      p.y += p.vy;
      if(p.x < 0 || p.x > W) p.vx *= -1;
      if(p.y < 0 || p.y > H) p.vy *= -1;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    }
  });
  return { unmount(){ runner.stop(); } };
}

function scanlinesMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = 'rgba(0,255,140,0.2)';
    ctx.lineWidth = 1;
    for(let y=0;y<H;y+=3){
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }
    const scanY = (tt*100) % H;
    ctx.fillStyle = 'rgba(0,255,140,0.3)';
    ctx.fillRect(0, scanY, W, 20);
    ctx.fillStyle = 'rgba(0,240,255,0.2)';
    ctx.fillRect(W/2-150, H/2-150, 300, 300);
    ctx.strokeStyle = 'rgba(0,240,255,0.6)';
    ctx.lineWidth = 2;
    ctx.strokeRect(W/2-150, H/2-150, 300, 300);
  });
  return { unmount(){ runner.stop(); } };
}

function dataStreamMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const streams = Array.from({length:30}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    speed: 1 + Math.random()*3,
    data: Array.from({length:10}, ()=>Math.random().toString(2).substr(2,8))
  }));
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    ctx.font = '12px monospace';
    for(let i=0;i<streams.length;i++){
      const s = streams[i];
      s.y += s.speed;
      if(s.y > H) s.y = -100;
      for(let j=0;j<s.data.length;j++){
        const alpha = 0.8 - j*0.08;
        ctx.fillStyle = `rgba(0,240,255,${alpha})`;
        ctx.fillText(s.data[j], s.x, s.y + j*15);
      }
    }
  });
  return { unmount(){ runner.stop(); } };
}

function particleNebulaMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const particles = Array.from({length:500}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    vx: (Math.random()-0.5)*0.5,
    vy: (Math.random()-0.5)*0.5,
    size: Math.random()*3,
    alpha: Math.random()
  }));
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0;i<particles.length;i++){
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      if(p.x < 0) p.x = W;
      if(p.x > W) p.x = 0;
      if(p.y < 0) p.y = H;
      if(p.y > H) p.y = 0;
      ctx.fillStyle = `rgba(176,67,255,${p.alpha*0.5})`;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    }
    ctx.globalCompositeOperation = 'source-over';
  });
  return { unmount(){ runner.stop(); } };
}

function geometricDanceMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<8; i++){
      ctx.save();
      ctx.rotate((i/8)*Math.PI*2);
      ctx.translate(150 + Math.sin(tt + i)*50, 0);
      ctx.rotate(tt*2);
      const size = 40 + Math.sin(tt*3 + i)*20;
      ctx.strokeStyle = `rgba(0,240,255,${0.4 + Math.sin(tt + i)*0.2})`;
      ctx.lineWidth = 3;
      if(i % 2 === 0){
        ctx.strokeRect(-size/2, -size/2, size, size);
      } else {
        ctx.beginPath();
        ctx.arc(0, 0, size/2, 0, Math.PI*2);
        ctx.stroke();
      }
      ctx.restore();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function synthwaveMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    const grd = ctx.createLinearGradient(0,0,0,H);
    grd.addColorStop(0, '#1a0033');
    grd.addColorStop(0.5, '#330066');
    grd.addColorStop(1, '#000');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H*0.8);
    ctx.scale(1, 0.5);
    ctx.strokeStyle = 'rgba(255,0,255,0.4)';
    ctx.lineWidth = 2;
    for(let i=-15;i<=15;i++){
      const y = i*30 - (tt*50 % 30);
      ctx.beginPath();
      ctx.moveTo(-W, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }
    for(let i=-10;i<=10;i++){
      ctx.beginPath();
      ctx.moveTo(i*60, -300);
      ctx.lineTo(i*60, 300);
      ctx.stroke();
    }
    ctx.restore();
    ctx.fillStyle = 'rgba(255,0,128,0.3)';
    ctx.beginPath();
    ctx.moveTo(0, H*0.6);
    for(let x=0;x<=W;x+=20){
      const y = H*0.6 - Math.sin(x*0.01 + tt)*50 - Math.cos(x*0.02)*30;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(W, H);
    ctx.lineTo(0, H);
    ctx.fill();
  });
  return { unmount(){ runner.stop(); } };
}

function digitalRainMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const cols = Math.floor(W/20);
  const drops = Array.from({length:cols}, ()=>({
    y: Math.random()*H,
    speed: 3 + Math.random()*7,
    chars: Array.from({length:15}, ()=>String.fromCharCode(0x30A0 + Math.random()*96))
  }));
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    ctx.font = '16px monospace';
    for(let i=0;i<cols;i++){
      const d = drops[i];
      d.y += d.speed;
      if(d.y > H + 200) d.y = -200;
      for(let j=0;j<d.chars.length;j++){
        const alpha = 0.8 - j*0.05;
        ctx.fillStyle = `rgba(0,255,140,${alpha})`;
        ctx.fillText(d.chars[j], i*20, d.y + j*20);
      }
    }
  });
  return { unmount(){ runner.stop(); } };
}

function cosmicVoidMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const stars = Array.from({length:200}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    z: Math.random()*1000,
    size: Math.random()*2
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    for(let i=0;i<stars.length;i++){
      const s = stars[i];
      s.z -= 5;
      if(s.z <= 0) s.z = 1000;
      const x = (s.x - W/2) * (1000/s.z) + W/2;
      const y = (s.y - H/2) * (1000/s.z) + H/2;
      const size = s.size * (1000/s.z);
      const alpha = 1 - s.z/1000;
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.fillRect(x, y, size, size);
    }
    const grd = ctx.createRadialGradient(W/2,H/2,0,W/2,H/2,200);
    grd.addColorStop(0, 'rgba(128,0,255,0.3)');
    grd.addColorStop(0.5, 'rgba(0,0,128,0.1)');
    grd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,W,H);
  });
  return { unmount(){ runner.stop(); } };
}

function fractalTreeMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  function drawBranch(x, y, len, angle, depth, t) {
    if(depth === 0) return;
    const x2 = x + Math.cos(angle) * len;
    const y2 = y + Math.sin(angle) * len;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x2, y2);
    const alpha = 0.6 - depth*0.08;
    ctx.strokeStyle = `rgba(0,240,255,${alpha})`;
    ctx.lineWidth = depth;
    ctx.stroke();
    const angleOffset = Math.sin(t + depth)*0.2;
    drawBranch(x2, y2, len*0.7, angle-0.5+angleOffset, depth-1, t);
    drawBranch(x2, y2, len*0.7, angle+0.5+angleOffset, depth-1, t);
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    drawBranch(W/2, H-50, 100, -Math.PI/2, 8, tt);
  });
  return { unmount(){ runner.stop(); } };
}

function waveformMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    for(let layer=0;layer<5;layer++){
      ctx.beginPath();
      ctx.moveTo(0, H/2);
      for(let x=0;x<=W;x+=5){
        const y = H/2 + 
          Math.sin((x*0.01) + tt*(1 + layer*0.2))*30 +
          Math.cos((x*0.02) + tt*(0.5 + layer*0.1))*20 +
          layer*15;
        if(x===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.strokeStyle = `rgba(0,240,255,${0.5 - layer*0.08})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.fillStyle = 'rgba(176,67,255,0.3)';
    for(let i=0;i<50;i++){
      const h = 50 + Math.sin(tt*3 + i*0.5)*40 + Math.random()*20;
      ctx.fillRect(i*(W/50), H-h, W/50-2, h);
    }
  });
  return { unmount(){ runner.stop(); } };
}

function starfieldMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const stars = Array.from({length:300}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    size: Math.random()*2 + 0.5,
    speed: Math.random()*0.5 + 0.1,
    brightness: Math.random()
  }));
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,5,0.2)'; ctx.fillRect(0,0,W,H);
    for(let i=0;i<stars.length;i++){
      const s = stars[i];
      s.y += s.speed;
      if(s.y > H) {
        s.y = 0;
        s.x = Math.random()*W;
      }
      s.brightness = 0.3 + Math.sin(t*0.001 + i)*0.7;
      ctx.fillStyle = `rgba(255,255,255,${s.brightness})`;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
      ctx.fill();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function cyberpunkGridMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = 'rgba(255,0,255,0.2)';
    ctx.lineWidth = 1;
    const gridSize = 40;
    for(let x=0;x<W;x+=gridSize){
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, H);
      ctx.stroke();
    }
    for(let y=0;y<H;y+=gridSize){
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }
    for(let i=0;i<10;i++){
      const x = ((tt*50 + i*100) % W);
      const y = ((tt*30 + i*80) % H);
      const grd = ctx.createRadialGradient(x,y,0,x,y,60);
      grd.addColorStop(0, 'rgba(0,240,255,0.4)');
      grd.addColorStop(1, 'rgba(0,240,255,0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x-60, y-60, 120, 120);
    }
    ctx.fillStyle = 'rgba(255,0,255,0.2)';
    ctx.fillRect(W/2-100, H/2-100, 200, 200);
    ctx.strokeStyle = 'rgba(0,240,255,0.8)';
    ctx.lineWidth = 3;
    ctx.strokeRect(W/2-100, H/2-100, 200, 200);
  });
  return { unmount(){ runner.stop(); } };
}

function dnaHelixMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    const segments = 40;
    for(let i=0; i<segments; i++){
      const y = -H/3 + (i/segments)*H*0.66;
      const phase = tt*2 + i*0.3;
      const x1 = Math.sin(phase)*W*0.15;
      const x2 = Math.sin(phase + Math.PI)*W*0.15;
      ctx.fillStyle = 'rgba(0,240,255,0.8)';
      ctx.beginPath();
      ctx.arc(x1, y, 8, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = 'rgba(176,67,255,0.8)';
      ctx.beginPath();
      ctx.arc(x2, y, 8, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x1, y);
      ctx.lineTo(x2, y);
      ctx.stroke();
    }
    ctx.strokeStyle = 'rgba(0,240,255,0.4)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    for(let i=0; i<segments; i++){
      const y = -H/3 + (i/segments)*H*0.66;
      const x = Math.sin(tt*2 + i*0.3)*W*0.15;
      if(i===0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.strokeStyle = 'rgba(176,67,255,0.4)';
    ctx.beginPath();
    for(let i=0; i<segments; i++){
      const y = -H/3 + (i/segments)*H*0.66;
      const x = Math.sin(tt*2 + i*0.3 + Math.PI)*W*0.15;
      if(i===0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function liquidMetalMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const blobs = Array.from({length:5}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    vx: (Math.random()-0.5)*2,
    vy: (Math.random()-0.5)*2,
    r: 50 + Math.random()*100
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0; i<blobs.length; i++){
      const b = blobs[i];
      b.x += b.vx;
      b.y += b.vy;
      if(b.x < 0 || b.x > W) b.vx *= -1;
      if(b.y < 0 || b.y > H) b.vy *= -1;
      const grd = ctx.createRadialGradient(b.x,b.y,0,b.x,b.y,b.r);
      grd.addColorStop(0, 'rgba(200,220,255,0.6)');
      grd.addColorStop(0.5, 'rgba(100,150,255,0.3)');
      grd.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grd;
      ctx.fillRect(b.x-b.r, b.y-b.r, b.r*2, b.r*2);
    }
    ctx.globalCompositeOperation = 'source-over';
  });
  return { unmount(){ runner.stop(); } };
}

function quantumEntangleMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const particles = Array.from({length:20}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    vx: (Math.random()-0.5)*3,
    vy: (Math.random()-0.5)*3,
    partner: -1
  }));
  for(let i=0; i<particles.length; i+=2){
    if(i+1 < particles.length){
      particles[i].partner = i+1;
      particles[i+1].partner = i;
    }
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<particles.length; i++){
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      if(p.x < 0 || p.x > W) p.vx *= -1;
      if(p.y < 0 || p.y > H) p.vy *= -1;
      if(p.partner >= 0){
        const p2 = particles[p.partner];
        ctx.strokeStyle = 'rgba(176,67,255,0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }
      const grd = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,15);
      grd.addColorStop(0, 'rgba(0,240,255,0.8)');
      grd.addColorStop(1, 'rgba(0,240,255,0)');
      ctx.fillStyle = grd;
      ctx.fillRect(p.x-15, p.y-15, 30, 30);
    }
  });
  return { unmount(){ runner.stop(); } };
}

function neuralNetMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const nodes = Array.from({length:50}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    vx: (Math.random()-0.5)*0.5,
    vy: (Math.random()-0.5)*0.5
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<nodes.length; i++){
      const n = nodes[i];
      n.x += n.vx;
      n.y += n.vy;
      if(n.x < 0 || n.x > W) n.vx *= -1;
      if(n.y < 0 || n.y > H) n.vy *= -1;
    }
    ctx.strokeStyle = 'rgba(0,240,255,0.2)';
    ctx.lineWidth = 1;
    for(let i=0; i<nodes.length; i++){
      for(let j=i+1; j<nodes.length; j++){
        const dx = nodes[i].x - nodes[j].x;
        const dy = nodes[i].y - nodes[j].y;
        const d = Math.sqrt(dx*dx + dy*dy);
        if(d < 150){
          ctx.beginPath();
          ctx.moveTo(nodes[i].x, nodes[i].y);
          ctx.lineTo(nodes[j].x, nodes[j].y);
          ctx.stroke();
        }
      }
    }
    ctx.fillStyle = 'rgba(176,67,255,0.8)';
    for(let i=0; i<nodes.length; i++){
      ctx.beginPath();
      ctx.arc(nodes[i].x, nodes[i].y, 4, 0, Math.PI*2);
      ctx.fill();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function crystalGrowthMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let layer=0; layer<6; layer++){
      const scale = 1 + layer*0.3 + Math.sin(tt + layer)*0.1;
      ctx.save();
      ctx.scale(scale, scale);
      ctx.rotate(tt*0.2 + layer*0.5);
      ctx.strokeStyle = `rgba(0,240,255,${0.6 - layer*0.08})`;
      ctx.lineWidth = 2;
      for(let i=0; i<6; i++){
        const ang = (i/6)*Math.PI*2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(ang)*100, Math.sin(ang)*100);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(Math.cos(ang)*50, Math.sin(ang)*50);
        ctx.lineTo(Math.cos(ang+Math.PI/6)*70, Math.sin(ang+Math.PI/6)*70);
        ctx.stroke();
      }
      ctx.restore();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function radarScanMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const targets = Array.from({length:15}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    size: 3 + Math.random()*5
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=1; i<=5; i++){
      ctx.beginPath();
      ctx.arc(0, 0, i*H/6, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,255,140,0.3)';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.strokeStyle = 'rgba(0,255,140,0.2)';
    for(let i=0; i<12; i++){
      const ang = (i/12)*Math.PI*2;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(Math.cos(ang)*H/2, Math.sin(ang)*H/2);
      ctx.stroke();
    }
    const scanAngle = tt*2;
    const grd = ctx.createLinearGradient(0,0,Math.cos(scanAngle)*H/2,Math.sin(scanAngle)*H/2);
    grd.addColorStop(0, 'rgba(0,255,140,0.6)');
    grd.addColorStop(0.3, 'rgba(0,255,140,0.3)');
    grd.addColorStop(1, 'rgba(0,255,140,0)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.arc(0, 0, H/2, scanAngle-0.5, scanAngle);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.fillStyle = 'rgba(0,255,140,0.8)';
    for(let i=0; i<targets.length; i++){
      const t = targets[i];
      ctx.beginPath();
      ctx.arc(t.x, t.y, t.size, 0, Math.PI*2);
      ctx.fill();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function energyShieldMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const hexagons = [];
  const hexSize = 30;
  for(let x=-W/2; x<W/2; x+=hexSize*1.5){
    for(let y=-H/2; y<H/2; y+=hexSize*Math.sqrt(3)){
      hexagons.push({
        x: x + (Math.floor(y/(hexSize*Math.sqrt(3)))%2 ? hexSize*0.75 : 0),
        y: y,
        phase: Math.random()*Math.PI*2
      });
    }
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<hexagons.length; i++){
      const h = hexagons[i];
      const d = Math.sqrt(h.x*h.x + h.y*h.y);
      const pulse = Math.sin(tt*2 - d*0.01 + h.phase)*0.5 + 0.5;
      ctx.beginPath();
      for(let j=0; j<6; j++){
        const ang = (j/6)*Math.PI*2;
        const x = h.x + Math.cos(ang)*hexSize*0.5;
        const y = h.y + Math.sin(ang)*hexSize*0.5;
        if(j===0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.strokeStyle = `rgba(0,240,255,${0.2 + pulse*0.4})`;
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function spectrumAnalyzerMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const bars = 64;
  const barHeights = new Array(bars).fill(0);
  const barVels = new Array(bars).fill(0);
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<bars; i++){
      const target = Math.abs(Math.sin(tt*3 + i*0.2))*0.8 + Math.random()*0.2;
      barVels[i] += (target - barHeights[i])*0.1;
      barVels[i] *= 0.9;
      barHeights[i] += barVels[i];
      barHeights[i] = Math.max(0, Math.min(1, barHeights[i]));
    }
    const barWidth = W/bars;
    for(let i=0; i<bars; i++){
      const h = barHeights[i]*H*0.8;
      const hue = (i/bars)*360;
      ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.8)`;
      ctx.fillRect(i*barWidth, H-h, barWidth-2, h);
      const grd = ctx.createLinearGradient(i*barWidth, H-h, i*barWidth, H);
      grd.addColorStop(0, `hsla(${hue}, 80%, 80%, 0.6)`);
      grd.addColorStop(1, `hsla(${hue}, 80%, 40%, 0.6)`);
      ctx.fillStyle = grd;
      ctx.fillRect(i*barWidth, H-h, barWidth-2, h);
    }
  });
  return { unmount(){ runner.stop(); } };
}

function particleExplosionMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const particles = Array.from({length:200}, ()=>({
    ang: Math.random()*Math.PI*2,
    speed: 2 + Math.random()*8,
    life: 1,
    size: 2 + Math.random()*6,
    color: `rgba(${200 + Math.random()*55},${100 + Math.random()*155},0,`
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<particles.length; i++){
      const p = particles[i];
      const r = p.speed*tt*60;
      const x = W/2 + Math.cos(p.ang)*r;
      const y = H/2 + Math.sin(p.ang)*r;
      p.life = Math.max(0, 1 - tt*0.3);
      ctx.fillStyle = p.color + p.life + ')';
      ctx.beginPath();
      ctx.arc(x, y, p.size*p.life, 0, Math.PI*2);
      ctx.fill();
    }
    if(tt > 3){
      t0 = performance.now();
      for(let i=0; i<particles.length; i++){
        particles[i].ang = Math.random()*Math.PI*2;
        particles[i].speed = 2 + Math.random()*8;
        particles[i].life = 1;
      }
    }
  });
  return { unmount(){ runner.stop(); } };
}

function rippleEffectMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const ripples = [];
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    if(Math.random() < 0.05){
      ripples.push({
        x: Math.random()*W,
        y: Math.random()*H,
        r: 0,
        maxR: 100 + Math.random()*200,
        life: 1
      });
    }
    for(let i=ripples.length-1; i>=0; i--){
      const rip = ripples[i];
      rip.r += 3;
      rip.life = 1 - rip.r/rip.maxR;
      if(rip.life <= 0){
        ripples.splice(i, 1);
        continue;
      }
      ctx.beginPath();
      ctx.arc(rip.x, rip.y, rip.r, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(0,240,255,${rip.life*0.6})`;
      ctx.lineWidth = 3;
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function nebulaSwirlMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const particles = Array.from({length:500}, ()=>({
    ang: Math.random()*Math.PI*2,
    r: Math.random()*W*0.45,
    speed: 0.01 + Math.random()*0.02,
    size: 1 + Math.random()*3,
    color: Math.random()
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.02)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0; i<particles.length; i++){
      const p = particles[i];
      p.ang += p.speed;
      const x = Math.cos(p.ang)*p.r;
      const y = Math.sin(p.ang)*p.r;
      const hue = p.color*360;
      ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.6)`;
      ctx.fillRect(x, y, p.size, p.size);
    }
    ctx.globalCompositeOperation = 'source-over';
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function binaryClockMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const runner = makeRunner((t)=>{
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    const now = new Date();
    const h = now.getHours();
    const m = now.getMinutes();
    const s = now.getSeconds();
    const values = [
      Math.floor(h/10), h%10,
      Math.floor(m/10), m%10,
      Math.floor(s/10), s%10
    ];
    ctx.save();
    ctx.translate(W/2 - 150, H/2 - 80);
    for(let col=0; col<6; col++){
      const val = values[col];
      for(let row=0; row<4; row++){
        const bit = (val >> (3-row)) & 1;
        ctx.fillStyle = bit ? 'rgba(0,255,140,0.9)' : 'rgba(255,255,255,0.1)';
        ctx.fillRect(col*50, row*40, 40, 30);
      }
    }
    ctx.restore();
    ctx.font = '20px monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.fillText(`${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`, W/2-60, H/2+120);
  });
  return { unmount(){ runner.stop(); } };
}

function magneticFieldMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    const d = 200;
    ctx.fillStyle = 'rgba(255,0,0,0.8)';
    ctx.beginPath();
    ctx.arc(-d/2, 0, 20, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(0,0,255,0.8)';
    ctx.beginPath();
    ctx.arc(d/2, 0, 20, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(176,67,255,0.4)';
    ctx.lineWidth = 2;
    for(let i=-8; i<=8; i++){
      ctx.beginPath();
      for(let t=0; t<=1; t+=0.02){
        const x = (t-0.5)*W*0.8;
        const y = i*30 + Math.sin(t*Math.PI*2 + tt)*40*Math.exp(-Math.abs(i)*0.1);
        if(t===0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function fiberNetworkMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const nodes = Array.from({length:20}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H
  }));
  const connections = [];
  for(let i=0; i<nodes.length; i++){
    const numConn = 2 + Math.floor(Math.random()*3);
    for(let j=0; j<numConn; j++){
      const target = Math.floor(Math.random()*nodes.length);
      if(target !== i){
        connections.push({from: i, to: target, phase: Math.random()*Math.PI*2});
      }
    }
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<connections.length; i++){
      const c = connections[i];
      const n1 = nodes[c.from];
      const n2 = nodes[c.to];
      const pulse = Math.sin(tt*2 + c.phase)*0.5 + 0.5;
      ctx.strokeStyle = `rgba(0,240,255,${0.2 + pulse*0.4})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(n1.x, n1.y);
      const cx = (n1.x + n2.x)/2 + (Math.random()-0.5)*100;
      const cy = (n1.y + n2.y)/2 + (Math.random()-0.5)*100;
      ctx.quadraticCurveTo(cx, cy, n2.x, n2.y);
      ctx.stroke();
    }
    ctx.fillStyle = 'rgba(0,240,255,0.8)';
    for(let i=0; i<nodes.length; i++){
      ctx.beginPath();
      ctx.arc(nodes[i].x, nodes[i].y, 6, 0, Math.PI*2);
      ctx.fill();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function quantumWaveMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let layer=0; layer<5; layer++){
      ctx.strokeStyle = `rgba(176,67,255,${0.6 - layer*0.1})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      for(let x=-W/2; x<=W/2; x+=5){
        const k = 0.01;
        const omega = 2;
        const y = 80*Math.sin(k*x - omega*tt + layer*0.5)*Math.exp(-Math.abs(x)*0.002);
        if(x===-W/2) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.fillStyle = `rgba(176,67,255,${0.1 - layer*0.02})`;
      ctx.beginPath();
      for(let x=-W/2; x<=W/2; x+=5){
        const k = 0.01;
        const omega = 2;
        const y = 80*Math.sin(k*x - omega*tt + layer*0.5)*Math.exp(-Math.abs(x)*0.002);
        if(x===-W/2) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.lineTo(W/2, 0);
      ctx.lineTo(-W/2, 0);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function cyberEyeMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.beginPath();
    ctx.ellipse(0, 0, 250, 150, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(10,10,20,0.9)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,240,255,0.8)';
    ctx.lineWidth = 3;
    ctx.stroke();
    const irisSize = 80 + Math.sin(tt*2)*20;
    const grd = ctx.createRadialGradient(0,0,0,0,0,irisSize);
    grd.addColorStop(0, 'rgba(0,240,255,0.9)');
    grd.addColorStop(0.3, 'rgba(176,67,255,0.7)');
    grd.addColorStop(0.6, 'rgba(100,30,150,0.5)');
    grd.addColorStop(1, 'rgba(0,0,0,0.8)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(0, 0, irisSize, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(0,0,0,0.9)';
    ctx.beginPath();
    ctx.arc(0, 0, 30, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.beginPath();
    ctx.arc(-10, -10, 12, 0, Math.PI*2);
    ctx.fill();
    for(let i=0; i<12; i++){
      const ang = (i/12)*Math.PI*2 + tt;
      ctx.strokeStyle = 'rgba(0,240,255,0.3)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(Math.cos(ang)*irisSize, Math.sin(ang)*irisSize);
      ctx.lineTo(Math.cos(ang)*30, Math.sin(ang)*30);
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function pulseWaveMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let layer=0; layer<6; layer++){
      ctx.strokeStyle = `rgba(0,240,255,${0.7 - layer*0.1})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      for(let x=-W/2; x<=W/2; x+=8){
        let y = 0;
        const pulseWidth = 150;
        const offset = (tt*200 - layer*50) % W - W/2;
        if(Math.abs(x - offset) < pulseWidth){
          const t = (x - offset)/pulseWidth;
          y = Math.sin(t*Math.PI*4)*100*Math.exp(-Math.abs(t)*2);
        }
        if(x===-W/2) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function mandelbrotSetMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    const zoom = 1 + Math.sin(tt*0.3)*0.5;
    const offsetX = Math.cos(tt*0.2)*0.5;
    const offsetY = Math.sin(tt*0.2)*0.3;
    for(let px=0; px<W; px+=2){
      for(let py=0; py<H; py+=2){
        const x0 = (px - W/2)/(W/4)*zoom/zoom + offsetX;
        const y0 = (py - H/2)/(H/4)*zoom/zoom + offsetY;
        let x = 0, y = 0, iteration = 0;
        const maxIter = 50;
        while(x*x + y*y <= 4 && iteration < maxIter){
          const xtemp = x*x - y*y + x0;
          y = 2*x*y + y0;
          x = xtemp;
          iteration++;
        }
        if(iteration < maxIter){
          const hue = (iteration/maxIter)*360;
          ctx.fillStyle = `hsla(${hue}, 80%, 50%, 0.8)`;
        } else {
          ctx.fillStyle = '#000';
        }
        ctx.fillRect(px, py, 2, 2);
      }
    }
  });
  return { unmount(){ runner.stop(); } };
}

function kaleidoscopeMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    const segments = 12;
    for(let i=0; i<segments; i++){
      ctx.save();
      ctx.rotate((i/segments)*Math.PI*2);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(W/2, 0);
      ctx.lineTo(W/2, H/2);
      ctx.closePath();
      ctx.clip();
      for(let j=0; j<5; j++){
        const x = 50 + j*80 + Math.sin(tt + j)*30;
        const y = 50 + Math.cos(tt*1.5 + j)*50;
        const size = 40 + Math.sin(tt*2 + j)*20;
        const hue = (tt*50 + j*60) % 360;
        ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.6)`;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function laserShowMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const lasers = Array.from({length:12}, (_, i)=>({
    ang: (i/12)*Math.PI*2,
    speed: 0.5 + Math.random()*1,
    color: `hsla(${Math.random()*360}, 80%, 60%, `
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0; i<lasers.length; i++){
      const l = lasers[i];
      l.ang += l.speed*0.02;
      const x = Math.cos(l.ang)*W*0.4;
      const y = Math.sin(l.ang)*H*0.4;
      const grd = ctx.createLinearGradient(0,0,x,y);
      grd.addColorStop(0, l.color + '0.8)');
      grd.addColorStop(0.5, l.color + '0.4)');
      grd.addColorStop(1, l.color + '0)');
      ctx.strokeStyle = grd;
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(x, y);
      ctx.stroke();
    }
    ctx.globalCompositeOperation = 'source-over';
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function blackHoleMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const particles = Array.from({length:300}, ()=>({
    ang: Math.random()*Math.PI*2,
    r: W*0.3 + Math.random()*W*0.2,
    speed: 0.5 + Math.random()*1.5,
    size: 1 + Math.random()*3
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<particles.length; i++){
      const p = particles[i];
      p.ang += p.speed*0.01;
      p.r -= p.speed*0.5;
      if(p.r < 50){
        p.r = W*0.3 + Math.random()*W*0.2;
        p.ang = Math.random()*Math.PI*2;
      }
      const x = Math.cos(p.ang)*p.r;
      const y = Math.sin(p.ang)*p.r;
      const brightness = 1 - p.r/(W*0.5);
      ctx.fillStyle = `rgba(${100 + brightness*155},${50 + brightness*100},255,${0.6 + brightness*0.4})`;
      ctx.fillRect(x, y, p.size, p.size);
    }
    for(let i=0; i<8; i++){
      ctx.beginPath();
      ctx.arc(0, 0, 30 + i*20, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(176,67,255,${0.4 - i*0.04})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    const grd = ctx.createRadialGradient(0,0,0,0,0,60);
    grd.addColorStop(0, 'rgba(0,0,0,1)');
    grd.addColorStop(0.7, 'rgba(0,0,0,0.8)');
    grd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(0, 0, 60, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function circuitBoardMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const nodes = Array.from({length:30}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    connections: []
  }));
  for(let i=0; i<nodes.length; i++){
    const numConn = 2 + Math.floor(Math.random()*3);
    for(let j=0; j<numConn; j++){
      const target = Math.floor(Math.random()*nodes.length);
      if(target !== i && !nodes[i].connections.includes(target)){
        nodes[i].connections.push(target);
      }
    }
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,10,0,0.05)'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = 'rgba(0,255,140,0.4)';
    ctx.lineWidth = 2;
    for(let i=0; i<nodes.length; i++){
      const n1 = nodes[i];
      for(let j=0; j<n1.connections.length; j++){
        const n2 = nodes[n1.connections[j]];
        const pulse = Math.sin(tt*2 + i + j)*0.5 + 0.5;
        ctx.strokeStyle = `rgba(0,255,140,${0.2 + pulse*0.3})`;
        ctx.beginPath();
        ctx.moveTo(n1.x, n1.y);
        const mx = (n1.x + n2.x)/2;
        const my = (n1.y + n2.y)/2;
        if(Math.abs(n1.x - n2.x) > Math.abs(n1.y - n2.y)){
          ctx.lineTo(mx, n1.y);
          ctx.lineTo(mx, n2.y);
        } else {
          ctx.lineTo(n1.x, my);
          ctx.lineTo(n2.x, my);
        }
        ctx.lineTo(n2.x, n2.y);
        ctx.stroke();
      }
    }
    for(let i=0; i<nodes.length; i++){
      const n = nodes[i];
      const pulse = Math.sin(tt*3 + i)*0.5 + 0.5;
      ctx.fillStyle = `rgba(0,240,255,${0.6 + pulse*0.4})`;
      ctx.beginPath();
      ctx.arc(n.x, n.y, 6, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,255,140,0.8)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function audioVisualizerMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const bars = 128;
  const barHeights = new Array(bars).fill(0);
  const barVels = new Array(bars).fill(0);
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<bars; i++){
      const target = Math.abs(Math.sin(tt*2 + i*0.1))*0.8 + Math.random()*0.2;
      barVels[i] += (target - barHeights[i])*0.1;
      barVels[i] *= 0.9;
      barHeights[i] += barVels[i];
      barHeights[i] = Math.max(0, Math.min(1, barHeights[i]));
    }
    const barWidth = W/bars;
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<bars; i++){
      const h = barHeights[i]*H*0.4;
      const ang = (i/bars)*Math.PI*2;
      const r1 = 100;
      const r2 = r1 + h;
      const x1 = Math.cos(ang)*r1;
      const y1 = Math.sin(ang)*r1;
      const x2 = Math.cos(ang)*r2;
      const y2 = Math.sin(ang)*r2;
      const hue = (i/bars)*360;
      const grd = ctx.createLinearGradient(x1,y1,x2,y2);
      grd.addColorStop(0, `hsla(${hue}, 80%, 60%, 0.8)`);
      grd.addColorStop(1, `hsla(${hue}, 80%, 40%, 0.8)`);
      ctx.strokeStyle = grd;
      ctx.lineWidth = barWidth*0.8;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function timeTunnelMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const rings = Array.from({length:20}, (_, i)=>({
    z: i*50,
    rotation: Math.random()*Math.PI*2
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<rings.length; i++){
      const ring = rings[i];
      ring.z -= 3;
      if(ring.z < 0){
        ring.z = 1000;
        ring.rotation = Math.random()*Math.PI*2;
      }
      const scale = 1000/(ring.z + 1);
      const alpha = Math.min(1, scale*0.5);
      ring.rotation += 0.01;
      ctx.save();
      ctx.rotate(ring.rotation);
      ctx.beginPath();
      ctx.arc(0, 0, 100*scale, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(0,240,255,${alpha*0.6})`;
      ctx.lineWidth = 3*scale;
      ctx.stroke();
      for(let j=0; j<12; j++){
        const ang = (j/12)*Math.PI*2;
        ctx.beginPath();
        ctx.moveTo(Math.cos(ang)*80*scale, Math.sin(ang)*80*scale);
        ctx.lineTo(Math.cos(ang)*120*scale, Math.sin(ang)*120*scale);
        ctx.strokeStyle = `rgba(176,67,255,${alpha*0.4})`;
        ctx.lineWidth = 2*scale;
        ctx.stroke();
      }
      ctx.restore();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function plasmaStormMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    ctx.globalCompositeOperation = 'lighter';
    for(let x=0; x<W; x+=8){
      for(let y=0; y<H; y+=8){
        const v = Math.sin(x*0.02 + tt)*Math.cos(y*0.02 + tt*1.3) +
                  Math.sin(Math.sqrt((x-W/2)**2 + (y-H/2)**2)*0.02 - tt*2);
        const hue = (v*180 + tt*50) % 360;
        const brightness = (v + 2)/4;
        ctx.fillStyle = `hsla(${hue}, 80%, ${brightness*60}%, ${brightness*0.6})`;
        ctx.fillRect(x, y, 8, 8);
      }
    }
    ctx.globalCompositeOperation = 'source-over';
  });
  return { unmount(){ runner.stop(); } };
}

const templates = {
  cyberMinimal: { mount: cyberMinimalMount },
  cryptoOrb: { mount: cryptoOrbMount },
  retroTerminal: { mount: retroTerminalMount },
  zenSpace: { mount: zenSpaceMount },
  liquidWaves: { mount: liquidWavesMount },
  matrixRain: { mount: matrixRainMount },
  hexGridPulse: { mount: hexGridPulseMount },
  clockSync: { mount: clockSyncMount },
  codeVerse: { mount: codeVerseMount },
  aiBloom: { mount: aiBloomMount },
  signatureLoop: { mount: signatureLoopMount },
  neonCity: { mount: neonCityMount },
  glitchArt: { mount: glitchArtMount },
  vaporwave: { mount: vaporwaveMount },
  hologram: { mount: hologramMount },
  pixelStorm: { mount: pixelStormMount },
  scanlines: { mount: scanlinesMount },
  dataStream: { mount: dataStreamMount },
  particleNebula: { mount: particleNebulaMount },
  geometricDance: { mount: geometricDanceMount },
  synthwave: { mount: synthwaveMount },
  digitalRain: { mount: digitalRainMount },
  cosmicVoid: { mount: cosmicVoidMount },
  fractalTree: { mount: fractalTreeMount },
  waveform: { mount: waveformMount },
  starfield: { mount: starfieldMount },
  cyberpunkGrid: { mount: cyberpunkGridMount },
  dnaHelix: { mount: dnaHelixMount },
  liquidMetal: { mount: liquidMetalMount },
  quantumEntangle: { mount: quantumEntangleMount },
  neuralNet: { mount: neuralNetMount },
  crystalGrowth: { mount: crystalGrowthMount },
  radarScan: { mount: radarScanMount },
  energyShield: { mount: energyShieldMount },
  spectrumAnalyzer: { mount: spectrumAnalyzerMount },
  particleExplosion: { mount: particleExplosionMount },
  rippleEffect: { mount: rippleEffectMount },
  nebulaSwirl: { mount: nebulaSwirlMount },
  binaryClock: { mount: binaryClockMount },
  magneticField: { mount: magneticFieldMount },
  fiberNetwork: { mount: fiberNetworkMount },
  quantumWave: { mount: quantumWaveMount },
  cyberEye: { mount: cyberEyeMount },
  pulseWave: { mount: pulseWaveMount },
  mandelbrotSet: { mount: mandelbrotSetMount },
  kaleidoscope: { mount: kaleidoscopeMount },
  laserShow: { mount: laserShowMount },
  blackHole: { mount: blackHoleMount },
  circuitBoard: { mount: circuitBoardMount },
  audioVisualizer: { mount: audioVisualizerMount },
  timeTunnel: { mount: timeTunnelMount },
  plasmaStorm: { mount: plasmaStormMount }
};

window.addEventListener('beforeunload', ()=>{
  stopAutoplay();
  if(activeInstance && typeof activeInstance.unmount === 'function') activeInstance.unmount();
});

window.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape') closeOverlay();
  if(e.key === 'ArrowRight') nextTemplate();
  if(e.key === 'ArrowLeft') {
    const idx = (currentIndex - 1 + TEMPLATE_IDS.length) % TEMPLATE_IDS.length;
    openTemplate(idx);
  }
});

autoplayToggle.classList.toggle('toggled', autoplay);

</script>
</body>
</html>
