<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>dGEN Town — Visual Collection for dGEN1</title>

<!-- Keeping fonts -->
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#000000;
    --muted:#0f1112;
    --accent1:#00f0ff; /* electric cyan */
    --accent2:#b043ff; /* violet */
    --glass: rgba(255,255,255,0.04);
    --text: rgba(255,255,255,0.9);
    --small: 12px;
  }
  html,body{
    height:100%;
    margin:0;
    background:var(--bg);
    color:var(--text);
    font-family: "Rajdhani", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  /* 居中容器:保证 1:1 的 720x720 视窗在任意屏幕居中显示 */
  .stage {
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:40px 20px;
    box-sizing:border-box;
  }

  .frame {
 
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:12px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.8), inset 0 1px 0 rgba(255,255,255,0.02);
    overflow:hidden;
    position:relative;
    border:1px solid rgba(255,255,255,0.03);
  }

  /* 微粒背景(全局) */
  .grain {
    position:absolute;
    inset:0;
    pointer-events:none;
    background-image: radial-gradient(rgba(255,255,255,0.015) 1px, transparent 1px);
    background-size: 3px 3px;
    opacity:0.6;
    mix-blend-mode: overlay;
  }

  header {
    position:absolute;
    top:0;
    left:20px;
    right:20px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    z-index:50;
    pointer-events:none;
  }

  .title {
    display:flex;
    align-items:center;
    gap:12px;
    pointer-events:auto;
  }

  .logo {
    font-family: "Orbitron", monospace;
    font-weight:700;
    color:var(--accent1);
    font-size:18px;
    letter-spacing:1px;
    opacity:0.95;
    text-shadow: 0 2px 18px rgba(0,240,255,0.06);
    background: linear-gradient(90deg, rgba(0,240,255,0.12), rgba(176,67,255,0.04));
    padding:6px 10px;
    border-radius:8px;
  }

  .title h1{
    margin:0;
    font-size:18px;
    color:rgba(255,255,255,0.92);
    letter-spacing:1px;
  }
  .title p{ margin:0; font-size:12px; color:rgba(255,255,255,0.35);}

  .controls {
    display:flex;
    gap:10px;
    align-items:center;
    pointer-events:auto;
  }

  .btn {
    background:var(--glass);
    border:1px solid rgba(255,255,255,0.03);
    padding:8px 10px;
    border-radius:8px;
    cursor:pointer;
    color:var(--text);
    font-size:13px;
    display:inline-flex;
    gap:8px;
    align-items:center;
    transition:transform .18s ease, box-shadow .18s ease;
    user-select:none;
  }
  .btn:hover{ transform:translateY(-4px); box-shadow: 0 8px 28px rgba(0,0,0,0.5); }
  .btn.toggled { background: linear-gradient(90deg, rgba(0,240,255,0.06), rgba(176,67,255,0.02)); }

  /* 主页模板网格 */
  .gallery {
    padding:88px 36px 36px 36px;
    box-sizing:border-box;
    height:100%;
    display:grid;
    grid-template-columns: repeat(4, 1fr);
    grid-auto-rows: 1fr;
    gap:18px;
    z-index:10;
  }

  .card {
    border-radius:8px;
    overflow:hidden;
    background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
    border:1px solid rgba(255,255,255,0.02);
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    cursor:pointer;
    transition:transform .25s ease, box-shadow .25s ease;
  }
  .card:hover { transform: translateY(-8px); box-shadow: 0 14px 40px rgba(0,0,0,0.7); }
  .card canvas { width:100%; height:100%; display:block; }

  .card .label {
    position:absolute;
    left:12px;
    bottom:8px;
    font-size:12px;
    color:rgba(255,255,255,0.9);
    background: linear-gradient(180deg, rgba(0,0,0,0.25), rgba(255,255,255,0.02));
    padding:6px 8px;
    border-radius:6px;
    backdrop-filter: blur(4px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.6);
  }

  /* 展示层(overlay) */
  .overlay {
    position:absolute;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    z-index:60;
    background: linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.65));
    backdrop-filter: blur(6px);
  }
  .overlay.active { display:flex; animation:overlayIn .35s ease both; }
  @keyframes overlayIn { from{opacity:0; transform:scale(.995);} to{opacity:1; transform:none;} }

  .canvas-wrap{
    width:720px;
    height:720px;
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
    border-radius:10px;
    background:transparent;
  }

  .overlay-ui {
    position:absolute;
    inset:18px;
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    pointer-events:none;
  }
  .overlay-left, .overlay-right {
    pointer-events:auto;
    display:flex;
    gap:10px;
    align-items:center;
  }
  .back-btn {
    background:transparent;
    border:1px solid rgba(255,255,255,0.06);
    color:var(--text);
    padding:8px 10px;
    border-radius:8px;
    cursor:pointer;
    backdrop-filter: blur(6px);
  }
  .small {
    font-size:12px;
    color:rgba(255,255,255,0.7);
    opacity:0.9;
  }

  /* bottom-right autoplay bubble */
  .bubble {
    position:absolute;
    right:18px;
    bottom:18px;
    pointer-events:auto;
    display:flex;
    gap:10px;
    align-items:center;
  }
  .dot {
    width:10px;height:10px;border-radius:50%;
    background:var(--accent1);
    box-shadow:0 6px 20px rgba(0,240,255,0.08);
    opacity:0.9;
  }

  /* footer micro logo */
  .micro {
    position:absolute;
    left:18px;
    bottom:18px;
    font-size:11px;
    color:rgba(255,255,255,0.28);
    pointer-events:auto;
  }

  /* Pic Frame controls */
  .pic-controls {
    display:flex;
    gap:8px;
    align-items:center;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:8px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.03);
  }
  .input {
    background:transparent;border:1px dashed rgba(255,255,255,0.06);padding:6px;border-radius:6px;color:var(--text);font-size:12px;
  }

  /* 提示文字 */
  .hint {
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    font-size:13px;
    color:rgba(255,255,255,0.12);
    text-align:center;
    width:70%;
    pointer-events:none;
  }

  /* small responsive tweak for very small screens */
  @media (max-width:800px){
    .frame{ width:90vw; height:90vw; }
    .canvas-wrap{ width:90vw; height:90vw; }
    .gallery{ grid-template-columns: repeat(3, 1fr); padding:80px 20px 20px 20px; }
  }

</style>
</head>
<body>
  <div class="stage">
    <div class="frame" role="application" aria-label="dGEN Town visual frame">
      <div class="grain" aria-hidden="true"></div>

      <header>
        <div class="title">
          <div class="logo">dGEN1</div>
          <div>
            <h1>dGEN Town</h1>
            <!-- Changed back to English -->
            <p style="margin-top:4px;">Visual Collection — Click card to enter</p>
          </div>
        </div>

        <div class="controls">
          <!-- Changed all button text to English -->
          <button id="autoplayToggle" class="btn" title="Toggle autoplay">Autoplay</button>
          <button id="randomBtn" class="btn" title="Random template">Random</button>
          <button id="helpBtn" class="btn" title="Help/Info">Info</button>
        </div>
      </header>

      <!-- 模板网格 -->
      <main class="gallery" id="gallery" aria-hidden="false">
        <!-- 12 cards created by JS for easier mapping -->
      </main>

      <div class="micro">dGEN Town · © 2025</div>

      <!-- overlay for template display -->
      <div class="overlay" id="overlay" aria-hidden="true">
        <div class="canvas-wrap" id="canvasWrap">
          <!-- main canvas inserted by JS -->
        </div>

        <div class="overlay-ui" aria-hidden="false">
          <div class="overlay-left">
            <!-- Changed back button text to English -->
            <button id="backBtn" class="back-btn" title="Back to gallery">← Back</button>
            <div class="small" id="currentLabel">—</div>
          </div>
          <div class="overlay-right" style="align-items:center">
            <!-- PicFrame controls appear here dynamically -->
            <div id="picControlsContainer"></div>
            <div class="bubble">
              <div class="dot" id="autoplayDot" style="display:none"></div>
              <!-- Changed to English -->
              <div class="small">Auto</div>
              <button id="nextBtn" class="btn" title="Next template">Next</button>
            </div>
          </div>
        </div>

        <!-- Removed the hint overlay that said "Click to return" -->
      </div>

    </div>
  </div>

<script>
/*
  dGEN Town - index.html
  Single-file visual gallery for dGEN1 (720x720)
  - 12 templates
  - smooth transitions
  - autoplay with toggle
  - Pic Frame supports file upload or image URL
  NOTES:
  - Each template is a module in templates object: { id, name, preview, mount, unmount }
  - preview(ctx, w, h) is used to render small thumbnail canvas (kept cheap)
  - mount(canvas) called when entering overlay to run full animation
  - unmount() should stop RAF loops and clear resources
*/

// Utilities
const $ = sel => document.querySelector(sel);
const create = (tag, attrs={}, parent=null) => {
  const el = document.createElement(tag);
  Object.entries(attrs).forEach(([k,v])=>{
    if(k === 'class') el.className = v;
    else if(k === 'html') el.innerHTML = v;
    else el.setAttribute(k, v);
  });
  if(parent) parent.appendChild(el);
  return el;
};

const TEMPLATE_IDS = [
  'cyberMinimal','cryptoOrb','retroTerminal','zenSpace',
  'picFrame','liquidWaves','matrixRain','hexGridPulse',
  'clockSync','codeVerse','aiBloom','signatureLoop'
];

const TEMPLATE_META = {
  cyberMinimal: {name:'Cyber Minimal'},
  cryptoOrb: {name:'Crypto Orb'},
  retroTerminal: {name:'Retro Terminal'},
  zenSpace: {name:'Zen Space'},
  picFrame: {name:'Pic Frame'},
  liquidWaves: {name:'Liquid Waves'},
  matrixRain: {name:'Matrix Rain'},
  hexGridPulse: {name:'Hex Grid Pulse'},
  clockSync: {name:'Clock Sync'},
  codeVerse: {name:'Code Verse'},
  aiBloom: {name:'AI Bloom'},
  signatureLoop: {name:'Signature Loop'}
};

// global controller
let autoplay = false;
let autoplayTimer = null;
let currentIndex = -1;
let activeInstance = null; // template instance with unmount

// create gallery cards
const gallery = $('#gallery');
TEMPLATE_IDS.forEach((id, i)=>{
  const card = create('div', {class:'card', id:'card-'+id}, gallery);
  const thumb = create('canvas', {width:300, height:300}, card);
  const label = create('div', {class:'label', html: TEMPLATE_META[id].name}, card);

  card.addEventListener('click', ()=> openTemplate(i));
  
  setTimeout(()=> {
    const ctx = thumb.getContext('2d');
    const w = thumb.width, h = thumb.height;
    
    // 更亮的背景
    ctx.fillStyle = '#0a0a0c';
    ctx.fillRect(0,0,w,h);
    
    // 为每个模板创建独特且可见的预览图形
    ctx.save();
    ctx.translate(w/2, h/2);
    
    switch(id) {
      case 'cyberMinimal':
        // 旋转方块
        ctx.strokeStyle = 'rgba(0,240,255,0.4)';
        ctx.lineWidth = 3;
        ctx.strokeRect(-60, -60, 120, 120);
        ctx.rotate(Math.PI/4);
        ctx.strokeStyle = 'rgba(176,67,255,0.3)';
        ctx.strokeRect(-50, -50, 100, 100);
        break;
        
      case 'cryptoOrb':
        // 发光球体
        const grd = ctx.createRadialGradient(0,0,10,0,0,80);
        grd.addColorStop(0, 'rgba(0,240,255,0.6)');
        grd.addColorStop(0.5, 'rgba(176,67,255,0.3)');
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd;
        ctx.fillRect(-100,-100,200,200);
        ctx.beginPath();
        ctx.arc(0,0,40,0,Math.PI*2);
        ctx.fillStyle = 'rgba(0,240,255,0.2)';
        ctx.fill();
        break;
        
      case 'retroTerminal':
        // 终端文字
        ctx.font = '14px monospace';
        ctx.fillStyle = 'rgba(0,255,140,0.6)';
        for(let j=0; j<8; j++) {
          ctx.fillText('> 0x' + Math.random().toString(16).substr(2,8), -120, -60 + j*20);
        }
        break;
        
      case 'zenSpace':
        // 柔和圆圈
        ctx.beginPath();
        ctx.arc(0,0,80,0,Math.PI*2);
        ctx.fillStyle = 'rgba(176,67,255,0.25)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 2;
        for(let j=0; j<3; j++) {
          ctx.beginPath();
          ctx.arc(0, j*15, 60-j*15, 0, Math.PI*2);
          ctx.stroke();
        }
        break;
        
      case 'picFrame':
        // 相框轮廓
        ctx.strokeStyle = 'rgba(0,240,255,0.4)';
        ctx.lineWidth = 3;
        ctx.strokeRect(-80,-80,160,160);
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.font = '16px Rajdhani';
        ctx.fillText('📷', -12, 8);
        break;
        
      case 'liquidWaves':
        // 波浪线条
        ctx.strokeStyle = 'rgba(0,240,255,0.4)';
        ctx.lineWidth = 2;
        for(let j=0; j<5; j++) {
          ctx.beginPath();
          for(let x=-120; x<=120; x+=10) {
            const y = Math.sin(x*0.05 + j*0.5)*20 + j*10 - 40;
            if(x===-120) ctx.moveTo(x,y);
            else ctx.lineTo(x,y);
          }
          ctx.stroke();
        }
        break;
        
      case 'matrixRain':
        // 矩阵风格
        ctx.font = '16px monospace';
        ctx.fillStyle = 'rgba(0,255,140,0.5)';
        for(let j=0; j<15; j++) {
          const x = (j-7)*20;
          const y = (j%3)*30 - 40;
          ctx.fillText(Math.random()>0.5?'1':'0', x, y);
        }
        break;
        
      case 'hexGridPulse':
        // 六边形
        ctx.strokeStyle = 'rgba(0,240,255,0.3)';
        ctx.lineWidth = 2;
        for(let hx=-2; hx<=2; hx++) {
          for(let hy=-2; hy<=2; hy++) {
            const px = hx*30 + (hy%2?15:0);
            const py = hy*26;
            ctx.beginPath();
            for(let k=0; k<6; k++) {
              const ang = (Math.PI*2/6)*k;
              const x = px + Math.cos(ang)*15;
              const y = py + Math.sin(ang)*15;
              if(k===0) ctx.moveTo(x,y);
              else ctx.lineTo(x,y);
            }
            ctx.closePath();
            ctx.stroke();
          }
        }
        break;
        
      case 'clockSync':
        // 时钟表盘
        ctx.beginPath();
        ctx.arc(0,0,70,0,Math.PI*2);
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 2;
        ctx.stroke();
        // 时针分针
        ctx.strokeStyle = 'rgba(0,240,255,0.6)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(0,-50);
        ctx.stroke();
        ctx.strokeStyle = 'rgba(176,67,255,0.6)';
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(35,0);
        ctx.stroke();
        break;
        
      case 'codeVerse':
        // 代码片段
        ctx.font = '12px monospace';
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        const snippets = ['function()', 'const x =', 'if (true)', '{ code }', 'return;'];
        snippets.forEach((s,j)=>{
          ctx.fillText(s, -60, -40 + j*20);
        });
        break;
        
      case 'aiBloom':
        // 花瓣
        for(let j=0; j<12; j++) {
          const ang = (j/12)*Math.PI*2;
          ctx.beginPath();
          ctx.moveTo(0,0);
          ctx.arc(Math.cos(ang)*40, Math.sin(ang)*40, 30, ang-0.5, ang+0.5);
          ctx.fillStyle = `rgba(176,67,255,${0.15 + j*0.01})`;
          ctx.fill();
        }
        break;
        
      case 'signatureLoop':
        // 流动曲线
        ctx.strokeStyle = 'rgba(0,240,255,0.3)';
        ctx.lineWidth = 2;
        for(let j=0; j<4; j++) {
          ctx.beginPath();
          for(let t=0; t<=1; t+=0.05) {
            const x = (t-0.5)*200;
            const y = Math.sin(t*Math.PI*3 + j)*30 + j*15 - 30;
            if(t===0) ctx.moveTo(x,y);
            else ctx.lineTo(x,y);
          }
          ctx.stroke();
        }
        break;
    }
    
    ctx.restore();
    
    // 底部标签栏
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(0, h-40, w, 40);
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.font = '14px Rajdhani, sans-serif';
    ctx.fillText(TEMPLATE_META[id].name, 12, h-16);
  }, 50 + i*20); // 稍微错开渲染时间
});

// overlay elements
const overlay = $('#overlay');
const canvasWrap = $('#canvasWrap');
const backBtn = $('#backBtn');
const currentLabel = $('#currentLabel');
const autoplayToggle = $('#autoplayToggle');
const nextBtn = $('#nextBtn');
const autoplayDot = $('#autoplayDot');
const picControlsContainer = $('#picControlsContainer');
const randomBtn = $('#randomBtn');
const helpBtn = $('#helpBtn');
const overlayHint = $('#overlayHint'); // Note: This element is present in HTML but not used in JS

backBtn.addEventListener('click', closeOverlay);
autoplayToggle.addEventListener('click', ()=> {
  autoplay = !autoplay;
  autoplayToggle.classList.toggle('toggled', autoplay);
  autoplayDot.style.display = autoplay ? 'block' : 'none';
  if(autoplay) startAutoplay(); else stopAutoplay();
});
nextBtn.addEventListener('click', ()=> nextTemplate());
randomBtn.addEventListener('click', ()=> {
  const idx = Math.floor(Math.random()*TEMPLATE_IDS.length);
  openTemplate(idx);
});
helpBtn.addEventListener('click', ()=> {
  alert('dGEN Town — 12 templates for dGEN1. Click cards to view. Autoplay switches every 20s. Pic Frame supports file upload or image URL.');
});

// Auto-play functions
function startAutoplay(){
  stopAutoplay();
  autoplayTimer = setInterval(()=> {
    nextTemplate();
  }, 20000); // 20s
}
function stopAutoplay(){
  if(autoplayTimer){ clearInterval(autoplayTimer); autoplayTimer = null; }
}

// Overlay open/close
function openTemplate(index){
  // clamp
  index = (index + TEMPLATE_IDS.length) % TEMPLATE_IDS.length;
  currentIndex = index;
  const id = TEMPLATE_IDS[index];
  currentLabel.textContent = TEMPLATE_META[id].name;
  overlay.classList.add('active');
  overlay.setAttribute('aria-hidden','false');

  // create canvas for template
  canvasWrap.innerHTML = '';
  const canvas = create('canvas', {width:720, height:720});
  canvas.style.width = '720px'; canvas.style.height='720px';
  canvasWrap.appendChild(canvas);

  // mount template
  const tmpl = templates[id];
  if(!tmpl) return;
  activeInstance = tmpl.mount(canvas, {onExit: closeOverlay});
  // show pic controls if picFrame
  picControlsContainer.innerHTML = '';
  if(id === 'picFrame'){
    const el = createPicControls(activeInstance);
    picControlsContainer.appendChild(el);
  }
}

function closeOverlay(){
  overlay.classList.remove('active');
  overlay.setAttribute('aria-hidden','true');
  // unmount template
  if(activeInstance && typeof activeInstance.unmount === 'function') {
    activeInstance.unmount();
    activeInstance = null;
  }
  canvasWrap.innerHTML = '';
}

// next template
function nextTemplate(){
  const idx = (currentIndex + 1) % TEMPLATE_IDS.length;
  // replace overlay with next
  if(overlay.classList.contains('active')){
    // unmount
    if(activeInstance && typeof activeInstance.unmount === 'function') activeInstance.unmount();
    currentIndex = idx;
    const id = TEMPLATE_IDS[idx];
    currentLabel.textContent = TEMPLATE_META[id].name;
    canvasWrap.innerHTML = '';
    const canvas = create('canvas', {width:720, height:720});
    canvas.style.width = '720px'; canvas.style.height='720px';
    canvasWrap.appendChild(canvas);
    const tmpl = templates[id];
    activeInstance = tmpl.mount(canvas, {onExit: closeOverlay});
    picControlsContainer.innerHTML = '';
    if(id === 'picFrame'){
      const el = createPicControls(activeInstance);
      picControlsContainer.appendChild(el);
    }
  } else {
    openTemplate(idx);
  }
}

/* ===========================
    Template implementations
   ===========================
   Each template returns an object with:
   - mount(canvas, opts) -> instance { unmount() }
   - (optional) preview draw handled above in simple form
*/

// Shared helper: stop flag and RAF loop helper
function makeRunner(renderFn){
  let running = true;
  let rafId = null;
  function loop(t){
    if(!running) return;
    renderFn(t);
    rafId = requestAnimationFrame(loop);
  }
  rafId = requestAnimationFrame(loop);
  return {
    stop(){ running = false; if(rafId) cancelAnimationFrame(rafId); }
  };
}

// Template: Cyber Minimal
function cyberMinimalMount(canvas){
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (t - t0)/1000;
    ctx.clearRect(0,0,w,h);
    // background vignette
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, 'rgba(0,0,0,0.9)');
    g.addColorStop(1, 'rgba(10,10,12,0.95)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
    // central rotating square with neon stroke
    ctx.save();
    ctx.translate(w/2, h/2);
    ctx.rotate(tt*0.18);
    ctx.strokeStyle = 'rgba(0,240,255,0.14)';
    ctx.lineWidth = 6;
    for(let i=0;i<4;i++){
      const s = 220 + Math.sin(tt*0.9 + i)*10;
      ctx.strokeRect(-s/2, -s/2, s, s);
    }
    ctx.restore();
    // moving thin lines
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(176,67,255,0.06)';
    ctx.beginPath();
    for(let i=0;i<6;i++){
      const y = h*(i+1)/7 + Math.sin(tt*0.6 + i)*6;
      ctx.moveTo(40, y); ctx.lineTo(w-40, y);
    }
    ctx.stroke();
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.font = '12px Rajdhani';
    ctx.fillText('dGEN1 • Cyber Minimal', 24, h-24);
  });
  return {
    unmount(){ runner.stop(); }
  };
}

// Template: Crypto Orb (particles)
function cryptoOrbMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  // create particles orbiting a center
  const N = 220;
  const pts = new Array(N).fill(0).map((_,i)=>({
    a: Math.random()*Math.PI*2,
    r: 60 + Math.random()*220,
    s: 0.4 + Math.random()*1.4,
    phase: Math.random()*10
  }));
  const runner = makeRunner((t)=>{
    const tsec = (performance.now() - t0)/1000;
    ctx.clearRect(0,0,W,H);
    // dark background
    ctx.fillStyle = 'rgba(0,0,0,0.96)';
    ctx.fillRect(0,0,W,H);
    // orb glow
    const cx = W/2, cy = H/2;
    const grd = ctx.createRadialGradient(cx,cy,10,cx,cy,260);
    grd.addColorStop(0, 'rgba(0,200,255,0.08)');
    grd.addColorStop(0.45, 'rgba(176,67,255,0.03)');
    grd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grd; ctx.fillRect(0,0,W,H);
    // particle trails
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0;i<N;i++){
      const p = pts[i];
      const a = p.a + tsec*0.2*(0.6 + p.s*0.3);
      const r = p.r + Math.sin(tsec*0.9 + p.phase)*6;
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r;
      const size = 0.8 + p.s*1.8;
      ctx.beginPath();
      ctx.fillStyle = `rgba(0,240,255,${0.02 + p.s*0.06})`;
      ctx.arc(x,y,size,0,Math.PI*2);
      ctx.fill();
    }
    ctx.globalCompositeOperation = 'source-over';
    // center orb
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,240,255,0.06)';
    ctx.arc(cx, cy, 62 + Math.sin(tsec*0.8)*6, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.font = '13px Rajdhani';
    ctx.fillText('Orbit • Chain Energy', 30, H-28);
  });
  return { unmount(){ runner.stop(); } };
}

// Template: Retro Terminal (text stream)
function retroTerminalMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  // setup lines
  const lines = Array.from({length:30}, ()=> '');
  const ch = 18;
  function randomLine(){
    const hex = '0123456789abcdef';
    let s = '';
    if(Math.random() < 0.2){
      s = 'block ' + Math.floor(Math.random()*999999) + ' detected';
    } else {
      for(let i=0;i<40;i++) s += hex[Math.floor(Math.random()*16)];
    }
    return s;
  }
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.98)';
    ctx.fillRect(0,0,W,H);
    // background slight green glow
    const grd = ctx.createLinearGradient(0,0,0,H);
    grd.addColorStop(0,'rgba(0,0,0,0)');
    grd.addColorStop(1,'rgba(0,0,0,0.02)');
    ctx.fillStyle = grd; ctx.fillRect(0,0,W,H);
    // push lines occasionally
    if(Math.random() < 0.28){
      lines.pop();
      lines.unshift(randomLine());
    }
    // draw text
    ctx.font = '16px "Courier New", monospace';
    for(let i=0;i<lines.length;i++){
      const y = 60 + i*ch;
      ctx.fillStyle = (i===0)? 'rgba(0,255,140,0.85)' : 'rgba(0,255,140,0.22)';
      ctx.fillText(lines[i], 22, y);
    }
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.font = '12px Rajdhani';
    ctx.fillText('Retro Terminal', 24, H-24);
  });
  return { unmount(){ runner.stop(); } };
}

// Template: Zen Space
function zenSpaceMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let s = 0;
  const runner = makeRunner((t)=>{
    const tt = t/1000;
    s = Math.sin(tt*0.12)*0.5 + 0.5;
    // soft gradient
    const g = ctx.createLinearGradient(0,0,W,H);
    g.addColorStop(0, `rgba(34,36,40,${0.16 + s*0.04})`);
    g.addColorStop(1, `rgba(8,10,12,0.98)`);
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
    // large soft circle
    ctx.beginPath();
    ctx.fillStyle = `rgba(176,67,255,${0.04 + s*0.06})`;
    ctx.arc(W/2, H/2 - 20, 220 + s*20, 0, Math.PI*2);
    ctx.fill();
    // slow floating lines
    ctx.strokeStyle = 'rgba(255,255,255,0.02)';
    ctx.lineWidth = 1.2;
    for(let i=0;i<5;i++){
      ctx.beginPath();
      const off = Math.sin(tt*0.3 + i)*18;
      ctx.ellipse(W/2, H/2 + off, 200 - i*30, 60, Math.PI/6, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.font = '12px Rajdhani';
    ctx.fillText('Zen Space', 24, H-24);
  });
  return { unmount(){ runner.stop(); } };
}

// Template: Pic Frame (user image)
function picFrameMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let running = true;
  let img = null;
  let fitMode = 'cover'; // cover or contain
  // initial placeholder
  const runner = makeRunner((t)=>{
    if(!running) return;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#070708';
    ctx.fillRect(0,0,W,H);
    // frame glow
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(36,36,W-72,H-72);
    ctx.restore();
    // draw image if any
    if(img && img.complete){
      // draw with cover fit
      const iw = img.width, ih = img.height;
      let sx=0,sy=0,sw=iw,sh=ih;
      if(fitMode === 'cover'){
        const scale = Math.max((W-120)/iw, (H-120)/ih);
        const dw = iw*scale, dh = ih*scale;
        const dx = (W - dw)/2, dy = (H - dh)/2;
        ctx.drawImage(img, 0,0,iw,ih, dx, dy, dw, dh);
      } else {
        // contain
        const scale = Math.min((W-120)/iw, (H-120)/ih);
        const dw = iw*scale, dh = ih*scale;
        const dx = (W - dw)/2, dy = (H - dh)/2;
        ctx.drawImage(img, 0,0,iw,ih, dx, dy, dw, dh);
      }
    } else {
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.fillRect(90, 120, W-180, H-240);
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.font = '16px Rajdhani';
      ctx.fillText('Pic Frame', W/2 - 36, H/2 - 6);
      ctx.font = '12px Rajdhani';
      ctx.fillStyle = 'rgba(255,255,255,0.04)';
      ctx.fillText('Upload image or enter image URL', W/2 - 110, H/2 + 16);
    }
    // frame border
    ctx.strokeStyle = 'rgba(0,240,255,0.06)';
    ctx.lineWidth = 2;
    ctx.strokeRect(30,30,W-60,H-60);
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.font = '12px Rajdhani';
    ctx.fillText('Pic Frame', 30, H-28);
  });

  return {
    unmount(){ running=false; runner.stop(); },
    setImageFromFile(file){
      const reader = new FileReader();
      reader.onload = e=>{
        const im = new Image();
        im.onload = ()=> { img = im; };
        im.src = e.target.result;
      };
      reader.readAsDataURL(file);
    },
    setImageFromURL(url){
      const im = new Image();
      im.crossOrigin = 'anonymous';
      im.onload = ()=> { img = im; };
      im.onerror = ()=> { alert('Unable to load image, please check URL or CORS policy'); };
      im.src = url;
    },
    toggleFit(){
      fitMode = (fitMode === 'cover') ? 'contain' : 'cover';
    }
  };
}

// Template: Liquid Waves (simple sine waves)
function liquidWavesMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now() - t0)/1000;
    ctx.clearRect(0,0,W,H);
    // dark base
    ctx.fillStyle = '#040405'; ctx.fillRect(0,0,W,H);
    // waves
    for(let k=0;k<4;k++){
      ctx.beginPath();
      const amp = 12 + k*8;
      ctx.moveTo(0, H/2);
      for(let x=0;x<=W;x+=6){
        const y = H/2 + Math.sin((x*0.02) + tt*(0.6 + k*0.12) + k)*amp*Math.cos(k*0.2);
        ctx.lineTo(x,y + k*8);
      }
      ctx.strokeStyle = `rgba(0,240,255,${0.04 + k*0.02})`;
      ctx.lineWidth = 1.8;
      ctx.stroke();
    }
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.font = '12px Rajdhani';
    ctx.fillText('Liquid Waves', 24, H-24);
  });
  return { unmount(){ runner.stop(); } };
}

// Template: Matrix Rain
function matrixRainMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const cols = Math.floor(W/14);
  const drops = new Array(cols).fill(0).map(()=>Math.floor(Math.random()*H));
  const letters = '01'; // binary rain
  let running = true;
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(0,0,W,H);
    ctx.font = '14px monospace';
    for(let i=0;i<cols;i++){
      const x = i*14;
      ctx.fillStyle = 'rgba(0,255,140,0.08)';
      const text = letters[Math.floor(Math.random()*letters.length)];
      ctx.fillText(text, x, drops[i]);
      drops[i] += 14 + Math.random()*10;
      if(drops[i] > H + 20) drops[i] = -20*Math.random();
    }
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.font = '12px Rajdhani';
    ctx.fillText('Matrix Rain', 24, H-24);
  });
  return { unmount(){ running=false; runner.stop(); } };
}

// Template: HexGrid Pulse
function hexGridPulseMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const size = 36;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#070708'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    const cols = Math.ceil(W/size)+4;
    for(let x=-cols;x<cols;x++){
      for(let y=-cols;y<cols;y++){
        const px = x*size*0.86 + (y%2? size*0.43:0);
        const py = y*(size*0.75);
        const d = Math.hypot(px,py);
        const pulse = 0.6 + 0.4*Math.sin(d*0.06 - tt*2);
        const a = 0.03 + 0.06*(1-pulse);
        ctx.beginPath();
        // hexagon
        ctx.moveTo(px + size*0.5, py);
        for(let k=1;k<6;k++){
          const ang = (Math.PI*2/6)*k;
          ctx.lineTo(px + Math.cos(ang)*size*0.5, py + Math.sin(ang)*size*0.5);
        }
        ctx.closePath();
        ctx.fillStyle = `rgba(0,240,255,${a})`;
        ctx.fill();
      }
    }
    ctx.restore();
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.font = '12px Rajdhani';
    ctx.fillText('Hex Grid Pulse', 24, H-24);
  });
  return { unmount(){ runner.stop(); } };
}

// Template: Clock Sync
function clockSyncMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let running = true;
  const runner = makeRunner((t)=>{
    ctx.fillStyle = '#010101'; ctx.fillRect(0,0,W,H);
    const now = new Date();
    const s = now.getSeconds(), m = now.getMinutes(), hr = now.getHours()%12;
    // dial
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.beginPath(); ctx.arc(0,0,220,0,Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.02)'; ctx.fill();
    // ticks
    for(let i=0;i<60;i++){
      const ang = i*(Math.PI*2/60) - Math.PI/2;
      const r1 = 200, r2 = (i%5===0 ? 190 : 194);
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.lineWidth = (i%5===0)?2:1;
      ctx.beginPath();
      ctx.moveTo(Math.cos(ang)*r1, Math.sin(ang)*r1);
      ctx.lineTo(Math.cos(ang)*r2, Math.sin(ang)*r2);
      ctx.stroke();
    }
    // hands
    const angS = s*(Math.PI*2/60) - Math.PI/2;
    const angM = (m + s/60)*(Math.PI*2/60) - Math.PI/2;
    const angH = (hr + m/60)*(Math.PI*2/12) - Math.PI/2;
    // hour
    ctx.strokeStyle = 'rgba(176,67,255,0.9)'; ctx.lineWidth=6;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(angH)*110, Math.sin(angH)*110); ctx.stroke();
    // minute
    ctx.strokeStyle = 'rgba(0,240,255,0.96)'; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(angM)*150, Math.sin(angM)*150); ctx.stroke();
    // second
    ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth=1.6;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(angS)*180, Math.sin(angS)*180); ctx.stroke();
    ctx.restore();
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.font = '12px Rajdhani';
    ctx.fillText('Clock Sync — UTC '+now.toUTCString().split(' ')[4], 24, H-24);
  });
  return { unmount(){ running=false; runner.stop(); } };
}

// Template: Code Verse
function codeVerseMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const snippets = [
    'function syncBlock(){ /* destiny */ }',
    'const tx = broadcast(wallet.sign(tx))',
    'for await (const block of chain) { /* listen */ }',
    'if (nonce++ > 100) { revive(); }',
    'let entropy = crypto.getRandomValues(new Uint8Array(32))'
  ];
  let lines = new Array(24).fill('');
  const runner = makeRunner((t)=>{
    ctx.fillStyle = '#040405'; ctx.fillRect(0,0,W,H);
    if(Math.random() < 0.35){
      lines.pop();
      lines.unshift(snippets[Math.floor(Math.random()*snippets.length)]);
    }
    ctx.font = '14px "Courier New", monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    for(let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], 22, 60 + i*20);
    }
    ctx.fillStyle = 'rgba(255,255,255,0.04)';
    ctx.fillText('Code Verse', 24, H-24);
  });
  return { unmount(){ runner.stop(); } };
}

// Template: AI Bloom (simple fractal-ish)
function aiBloomMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#050507'; ctx.fillRect(0,0,W,H);
    // draw radial expanding petals
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let k=0;k<18;k++){
      const ang = (k/18)*Math.PI*2 + tt*0.06;
      const r = 80 + Math.sin(tt*0.9 + k)*80;
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(Math.cos(ang)*r/2, Math.sin(ang)*r/2, r*0.6, ang-0.8, ang+0.8);
      ctx.fillStyle = `rgba(176,67,255,${0.03 + k*0.002})`;
      ctx.fill();
    }
    ctx.restore();
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillText('AI Bloom', 24, H-24);
  });
  return { unmount(){ runner.stop(); } };
}

// Template: Signature Loop (flowing lines)
function signatureLoopMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const lines = [];
  for(let i=0;i<6;i++){
    const pts = [];
    for(let j=0;j<30;j++){
      pts.push({x: Math.random()*W, y: Math.random()*H});
    }
    lines.push(pts);
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#020202'; ctx.fillRect(0,0,W,H);
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0;i<lines.length;i++){
      const pts = lines[i];
      ctx.beginPath();
      for(let j=0;j<pts.length;j++){
        const p = pts[j];
        const nx = p.x + Math.sin(tt*0.6 + i + j)*12;
        const ny = p.y + Math.cos(tt*0.4 + i - j)*12;
        if(j===0) ctx.moveTo(nx, ny); else ctx.lineTo(nx, ny);
      }
      ctx.strokeStyle = `rgba(0,240,255,${0.03 + i*0.03})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillText('Signature Loop', 24, H-24);
  });
  return { unmount(){ runner.stop(); } };
}

// Collect templates mapping
const templates = {
  cyberMinimal: { mount: cyberMinimalMount },
  cryptoOrb: { mount: cryptoOrbMount },
  retroTerminal: { mount: retroTerminalMount },
  zenSpace: { mount: zenSpaceMount },
  picFrame: { mount: picFrameMount },
  liquidWaves: { mount: liquidWavesMount },
  matrixRain: { mount: matrixRainMount },
  hexGridPulse: { mount: hexGridPulseMount },
  clockSync: { mount: clockSyncMount },
  codeVerse: { mount: codeVerseMount },
  aiBloom: { mount: aiBloomMount },
  signatureLoop: { mount: signatureLoopMount }
};

/* Pic Frame controls: create DOM elements for uploading/selecting image */
function createPicControls(instance){
  const box = create('div', {class:'pic-controls'});
  // file input
  const fileBtn = create('input', {type:'file', class:'input'});
  fileBtn.accept = 'image/*';
  fileBtn.addEventListener('change', (e)=>{
    const f = e.target.files && e.target.files[0];
    if(f) instance.setImageFromFile(f);
  });
  box.appendChild(fileBtn);

  const urlInput = create('input', {type:'text', placeholder:'Enter image URL', class:'input'});
  urlInput.style.width = '220px';
  urlInput.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter'){
      const url = urlInput.value.trim();
      if(url) instance.setImageFromURL(url);
    }
  });
  box.appendChild(urlInput);

  const fitBtn = create('button', {class:'btn', html:'Toggle Fit'});
  fitBtn.addEventListener('click', ()=>{
    if(typeof instance.toggleFit === 'function') instance.toggleFit();
  });
  box.appendChild(fitBtn);

  const clearBtn = create('button', {class:'btn', html:'Clear'});
  clearBtn.addEventListener('click', ()=> {
    // easiest way: reload template -> unmount and mount fresh
    if(activeInstance && activeInstance.unmount) activeInstance.unmount();
    const canvas = create('canvas', {width:720, height:720});
    canvas.style.width='720px'; canvas.style.height='720px';
    canvasWrap.innerHTML = '';
    canvasWrap.appendChild(canvas);
    const id = TEMPLATE_IDS[currentIndex];
    activeInstance = templates[id].mount(canvas);
    picControlsContainer.innerHTML = '';
    picControlsContainer.appendChild(createPicControls(activeInstance));
  });
  box.appendChild(clearBtn);

  return box;
}

/* Clean up when leaving page */
window.addEventListener('beforeunload', ()=>{
  stopAutoplay();
  if(activeInstance && typeof activeInstance.unmount === 'function') activeInstance.unmount();
});

// Keyboard controls: Esc to close, ArrowRight next, ArrowLeft prev
window.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape') closeOverlay();
  if(e.key === 'ArrowRight') nextTemplate();
  if(e.key === 'ArrowLeft') {
    const idx = (currentIndex - 1 + TEMPLATE_IDS.length) % TEMPLATE_IDS.length;
    openTemplate(idx);
  }
});

// Initialize autoplay button initial state
autoplayToggle.classList.toggle('toggled', autoplay);

// End of script
</script>
</body>
</html>
