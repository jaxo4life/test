<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LumaGEN</title>
<link rel="icon" href="https://purple-payable-felidae-371.mypinata.cloud/ipfs/bafybeigds36kzucrp4uzxvyf2q2oqmda2od2i62h3ld4pcz62tqq5ox3wy" type="image/png" />

<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#000000;
    --muted:#0f1112;
    --accent1:#00f0ff;
    --accent2:#b043ff;
    --glass: rgba(255,255,255,0.04);
    --text: rgba(255,255,255,0.9);
    --small: 12px;
  }
  html,body{
    height:100%;
    margin:0;
    background:var(--bg);
    color:var(--text);
    font-family: "Rajdhani", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  .stage {
    width:100vw;
    height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    box-sizing:border-box;
  }

  .frame {
    width:100%;
    height:100%;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    overflow:hidden;
    position:relative;
    border:none;
  }

  .grain {
    position:absolute;
    inset:0;
    pointer-events:none;
    background-image: radial-gradient(rgba(255,255,255,0.015) 1px, transparent 1px);
    background-size: 3px 3px;
    opacity:0.6;
    mix-blend-mode: overlay;
  }

  header {
    position:absolute;
    top:18px;
    left:20px;
    right:20px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    z-index:50;
    pointer-events:none;
  }

  .title {
    display:flex;
		flex-direction: column;
    align-items:center;
    gap:4px;
    pointer-events:auto;
  }

  .logo {
    font-family: "Orbitron", monospace;
    font-weight:700;
    color:var(--accent1);
    font-size:18px;
    letter-spacing:1px;
    opacity:0.95;
    text-shadow: 0 2px 18px rgba(0,240,255,0.06);
    background: linear-gradient(90deg, rgba(0,240,255,0.12), rgba(176,67,255,0.04));
    padding:6px 10px;
    border-radius:8px;
  }

  .title h1{
    margin:0;
    font-size:18px;
    color:rgba(255,255,255,0.92);
    letter-spacing:1px;
  }
  .title p{ margin:0; font-size:12px; color:rgba(255,255,255,0.35);}

  .controls {
    display:flex;
    gap:10px;
    align-items:center;
    pointer-events:auto;
  }

  .btn {
    background:var(--glass);
    border:1px solid rgba(255,255,255,0.03);
    padding:8px 10px;
    border-radius:8px;
    cursor:pointer;
    color:var(--text);
    font-size:13px;
    display:inline-flex;
    gap:8px;
    align-items:center;
    transition:transform .18s ease, box-shadow .18s ease;
    user-select:none;
  }
  .btn:hover{ transform:translateY(-4px); box-shadow: 0 8px 28px rgba(0,0,0,0.5); }
  .btn.toggled { background: linear-gradient(90deg, rgba(0,240,255,0.06), rgba(176,67,255,0.02)); }

  .gallery {
    padding:88px 36px 36px 36px;
    box-sizing:border-box;
    height:100%;
    display:grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    grid-auto-rows: minmax(180px, 1fr);
    gap:18px;
    z-index:10;
    overflow-y:auto;
  }

  .card {
    border-radius:8px;
    overflow:hidden;
    background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
    border:1px solid rgba(255,255,255,0.02);
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    cursor:pointer;
    transition:transform .25s ease, box-shadow .25s ease;
  }
  .card:hover { transform:translateY(-8px); box-shadow: 0 14px 40px rgba(0,0,0,0.7); }
  .card canvas { width:100%; height:100%; display:block; }

  .card .label {
    position:absolute;
    left:12px;
    bottom:8px;
    font-size:12px;
    color:rgba(255,255,255,0.9);
    background: linear-gradient(180deg, rgba(0,0,0,0.25), rgba(255,255,255,0.02));
    padding:6px 8px;
    border-radius:6px;
    backdrop-filter: blur(4px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.6);
  }

  .overlay {
    position:absolute;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    z-index:60;
    background: linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.65));
    backdrop-filter: blur(6px);
  }
  .overlay.active { display:flex; animation:overlayIn .35s ease both; }
  @keyframes overlayIn { from{opacity:0; transform:scale(.995);} to{opacity:1; transform:none;} }

  .canvas-wrap{
    width:100%;
    height:100%;
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
    background:transparent;
    cursor:pointer;
  }

  .overlay-ui {
    position:absolute;
    inset:18px;
    display:flex;
    justify-content:space-between;
    align-items:flex-start;
    pointer-events:none;
    transition: opacity 0.3s ease, transform 0.3s ease;
  }
  
  .overlay-ui.hidden {
    opacity:0;
    transform:translateY(-10px);
    pointer-events:none;
  }
  
  .overlay-left, .overlay-right {
    pointer-events:auto;
    display:flex;
    gap:10px;
    align-items:center;
  }
  .back-btn {
    background:transparent;
    border:1px solid rgba(255,255,255,0.06);
    color:var(--text);
    padding:8px 10px;
    border-radius:8px;
    cursor:pointer;
    backdrop-filter: blur(6px);
  }
  .small {
    font-size:12px;
    color:rgba(255,255,255,0.7);
    opacity:0.9;
  }

  .bubble {
    position:absolute;
    right:18px;
    bottom:18px;
    pointer-events:auto;
    display:flex;
    gap:10px;
    align-items:center;
  }
  .dot {
    width:10px;height:10px;border-radius:50%;
    background:var(--accent1);
    box-shadow:0 6px 20px rgba(0,240,255,0.08);
    opacity:0.9;
  }

  .micro {
    position:absolute;
    left:18px;
    bottom:18px;
    font-size:11px;
    color:rgba(255,255,255,0.28);
    pointer-events:auto;
  }

  .pic-controls {
    display:flex;
    gap:8px;
    align-items:center;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:8px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.03);
  }
  .input {
    background:transparent;border:1px dashed rgba(255,255,255,0.06);padding:6px;border-radius:6px;color:var(--text);font-size:12px;
  }

  @media (max-width:800px){
    .gallery{ grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); padding:80px 20px 20px 20px; }
  }

</style>
</head>
<body>
  <div class="stage">
    <div class="frame" role="application" aria-label="dGEN Town visual frame">
      <div class="grain" aria-hidden="true"></div>

      <header>
        <div class="title">
          <div class="logo">LumaGEN</div>
          <div>
            <p style="margin-top:4px;">Where dGEN1s come to shine</p>
          </div>
        </div>

        <div class="controls">
          <button id="autoplayToggle" class="btn" title="Toggle autoplay">Autoplay</button>
					<select id="autoplayInterval">
						<option value="5000">5s</option>
						<option value="10000">10s</option>
						<option value="20000" selected>20s</option>
						<option value="60000">60s</option>
					</select>
          <button id="randomBtn" class="btn" title="Random template">Random</button>
          <button id="helpBtn" class="btn" title="Help/Info">Info</button>
        </div>
      </header>

      <main class="gallery" id="gallery" aria-hidden="false"></main>

      <div class="micro">LumaGEN · © 2025</div>

      <div class="overlay" id="overlay" aria-hidden="true">
        <div class="canvas-wrap" id="canvasWrap"></div>

        <div class="overlay-ui" id="overlayUI" aria-hidden="false">
          <div class="overlay-left">
            <button id="backBtn" class="back-btn" title="Back to gallery">← Back</button>
            <div class="small" id="currentLabel">—</div>
          </div>
          <div class="overlay-right" style="align-items:center">
            <div id="picControlsContainer"></div>
            <div class="bubble">
              <div class="dot" id="autoplayDot" style="display:none"></div>
              <div class="small">Auto</div>
              <button id="nextBtn" class="btn" title="Next template">Next</button>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

<script>
const $ = sel => document.querySelector(sel);
const create = (tag, attrs={}, parent=null) => {
  const el = document.createElement(tag);
  Object.entries(attrs).forEach(([k,v])=>{
    if(k === 'class') el.className = v;
    else if(k === 'html') el.innerHTML = v;
    else el.setAttribute(k, v);
  });
  if(parent) parent.appendChild(el);
  return el;
};

const TEMPLATE_IDS = [
  'cyberMinimal','cryptoOrb','retroTerminal','zenSpace',
  'liquidWaves','matrixRain','hexGridPulse',
  'clockSync','codeVerse','aiBloom','signatureLoop',
  'neonCity','glitchArt','vaporwave','hologram',
  'pixelStorm','scanlines','dataStream','particleNebula',
  'geometricDance','synthwave','digitalRain','cosmicVoid',
  'fractalTree','waveform','starfield','cyberpunkGrid',
  'dnaHelix','liquidMetal','quantumEntangle','neuralNet',
  'crystalGrowth','radarScan','energyShield','spectrumAnalyzer',
  'particleExplosion','rippleEffect','nebulaSwirl','binaryClock',
  'magneticField','fiberNetwork','quantumWave','cyberEye',
  'pulseWave','mandelbrotSet','kaleidoscope','laserShow',
  'blackHole','circuitBoard','audioVisualizer','timeTunnel','plasmaStorm',
  'neonTunnel','gravityWell','prismRefract','quantumFoam',
  'cyberRain','spiralMatrix','energyVortex','digitalHorizon',
  'particleSwarm','neonPulse','fractalZoom','laserGrid',
  'quantumTunnel','cyberWaves','plasmaRings','digitalWaterfall',
  'neonSpiral','energyBurst','particleTrails','cyberBloom',
  'quantumRipples','laserBeams','digitalSmoke','neonRings',
  'energyWeb','particleDance','cyberPulse','quantumStrings',
  'laserSpiral','digitalAurora','neonWaves','energySphere',
  'particleFountain','cyberVortex','quantumGrid','laserPulse',
  'digitalNebula','neonMatrix','energyFlow','particleStorm',
  'cyberSphere','quantumBurst','laserWeb','digitalVortex',
  'neonFlow','energyRings','particleWeb','cyberAurora',
  'fractalFern','fractalSnowflake','fractalDragon','fractalSpiral',
  'fractalTriangle','fractalBranch','fractalLightning','fractalVine',
  'fractalCrystal','fractalWeb'
];

const TEMPLATE_META = {
  cyberMinimal: {name:'Cyber Minimal'},
  cryptoOrb: {name:'Crypto Orb'},
  retroTerminal: {name:'Retro Terminal'},
  zenSpace: {name:'Zen Space'},
  liquidWaves: {name:'Liquid Waves'},
  matrixRain: {name:'Matrix Rain'},
  hexGridPulse: {name:'Hex Grid Pulse'},
  clockSync: {name:'Clock Sync'},
  codeVerse: {name:'Code Verse'},
  aiBloom: {name:'AI Bloom'},
  signatureLoop: {name:'Signature Loop'},
  neonCity: {name:'Neon City'},
  glitchArt: {name:'Glitch Art'},
  vaporwave: {name:'Vaporwave'},
  hologram: {name:'Hologram'},
  pixelStorm: {name:'Pixel Storm'},
  scanlines: {name:'Scanlines'},
  dataStream: {name:'Data Stream'},
  particleNebula: {name:'Particle Nebula'},
  geometricDance: {name:'Geometric Dance'},
  synthwave: {name:'Synthwave'},
  digitalRain: {name:'Digital Rain'},
  cosmicVoid: {name:'Cosmic Void'},
  fractalTree: {name:'Fractal Tree'},
  waveform: {name:'Waveform'},
  starfield: {name:'Starfield'},
  cyberpunkGrid: {name:'Cyberpunk Grid'},
  dnaHelix: {name:'DNA Helix'},
  liquidMetal: {name:'Liquid Metal'},
  quantumEntangle: {name:'Quantum Entangle'},
  neuralNet: {name:'Neural Network'},
  crystalGrowth: {name:'Crystal Growth'},
  radarScan: {name:'Radar Scan'},
  energyShield: {name:'Energy Shield'},
  spectrumAnalyzer: {name:'Spectrum Analyzer'},
  particleExplosion: {name:'Particle Explosion'},
  rippleEffect: {name:'Ripple Effect'},
  nebulaSwirl: {name:'Nebula Swirl'},
  binaryClock: {name:'Binary Clock'},
  magneticField: {name:'Magnetic Field'},
  fiberNetwork: {name:'Fiber Network'},
  quantumWave: {name:'Quantum Wave'},
  cyberEye: {name:'Cyber Eye'},
  pulseWave: {name:'Pulse Wave'},
  mandelbrotSet: {name:'Mandelbrot Set'},
  kaleidoscope: {name:'Kaleidoscope'},
  laserShow: {name:'Laser Show'},
  blackHole: {name:'Black Hole'},
  circuitBoard: {name:'Circuit Board'},
  audioVisualizer: {name:'Audio Visualizer'},
  timeTunnel: {name:'Time Tunnel'},
  plasmaStorm: {name:'Plasma Storm'},
  neonTunnel: {name:'Neon Tunnel'},
  gravityWell: {name:'Gravity Well'},
  prismRefract: {name:'Prism Refraction'},
  quantumFoam: {name:'Quantum Foam'},
  cyberRain: {name:'Cyber Rain'},
  spiralMatrix: {name:'Spiral Matrix'},
  energyVortex: {name:'Energy Vortex'},
  digitalHorizon: {name:'Digital Horizon'},
  particleSwarm: {name:'Particle Swarm'},
  neonPulse: {name:'Neon Pulse'},
  fractalZoom: {name:'Fractal Zoom'},
  laserGrid: {name:'Laser Grid'},
  quantumTunnel: {name:'Quantum Tunnel'},
  cyberWaves: {name:'Cyber Waves'},
  plasmaRings: {name:'Plasma Rings'},
  digitalWaterfall: {name:'Digital Waterfall'},
  neonSpiral: {name:'Neon Spiral'},
  energyBurst: {name:'Energy Burst'},
  particleTrails: {name:'Particle Trails'},
  cyberBloom: {name:'Cyber Bloom'},
  quantumRipples: {name:'Quantum Ripples'},
  laserBeams: {name:'Laser Beams'},
  digitalSmoke: {name:'Digital Smoke'},
  neonRings: {name:'Neon Rings'},
  energyWeb: {name:'Energy Web'},
  particleDance: {name:'Particle Dance'},
  cyberPulse: {name:'Cyber Pulse'},
  quantumStrings: {name:'Quantum Strings'},
  laserSpiral: {name:'Laser Spiral'},
  digitalAurora: {name:'Digital Aurora'},
  neonWaves: {name:'Neon Waves'},
  energySphere: {name:'Energy Sphere'},
  particleFountain: {name:'Particle Fountain'},
  cyberVortex: {name:'Cyber Vortex'},
  quantumGrid: {name:'Quantum Grid'},
  laserPulse: {name:'Laser Pulse'},
  digitalNebula: {name:'Digital Nebula'},
  neonMatrix: {name:'Neon Matrix'},
  energyFlow: {name:'Energy Flow'},
  particleStorm: {name:'Particle Storm'},
  cyberSphere: {name:'Cyber Sphere'},
  quantumBurst: {name:'Quantum Burst'},
  laserWeb: {name:'Laser Web'},
  digitalVortex: {name:'Digital Vortex'},
  neonFlow: {name:'Neon Flow'},
  energyRings: {name:'Energy Rings'},
  particleWeb: {name:'Particle Web'},
  cyberAurora: {name:'Cyber Aurora'},
  fractalFern: {name:'Fractal Fern'},
  fractalSnowflake: {name:'Fractal Snowflake'},
  fractalDragon: {name:'Fractal Dragon'},
  fractalSpiral: {name:'Fractal Spiral'},
  fractalTriangle: {name:'Fractal Triangle'},
  fractalBranch: {name:'Fractal Branch'},
  fractalLightning: {name:'Fractal Lightning'},
  fractalVine: {name:'Fractal Vine'},
  fractalCrystal: {name:'Fractal Crystal'},
  fractalWeb: {name:'Fractal Web'}
};

let autoplay = false;
let autoplayTimer = null;
let currentIndex = -1;
let activeInstance = null;
let uiVisible = true;

const gallery = $('#gallery');
TEMPLATE_IDS.forEach((id, i)=>{
  const card = create('div', {class:'card', id:'card-'+id}, gallery);
  const thumb = create('canvas', {width:300, height:300}, card);
  const label = create('div', {class:'label', html: TEMPLATE_META[id].name}, card);

  card.addEventListener('click', ()=> openTemplate(i));
  
  setTimeout(()=> {
    const ctx = thumb.getContext('2d');
    const w = thumb.width, h = thumb.height;
    
    ctx.fillStyle = '#0a0a0c';
    ctx.fillRect(0,0,w,h);
    
    ctx.save();
    ctx.translate(w/2, h/2);
    
    switch(id) {
      case 'cyberMinimal':
        ctx.strokeStyle = 'rgba(0,240,255,0.4)';
        ctx.lineWidth = 3;
        ctx.strokeRect(-60, -60, 120, 120);
        ctx.rotate(Math.PI/4);
        ctx.strokeStyle = 'rgba(176,67,255,0.3)';
        ctx.strokeRect(-50, -50, 100, 100);
        break;
        
      case 'cryptoOrb':
        const grd = ctx.createRadialGradient(0,0,10,0,0,80);
        grd.addColorStop(0, 'rgba(0,240,255,0.6)');
        grd.addColorStop(0.5, 'rgba(176,67,255,0.3)');
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd;
        ctx.fillRect(-100,-100,200,200);
        break;
        
      case 'retroTerminal':
        ctx.font = '14px monospace';
        ctx.fillStyle = 'rgba(0,255,140,0.6)';
        for(let j=0; j<8; j++) {
          ctx.fillText('> 0x' + Math.random().toString(16).substr(2,8), -120, -60 + j*20);
        }
        break;
        
      case 'zenSpace':
        ctx.beginPath();
        ctx.arc(0,0,80,0,Math.PI*2);
        ctx.fillStyle = 'rgba(176,67,255,0.25)';
        ctx.fill();
        break;
        
      case 'liquidWaves':
        ctx.strokeStyle = 'rgba(0,240,255,0.4)';
        ctx.lineWidth = 2;
        for(let j=0; j<5; j++) {
          ctx.beginPath();
          for(let x=-120; x<=120; x+=10) {
            const y = Math.sin(x*0.05 + j*0.5)*20 + j*10 - 40;
            if(x===-120) ctx.moveTo(x,y);
            else ctx.lineTo(x,y);
          }
          ctx.stroke();
        }
        break;
        
      case 'matrixRain':
        ctx.font = '16px monospace';
        ctx.fillStyle = 'rgba(0,255,140,0.5)';
        for(let j=0; j<15; j++) {
          const x = (j-7)*20;
          const y = (j%3)*30 - 40;
          ctx.fillText(Math.random()>0.5?'1':'0', x, y);
        }
        break;
        
      case 'hexGridPulse':
        ctx.strokeStyle = 'rgba(0,240,255,0.3)';
        ctx.lineWidth = 2;
        for(let hx=-2; hx<=2; hx++) {
          for(let hy=-2; hy<=2; hy++) {
            const px = hx*30 + (hy%2?15:0);
            const py = hy*26;
            ctx.beginPath();
            for(let k=0; k<6; k++) {
              const ang = (Math.PI*2/6)*k;
              const x = px + Math.cos(ang)*15;
              const y = py + Math.sin(ang)*15;
              if(k===0) ctx.moveTo(x,y);
              else ctx.lineTo(x,y);
            }
            ctx.closePath();
            ctx.stroke();
          }
        }
        break;
        
      case 'clockSync':
        ctx.beginPath();
        ctx.arc(0,0,70,0,Math.PI*2);
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.strokeStyle = 'rgba(0,240,255,0.6)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(0,-50);
        ctx.stroke();
        break;
        
      case 'codeVerse':
        ctx.font = '12px monospace';
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        const snippets = ['function()', 'const x =', 'if (true)', '{ code }', 'return;'];
        snippets.forEach((s,j)=>{
          ctx.fillText(s, -60, -40 + j*20);
        });
        break;
        
      case 'aiBloom':
        for(let j=0; j<12; j++) {
          const ang = (j/12)*Math.PI*2;
          ctx.beginPath();
          ctx.moveTo(0,0);
          ctx.arc(Math.cos(ang)*40, Math.sin(ang)*40, 30, ang-0.5, ang+0.5);
          ctx.fillStyle = `rgba(176,67,255,${0.15 + j*0.01})`;
          ctx.fill();
        }
        break;
        
      case 'signatureLoop':
        ctx.strokeStyle = 'rgba(0,240,255,0.3)';
        ctx.lineWidth = 2;
        for(let j=0; j<4; j++) {
          ctx.beginPath();
          for(let t=0; t<=1; t+=0.05) {
            const x = (t-0.5)*200;
            const y = Math.sin(t*Math.PI*3 + j)*30 + j*15 - 30;
            if(t===0) ctx.moveTo(x,y);
            else ctx.lineTo(x,y);
          }
          ctx.stroke();
        }
        break;
        
      case 'neonCity':
        ctx.strokeStyle = 'rgba(255,0,255,0.5)';
        ctx.lineWidth = 2;
        for(let j=0; j<8; j++) {
          const h = 40 + Math.random()*60;
          ctx.strokeRect(-100 + j*25, 50-h, 20, h);
        }
        ctx.fillStyle = 'rgba(0,240,255,0.3)';
        ctx.fillRect(-120, 50, 240, 2);
        break;
        
      case 'glitchArt':
        for(let j=0; j<10; j++) {
          ctx.fillStyle = `rgba(${Math.random()*255},${Math.random()*255},255,0.3)`;
          ctx.fillRect(-100 + Math.random()*200, -100 + Math.random()*200, 40, 8);
        }
        break;
        
      case 'vaporwave':
        const grd2 = ctx.createLinearGradient(0,-100,0,100);
        grd2.addColorStop(0, 'rgba(255,0,255,0.3)');
        grd2.addColorStop(1, 'rgba(0,240,255,0.3)');
        ctx.fillStyle = grd2;
        ctx.fillRect(-100,-100,200,200);
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        for(let j=-5; j<=5; j++) {
          ctx.beginPath();
          ctx.moveTo(-100, j*20);
          ctx.lineTo(100, j*20);
          ctx.stroke();
        }
        break;
        
      case 'hologram':
        for(let j=0; j<5; j++) {
          ctx.beginPath();
          ctx.arc(0, 0, 20 + j*15, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(0,240,255,${0.4 - j*0.06})`;
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        break;
        
      case 'pixelStorm':
        for(let j=0; j<50; j++) {
          ctx.fillStyle = `rgba(${Math.random()*255},${Math.random()*255},255,0.5)`;
          ctx.fillRect(-100 + Math.random()*200, -100 + Math.random()*200, 6, 6);
        }
        break;
        
      case 'scanlines':
        ctx.strokeStyle = 'rgba(0,255,140,0.3)';
        ctx.lineWidth = 1;
        for(let j=-100; j<100; j+=4) {
          ctx.beginPath();
          ctx.moveTo(-100, j);
          ctx.lineTo(100, j);
          ctx.stroke();
        }
        ctx.fillStyle = 'rgba(0,240,255,0.2)';
        ctx.fillRect(-60, -60, 120, 120);
        break;
        
      case 'dataStream':
        ctx.font = '10px monospace';
        ctx.fillStyle = 'rgba(0,240,255,0.4)';
        for(let j=0; j<20; j++) {
          ctx.fillText(Math.random().toString(2).substr(2,8), -100 + (j%5)*50, -80 + Math.floor(j/5)*40);
        }
        break;
        
      case 'particleNebula':
        for(let j=0; j<100; j++) {
          const x = (Math.random()-0.5)*200;
          const y = (Math.random()-0.5)*200;
          const size = Math.random()*3;
          ctx.fillStyle = `rgba(176,67,255,${Math.random()*0.5})`;
          ctx.fillRect(x, y, size, size);
        }
        break;
        
      case 'geometricDance':
        for(let j=0; j<6; j++) {
          ctx.save();
          ctx.rotate((j/6)*Math.PI*2);
          ctx.strokeStyle = `rgba(0,240,255,${0.3 + j*0.05})`;
          ctx.lineWidth = 2;
          ctx.strokeRect(30, -10, 40, 20);
          ctx.restore();
        }
        break;
        
      case 'synthwave':
        const grd3 = ctx.createLinearGradient(0,-100,0,100);
        grd3.addColorStop(0, 'rgba(255,0,128,0.4)');
        grd3.addColorStop(0.5, 'rgba(128,0,255,0.3)');
        grd3.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd3;
        ctx.fillRect(-100,-100,200,200);
        ctx.strokeStyle = 'rgba(255,0,255,0.3)';
        for(let j=-5; j<=5; j++) {
          ctx.beginPath();
          ctx.moveTo(j*20, -100);
          ctx.lineTo(j*20, 100);
          ctx.stroke();
        }
        break;
        
      case 'digitalRain':
        ctx.font = '14px monospace';
        for(let j=0; j<12; j++) {
          ctx.fillStyle = `rgba(0,255,140,${0.2 + Math.random()*0.4})`;
          ctx.fillText(String.fromCharCode(0x30A0 + Math.random()*96), -100 + j*20, -80 + (j%4)*50);
        }
        break;
        
      case 'cosmicVoid':
        const grd4 = ctx.createRadialGradient(0,0,0,0,0,120);
        grd4.addColorStop(0, 'rgba(128,0,255,0.4)');
        grd4.addColorStop(0.7, 'rgba(0,0,128,0.2)');
        grd4.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd4;
        ctx.fillRect(-120,-120,240,240);
        for(let j=0; j<30; j++) {
          ctx.fillStyle = 'rgba(255,255,255,0.6)';
          ctx.fillRect((Math.random()-0.5)*200, (Math.random()-0.5)*200, 2, 2);
        }
        break;
        
      case 'fractalTree':
        ctx.strokeStyle = 'rgba(0,240,255,0.4)';
        ctx.lineWidth = 2;
        function drawBranch(x, y, len, angle, depth) {
          if(depth === 0) return;
          const x2 = x + Math.cos(angle) * len;
          const y2 = y + Math.sin(angle) * len;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          drawBranch(x2, y2, len*0.7, angle-0.5, depth-1);
          drawBranch(x2, y2, len*0.7, angle+0.5, depth-1);
        }
        drawBranch(0, 80, 40, -Math.PI/2, 4);
        break;
        
      case 'waveform':
        ctx.strokeStyle = 'rgba(0,240,255,0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let x=-120; x<=120; x+=4) {
          const y = Math.sin(x*0.1)*30 + Math.cos(x*0.05)*20;
          if(x===-120) ctx.moveTo(x,y);
          else ctx.lineTo(x,y);
        }
        ctx.stroke();
        break;
        
      case 'starfield':
        for(let j=0; j<80; j++) {
          const x = (Math.random()-0.5)*200;
          const y = (Math.random()-0.5)*200;
          const size = Math.random()*2 + 0.5;
          ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.8 + 0.2})`;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'cyberpunkGrid':
        ctx.strokeStyle = 'rgba(255,0,255,0.3)';
        ctx.lineWidth = 1;
        for(let j=-5; j<=5; j++) {
          ctx.beginPath();
          ctx.moveTo(-100, j*20);
          ctx.lineTo(100, j*20);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(j*20, -100);
          ctx.lineTo(j*20, 100);
          ctx.stroke();
        }
        ctx.fillStyle = 'rgba(0,240,255,0.2)';
        ctx.fillRect(-40, -40, 80, 80);
        break;
        
      case 'dnaHelix':
        ctx.strokeStyle = 'rgba(0,240,255,0.5)';
        ctx.lineWidth = 2;
        for(let j=0; j<10; j++) {
          const y = -80 + j*16;
          const x1 = Math.sin(j*0.5)*40;
          const x2 = Math.sin(j*0.5 + Math.PI)*40;
          ctx.beginPath();
          ctx.arc(x1, y, 5, 0, Math.PI*2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x2, y, 5, 0, Math.PI*2);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(x1, y);
          ctx.lineTo(x2, y);
          ctx.stroke();
        }
        break;
        
      case 'liquidMetal':
        const grd5 = ctx.createRadialGradient(-20,-20,0,0,0,100);
        grd5.addColorStop(0, 'rgba(200,200,255,0.6)');
        grd5.addColorStop(0.5, 'rgba(100,100,200,0.4)');
        grd5.addColorStop(1, 'rgba(50,50,100,0.2)');
        ctx.fillStyle = grd5;
        ctx.beginPath();
        for(let j=0; j<8; j++) {
          const ang = (j/8)*Math.PI*2;
          const r = 60 + Math.sin(j*2)*20;
          if(j===0) ctx.moveTo(Math.cos(ang)*r, Math.sin(ang)*r);
          else ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r);
        }
        ctx.closePath();
        ctx.fill();
        break;
        
      case 'quantumEntangle':
        for(let j=0; j<6; j++) {
          const x1 = (Math.random()-0.5)*120;
          const y1 = (Math.random()-0.5)*120;
          const x2 = (Math.random()-0.5)*120;
          const y2 = (Math.random()-0.5)*120;
          ctx.strokeStyle = `rgba(176,67,255,${0.3 + Math.random()*0.3})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          ctx.fillStyle = 'rgba(0,240,255,0.6)';
          ctx.beginPath();
          ctx.arc(x1, y1, 4, 0, Math.PI*2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x2, y2, 4, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'neuralNet':
        const nodes = [];
        for(let j=0; j<12; j++) {
          nodes.push({x: (Math.random()-0.5)*180, y: (Math.random()-0.5)*180});
        }
        ctx.strokeStyle = 'rgba(0,240,255,0.2)';
        ctx.lineWidth = 1;
        for(let j=0; j<nodes.length; j++) {
          for(let k=j+1; k<nodes.length; k++) {
            const d = Math.hypot(nodes[j].x-nodes[k].x, nodes[j].y-nodes[k].y);
            if(d < 100) {
              ctx.beginPath();
              ctx.moveTo(nodes[j].x, nodes[j].y);
              ctx.lineTo(nodes[k].x, nodes[k].y);
              ctx.stroke();
            }
          }
        }
        ctx.fillStyle = 'rgba(176,67,255,0.6)';
        nodes.forEach(n => {
          ctx.beginPath();
          ctx.arc(n.x, n.y, 5, 0, Math.PI*2);
          ctx.fill();
        });
        break;
        
      case 'crystalGrowth':
        ctx.strokeStyle = 'rgba(0,240,255,0.4)';
        ctx.lineWidth = 2;
        for(let j=0; j<6; j++) {
          const ang = (j/6)*Math.PI*2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(ang)*80, Math.sin(ang)*80);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(Math.cos(ang)*40, Math.sin(ang)*40);
          ctx.lineTo(Math.cos(ang+0.5)*60, Math.sin(ang+0.5)*60);
          ctx.stroke();
        }
        break;
        
      case 'radarScan':
        ctx.beginPath();
        ctx.arc(0, 0, 80, 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(0,255,140,0.4)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(0, 0, 50, 0, Math.PI*2);
        ctx.stroke();
        const grd6 = ctx.createLinearGradient(0,0,60,60);
        grd6.addColorStop(0, 'rgba(0,255,140,0.6)');
        grd6.addColorStop(1, 'rgba(0,255,140,0)');
        ctx.fillStyle = grd6;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, 80, -Math.PI/4, Math.PI/4);
        ctx.closePath();
        ctx.fill();
        break;
        
      case 'energyShield':
        for(let j=0; j<4; j++) {
          ctx.beginPath();
          ctx.arc(0, 0, 40 + j*15, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(0,240,255,${0.5 - j*0.1})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        ctx.strokeStyle = 'rgba(176,67,255,0.3)';
        for(let j=0; j<6; j++) {
          const ang = (j/6)*Math.PI*2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(ang)*90, Math.sin(ang)*90);
          ctx.stroke();
        }
        break;
        
      case 'spectrumAnalyzer':
        const colors = ['rgba(255,0,0,0.5)', 'rgba(255,127,0,0.5)', 'rgba(255,255,0,0.5)', 
                       'rgba(0,255,0,0.5)', 'rgba(0,0,255,0.5)', 'rgba(75,0,130,0.5)', 'rgba(148,0,211,0.5)'];
        for(let j=0; j<7; j++) {
          ctx.fillStyle = colors[j];
          ctx.fillRect(-70 + j*20, -60, 18, 120);
        }
        break;
        
      case 'particleExplosion':
        for(let j=0; j<30; j++) {
          const ang = (j/30)*Math.PI*2;
          const r = 20 + Math.random()*60;
          const x = Math.cos(ang)*r;
          const y = Math.sin(ang)*r;
          ctx.fillStyle = `rgba(255,${100 + Math.random()*155},0,${0.4 + Math.random()*0.4})`;
          ctx.beginPath();
          ctx.arc(x, y, 2 + Math.random()*4, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'rippleEffect':
        for(let j=0; j<5; j++) {
          ctx.beginPath();
          ctx.arc(0, 0, 20 + j*20, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(0,240,255,${0.6 - j*0.1})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        break;
        
      case 'nebulaSwirl':
        for(let j=0; j<50; j++) {
          const ang = (j/50)*Math.PI*4;
          const r = j*1.5;
          const x = Math.cos(ang)*r;
          const y = Math.sin(ang)*r;
          ctx.fillStyle = `rgba(${100 + j*2},${50 + j},255,${0.3 + Math.random()*0.3})`;
          ctx.beginPath();
          ctx.arc(x, y, 2, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'binaryClock':
        ctx.font = '12px monospace';
        ctx.fillStyle = 'rgba(0,255,140,0.6)';
        for(let j=0; j<6; j++) {
          for(let k=0; k<4; k++) {
            const bit = Math.random() > 0.5 ? '1' : '0';
            ctx.fillText(bit, -60 + j*24, -40 + k*24);
          }
        }
        break;
        
      case 'magneticField':
        ctx.strokeStyle = 'rgba(176,67,255,0.4)';
        ctx.lineWidth = 2;
        for(let j=-3; j<=3; j++) {
          ctx.beginPath();
          for(let t=0; t<=1; t+=0.05) {
            const x = (t-0.5)*200;
            const y = j*20 + Math.sin(t*Math.PI*2)*30;
            if(t===0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
        ctx.fillStyle = 'rgba(255,0,0,0.6)';
        ctx.beginPath();
        ctx.arc(-60, 0, 10, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = 'rgba(0,0,255,0.6)';
        ctx.beginPath();
        ctx.arc(60, 0, 10, 0, Math.PI*2);
        ctx.fill();
        break;
        
      case 'fiberNetwork':
        ctx.strokeStyle = 'rgba(0,240,255,0.3)';
        ctx.lineWidth = 1;
        for(let j=0; j<8; j++) {
          const x1 = -80 + Math.random()*160;
          const y1 = -80 + Math.random()*160;
          const x2 = -80 + Math.random()*160;
          const y2 = -80 + Math.random()*160;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.bezierCurveTo(x1, (y1+y2)/2, x2, (y1+y2)/2, x2, y2);
          ctx.stroke();
        }
        break;
        
      case 'quantumWave':
        ctx.strokeStyle = 'rgba(176,67,255,0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let x=-120; x<=120; x+=4) {
          const y = Math.sin(x*0.1)*30 * Math.exp(-Math.abs(x)*0.005);
          if(x===-120) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.fillStyle = 'rgba(176,67,255,0.2)';
        ctx.beginPath();
        for(let x=-120; x<=120; x+=4) {
          const y = Math.sin(x*0.1)*30 * Math.exp(-Math.abs(x)*0.005);
          if(x===-120) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.lineTo(120, 0);
        ctx.lineTo(-120, 0);
        ctx.closePath();
        ctx.fill();
        break;
        
      case 'cyberEye':
        ctx.beginPath();
        ctx.ellipse(0, 0, 80, 50, 0, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,240,255,0.6)';
        ctx.lineWidth = 2;
        ctx.stroke();
        const grd7 = ctx.createRadialGradient(0,0,0,0,0,30);
        grd7.addColorStop(0, 'rgba(0,240,255,0.8)');
        grd7.addColorStop(0.5, 'rgba(176,67,255,0.6)');
        grd7.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd7;
        ctx.beginPath();
        ctx.arc(0, 0, 30, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.arc(-5, -5, 8, 0, Math.PI*2);
        ctx.fill();
        break;
        
      case 'pulseWave':
        for(let j=0; j<4; j++) {
          ctx.strokeStyle = `rgba(0,240,255,${0.6 - j*0.12})`;
          ctx.lineWidth = 3;
          ctx.beginPath();
          for(let x=-120; x<=120; x+=8) {
            let y = 0;
            if(Math.abs(x) < 40) {
              y = Math.sin((x + j*10)*0.2)*40;
            }
            if(x===-120) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
        break;
        
      case 'mandelbrotSet':
        for(let px=-100; px<100; px+=4) {
          for(let py=-100; py<100; py+=4) {
            const x0 = px/50;
            const y0 = py/50;
            let x = 0, y = 0, iteration = 0;
            while(x*x + y*y <= 4 && iteration < 20) {
              const xtemp = x*x - y*y + x0;
              y = 2*x*y + y0;
              x = xtemp;
              iteration++;
            }
            const color = iteration < 20 ? iteration*12 : 0;
            ctx.fillStyle = `rgba(${color},${color*2},255,0.6)`;
            ctx.fillRect(px, py, 4, 4);
          }
        }
        break;
        
      case 'kaleidoscope':
        for(let j=0; j<8; j++) {
          ctx.save();
          ctx.rotate((j/8)*Math.PI*2);
          ctx.fillStyle = `rgba(${Math.random()*255},${Math.random()*255},255,0.4)`;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(60, 20);
          ctx.lineTo(50, 60);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
        break;
        
      case 'laserShow':
        for(let j=0; j<6; j++) {
          const ang = (j/6)*Math.PI*2;
          const grd8 = ctx.createLinearGradient(0,0,Math.cos(ang)*100,Math.sin(ang)*100);
          grd8.addColorStop(0, `rgba(${Math.random()*255},${Math.random()*255},255,0.8)`);
          grd8.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.strokeStyle = grd8;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(ang)*100, Math.sin(ang)*100);
          ctx.stroke();
        }
        break;
        
      case 'blackHole':
        for(let j=0; j<10; j++) {
          const r = 20 + j*10;
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(176,67,255,${0.6 - j*0.05})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        const grd9 = ctx.createRadialGradient(0,0,0,0,0,40);
        grd9.addColorStop(0, 'rgba(0,0,0,1)');
        grd9.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd9;
        ctx.beginPath();
        ctx.arc(0, 0, 40, 0, Math.PI*2);
        ctx.fill();
        break;
        
      case 'circuitBoard':
        ctx.strokeStyle = 'rgba(0,255,140,0.4)';
        ctx.lineWidth = 2;
        for(let j=0; j<5; j++) {
          const x1 = -80 + Math.random()*160;
          const y1 = -80 + Math.random()*160;
          const x2 = -80 + Math.random()*160;
          const y2 = -80 + Math.random()*160;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x1, (y1+y2)/2);
          ctx.lineTo(x2, (y1+y2)/2);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          ctx.fillStyle = 'rgba(0,240,255,0.6)';
          ctx.beginPath();
          ctx.arc(x1, y1, 4, 0, Math.PI*2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x2, y2, 4, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'audioVisualizer':
        for(let j=0; j<20; j++) {
          const h = 20 + Math.random()*60;
          ctx.fillStyle = `rgba(${j*12},${255-j*10},255,0.6)`;
          ctx.fillRect(-100 + j*10, 40-h, 8, h);
        }
        break;
        
      case 'timeTunnel':
        for(let j=0; j<8; j++) {
          const r = 20 + j*15;
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(0,240,255,${0.6 - j*0.06})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        for(let j=0; j<12; j++) {
          const ang = (j/12)*Math.PI*2;
          ctx.beginPath();
          ctx.moveTo(Math.cos(ang)*20, Math.sin(ang)*20);
          ctx.lineTo(Math.cos(ang)*120, Math.sin(ang)*120);
          ctx.strokeStyle = 'rgba(176,67,255,0.3)';
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        break;
        
      case 'plasmaStorm':
        for(let j=0; j<40; j++) {
          const x = (Math.random()-0.5)*180;
          const y = (Math.random()-0.5)*180;
          const grd10 = ctx.createRadialGradient(x,y,0,x,y,15);
          grd10.addColorStop(0, `rgba(${100 + Math.random()*155},${Math.random()*100},255,0.6)`);
          grd10.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = grd10;
          ctx.fillRect(x-15, y-15, 30, 30);
        }
        break;
      case 'neonTunnel':
        for(let j=0; j<6; j++) {
          ctx.beginPath();
          ctx.arc(0, 0, 20 + j*15, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(255,0,255,${0.6 - j*0.08})`;
          ctx.lineWidth = 3;
          ctx.stroke();
        }
        ctx.strokeStyle = 'rgba(0,240,255,0.4)';
        for(let j=0; j<8; j++) {
          const ang = (j/8)*Math.PI*2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(ang)*100, Math.sin(ang)*100);
          ctx.stroke();
        }
        break;
        
      case 'gravityWell':
        const grd11 = ctx.createRadialGradient(0,0,0,0,0,100);
        grd11.addColorStop(0, 'rgba(0,0,0,0.9)');
        grd11.addColorStop(0.3, 'rgba(128,0,255,0.6)');
        grd11.addColorStop(0.7, 'rgba(0,240,255,0.3)');
        grd11.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd11;
        ctx.fillRect(-100,-100,200,200);
        for(let j=0; j<20; j++) {
          const ang = (j/20)*Math.PI*2;
          const r = 40 + Math.random()*50;
          ctx.fillStyle = 'rgba(255,255,255,0.6)';
          ctx.beginPath();
          ctx.arc(Math.cos(ang)*r, Math.sin(ang)*r, 2, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'prismRefract':
        const colors2 = [
          'rgba(255,0,0,0.5)', 'rgba(255,127,0,0.5)', 'rgba(255,255,0,0.5)',
          'rgba(0,255,0,0.5)', 'rgba(0,127,255,0.5)', 'rgba(0,0,255,0.5)', 'rgba(139,0,255,0.5)'
        ];
        for(let j=0; j<7; j++) {
          ctx.fillStyle = colors2[j];
          ctx.beginPath();
          ctx.moveTo(-60 + j*20, -80);
          ctx.lineTo(-50 + j*20, 80);
          ctx.lineTo(-40 + j*20, 80);
          ctx.lineTo(-50 + j*20, -80);
          ctx.closePath();
          ctx.fill();
        }
        break;
        
      case 'quantumFoam':
        for(let j=0; j<30; j++) {
          const x = (Math.random()-0.5)*180;
          const y = (Math.random()-0.5)*180;
          const r = 5 + Math.random()*15;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI*2);
          ctx.fillStyle = `rgba(176,67,255,${0.2 + Math.random()*0.3})`;
          ctx.fill();
          ctx.strokeStyle = `rgba(0,240,255,${0.3 + Math.random()*0.3})`;
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        break;
        
      case 'cyberRain':
        ctx.strokeStyle = 'rgba(0,240,255,0.4)';
        ctx.lineWidth = 2;
        for(let j=0; j<15; j++) {
          const x = -100 + j*14;
          const len = 20 + Math.random()*40;
          ctx.beginPath();
          ctx.moveTo(x, -100);
          ctx.lineTo(x, -100 + len);
          ctx.stroke();
        }
        break;
        
      case 'spiralMatrix':
        ctx.strokeStyle = 'rgba(0,240,255,0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let j=0; j<100; j++) {
          const ang = j*0.2;
          const r = j*0.8;
          const x = Math.cos(ang)*r;
          const y = Math.sin(ang)*r;
          if(j===0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        break;
        
      case 'energyVortex':
        for(let j=0; j<8; j++) {
          const ang = (j/8)*Math.PI*2;
          ctx.strokeStyle = `rgba(255,0,255,${0.6 - j*0.05})`;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(0, 0, 20 + j*10, ang, ang + Math.PI/2);
          ctx.stroke();
        }
        break;
        
      case 'digitalHorizon':
        const grd12 = ctx.createLinearGradient(0,-100,0,100);
        grd12.addColorStop(0, 'rgba(255,0,128,0.4)');
        grd12.addColorStop(0.5, 'rgba(0,0,0,0.8)');
        grd12.addColorStop(1, 'rgba(0,240,255,0.4)');
        ctx.fillStyle = grd12;
        ctx.fillRect(-100,-100,200,200);
        ctx.strokeStyle = 'rgba(0,240,255,0.6)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-100, 0);
        ctx.lineTo(100, 0);
        ctx.stroke();
        break;
        
      case 'particleSwarm':
        for(let j=0; j<50; j++) {
          const ang = (j/50)*Math.PI*2;
          const r = 30 + Math.sin(j*0.5)*20;
          const x = Math.cos(ang)*r;
          const y = Math.sin(ang)*r;
          ctx.fillStyle = `rgba(0,240,255,${0.4 + Math.random()*0.4})`;
          ctx.beginPath();
          ctx.arc(x, y, 2, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'neonPulse':
        for(let j=0; j<5; j++) {
          ctx.beginPath();
          ctx.arc(0, 0, 20 + j*18, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(255,0,255,${0.7 - j*0.12})`;
          ctx.lineWidth = 4;
          ctx.stroke();
        }
        break;
        
      case 'fractalZoom':
        for(let j=0; j<6; j++) {
          const s = 80 - j*12;
          ctx.strokeStyle = `rgba(176,67,255,${0.6 - j*0.08})`;
          ctx.lineWidth = 2;
          ctx.strokeRect(-s/2, -s/2, s, s);
        }
        break;
        
      case 'laserGrid':
        ctx.strokeStyle = 'rgba(255,0,0,0.5)';
        ctx.lineWidth = 2;
        for(let j=-4; j<=4; j++) {
          ctx.beginPath();
          ctx.moveTo(-100, j*25);
          ctx.lineTo(100, j*25);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(j*25, -100);
          ctx.lineTo(j*25, 100);
          ctx.stroke();
        }
        break;
        
      case 'quantumTunnel':
        for(let j=0; j<8; j++) {
          const s = 20 + j*15;
          ctx.strokeStyle = `rgba(176,67,255,${0.7 - j*0.07})`;
          ctx.lineWidth = 2;
          ctx.strokeRect(-s/2, -s/2, s, s);
          ctx.rotate(Math.PI/16);
        }
        break;
        
      case 'cyberWaves':
        ctx.strokeStyle = 'rgba(0,240,255,0.6)';
        ctx.lineWidth = 3;
        for(let j=0; j<4; j++) {
          ctx.beginPath();
          for(let x=-120; x<=120; x+=5) {
            const y = Math.sin(x*0.08 + j*1.5)*25 + j*15 - 30;
            if(x===-120) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
        break;
        
      case 'plasmaRings':
        for(let j=0; j<6; j++) {
          ctx.beginPath();
          ctx.arc(0, 0, 15 + j*15, 0, Math.PI*2);
          const grd13 = ctx.createRadialGradient(0,0,15+j*15-5,0,0,15+j*15+5);
          grd13.addColorStop(0, `rgba(${100+j*20},${50+j*30},255,0)`);
          grd13.addColorStop(0.5, `rgba(${100+j*20},${50+j*30},255,0.6)`);
          grd13.addColorStop(1, `rgba(${100+j*20},${50+j*30},255,0)`);
          ctx.strokeStyle = grd13;
          ctx.lineWidth = 8;
          ctx.stroke();
        }
        break;
        
      case 'digitalWaterfall':
        ctx.font = '10px monospace';
        for(let j=0; j<12; j++) {
          for(let k=0; k<10; k++) {
            ctx.fillStyle = `rgba(0,240,255,${0.8 - k*0.08})`;
            ctx.fillText(Math.random().toString(36).substr(2,1), -100 + j*18, -80 + k*18);
          }
        }
        break;
        
      case 'neonSpiral':
        ctx.strokeStyle = 'rgba(255,0,255,0.6)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        for(let j=0; j<150; j++) {
          const ang = j*0.15;
          const r = j*0.5;
          const x = Math.cos(ang)*r;
          const y = Math.sin(ang)*r;
          if(j===0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        break;
        
      case 'energyBurst':
        for(let j=0; j<16; j++) {
          const ang = (j/16)*Math.PI*2;
          const grd14 = ctx.createLinearGradient(0,0,Math.cos(ang)*80,Math.sin(ang)*80);
          grd14.addColorStop(0, 'rgba(255,255,0,0.8)');
          grd14.addColorStop(0.5, 'rgba(255,0,0,0.6)');
          grd14.addColorStop(1, 'rgba(255,0,0,0)');
          ctx.strokeStyle = grd14;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(ang)*80, Math.sin(ang)*80);
          ctx.stroke();
        }
        break;
        
      case 'particleTrails':
        for(let j=0; j<10; j++) {
          const ang = (j/10)*Math.PI*2;
          ctx.strokeStyle = `rgba(0,240,255,${0.6 - j*0.04})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          for(let k=0; k<20; k++) {
            const r = k*4;
            const x = Math.cos(ang + k*0.1)*r;
            const y = Math.sin(ang + k*0.1)*r;
            if(k===0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
        break;
        
      case 'cyberBloom':
        for(let j=0; j<8; j++) {
          const ang = (j/8)*Math.PI*2;
          ctx.fillStyle = `rgba(255,0,255,${0.4 + j*0.03})`;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.arc(Math.cos(ang)*50, Math.sin(ang)*50, 25, ang-0.4, ang+0.4);
          ctx.closePath();
          ctx.fill();
        }
        break;
        
      case 'quantumRipples':
        for(let j=0; j<6; j++) {
          ctx.beginPath();
          ctx.arc(0, 0, 15 + j*18, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(176,67,255,${0.7 - j*0.1})`;
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(0, 0, 15 + j*18 + 5, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(0,240,255,${0.5 - j*0.08})`;
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        break;
        
      case 'laserBeams':
        for(let j=0; j<8; j++) {
          const ang = (j/8)*Math.PI*2 + Math.PI/16;
          const grd15 = ctx.createLinearGradient(0,0,Math.cos(ang)*100,Math.sin(ang)*100);
          grd15.addColorStop(0, 'rgba(255,0,0,0.8)');
          grd15.addColorStop(0.5, 'rgba(255,255,0,0.6)');
          grd15.addColorStop(1, 'rgba(255,0,0,0)');
          ctx.strokeStyle = grd15;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(ang)*100, Math.sin(ang)*100);
          ctx.stroke();
        }
        break;
        
      case 'digitalSmoke':
        for(let j=0; j<20; j++) {
          const x = (Math.random()-0.5)*160;
          const y = -80 + j*8;
          const r = 10 + Math.random()*20;
          ctx.fillStyle = `rgba(100,100,255,${0.3 - j*0.01})`;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'neonRings':
        for(let j=0; j<5; j++) {
          ctx.beginPath();
          ctx.arc(0, 0, 20 + j*20, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(255,0,255,${0.7 - j*0.1})`;
          ctx.lineWidth = 4;
          ctx.stroke();
          ctx.strokeStyle = `rgba(0,240,255,${0.5 - j*0.08})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        break;
        
      case 'energyWeb':
        const nodes2 = [];
        for(let j=0; j<10; j++) {
          const ang = (j/10)*Math.PI*2;
          nodes2.push({x: Math.cos(ang)*60, y: Math.sin(ang)*60});
        }
        ctx.strokeStyle = 'rgba(0,240,255,0.4)';
        ctx.lineWidth = 1;
        for(let j=0; j<nodes2.length; j++) {
          for(let k=j+1; k<nodes2.length; k++) {
            ctx.beginPath();
            ctx.moveTo(nodes2[j].x, nodes2[j].y);
            ctx.lineTo(nodes2[k].x, nodes2[k].y);
            ctx.stroke();
          }
        }
        ctx.fillStyle = 'rgba(255,0,255,0.8)';
        nodes2.forEach(n => {
          ctx.beginPath();
          ctx.arc(n.x, n.y, 4, 0, Math.PI*2);
          ctx.fill();
        });
        break;
        
      case 'particleDance':
        for(let j=0; j<30; j++) {
          const ang = (j/30)*Math.PI*2;
          const r = 40 + Math.sin(j*0.8)*20;
          const x = Math.cos(ang)*r;
          const y = Math.sin(ang)*r;
          ctx.fillStyle = `rgba(${100 + j*5},${200 - j*3},255,0.6)`;
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'cyberPulse':
        for(let j=0; j<4; j++) {
          ctx.strokeStyle = `rgba(0,240,255,${0.8 - j*0.15})`;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(0, 0, 25 + j*20, 0, Math.PI*2);
          ctx.stroke();
        }
        ctx.fillStyle = 'rgba(255,0,255,0.6)';
        ctx.beginPath();
        ctx.arc(0, 0, 15, 0, Math.PI*2);
        ctx.fill();
        break;
        
      case 'quantumStrings':
        ctx.strokeStyle = 'rgba(176,67,255,0.5)';
        ctx.lineWidth = 2;
        for(let j=0; j<8; j++) {
          ctx.beginPath();
          for(let x=-100; x<=100; x+=5) {
            const y = Math.sin(x*0.05 + j*0.8)*30 + (j-4)*15;
            if(x===-100) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
        break;
        
      case 'laserSpiral':
        const grd16 = ctx.createLinearGradient(-80,-80,80,80);
        grd16.addColorStop(0, 'rgba(255,0,0,0.6)');
        grd16.addColorStop(0.5, 'rgba(255,255,0,0.6)');
        grd16.addColorStop(1, 'rgba(255,0,0,0.6)');
        ctx.strokeStyle = grd16;
        ctx.lineWidth = 3;
        ctx.beginPath();
        for(let j=0; j<100; j++) {
          const ang = j*0.2;
          const r = j*0.7;
          const x = Math.cos(ang)*r;
          const y = Math.sin(ang)*r;
          if(j===0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        break;
        
      case 'digitalAurora':
        for(let j=0; j<6; j++) {
          ctx.strokeStyle = `rgba(${100 + j*25},${200 - j*20},255,${0.5 - j*0.05})`;
          ctx.lineWidth = 8;
          ctx.beginPath();
          for(let x=-120; x<=120; x+=10) {
            const y = Math.sin(x*0.04 + j*0.6)*35 + Math.cos(x*0.02)*15 + (j-3)*8;
            if(x===-120) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
        break;
        
      case 'neonWaves':
        for(let j=0; j<5; j++) {
          ctx.strokeStyle = `rgba(255,0,255,${0.7 - j*0.1})`;
          ctx.lineWidth = 3;
          ctx.beginPath();
          for(let x=-120; x<=120; x+=5) {
            const y = Math.sin(x*0.06 + j*1.2)*30 + j*12 - 30;
            if(x===-120) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
        break;
        
      case 'energySphere':
        const grd17 = ctx.createRadialGradient(0,0,0,0,0,70);
        grd17.addColorStop(0, 'rgba(255,255,0,0.8)');
        grd17.addColorStop(0.5, 'rgba(255,0,255,0.5)');
        grd17.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd17;
        ctx.beginPath();
        ctx.arc(0, 0, 70, 0, Math.PI*2);
        ctx.fill();
        for(let j=0; j<12; j++) {
          const ang = (j/12)*Math.PI*2;
          ctx.strokeStyle = 'rgba(255,255,255,0.6)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(ang)*70, Math.sin(ang)*70);
          ctx.stroke();
        }
        break;
        
      case 'particleFountain':
        for(let j=0; j<40; j++) {
          const x = (Math.random()-0.5)*60;
          const y = -80 + j*4;
          const size = 2 + Math.random()*3;
          ctx.fillStyle = `rgba(0,240,255,${0.8 - j*0.015})`;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'cyberVortex':
        for(let j=0; j<50; j++) {
          const ang = j*0.2;
          const r = j*1.5;
          const x = Math.cos(ang)*r;
          const y = Math.sin(ang)*r;
          ctx.fillStyle = `rgba(0,240,255,${0.8 - j*0.015})`;
          ctx.beginPath();
          ctx.arc(x, y, 2, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'quantumGrid':
        ctx.strokeStyle = 'rgba(176,67,255,0.4)';
        ctx.lineWidth = 1;
        for(let j=-4; j<=4; j++) {
          for(let k=-4; k<=4; k++) {
            ctx.strokeRect(j*22-8, k*22-8, 16, 16);
          }
        }
        ctx.fillStyle = 'rgba(0,240,255,0.6)';
        for(let j=0; j<8; j++) {
          const x = (Math.random()-0.5)*160;
          const y = (Math.random()-0.5)*160;
          ctx.beginPath();
          ctx.arc(x, y, 4, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'laserPulse':
        for(let j=0; j<6; j++) {
          const ang = (j/6)*Math.PI*2;
          ctx.strokeStyle = `rgba(255,0,0,${0.8 - j*0.1})`;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(ang)*90, Math.sin(ang)*90);
          ctx.stroke();
        }
        ctx.fillStyle = 'rgba(255,255,0,0.8)';
        ctx.beginPath();
        ctx.arc(0, 0, 12, 0, Math.PI*2);
        ctx.fill();
        break;
        
      case 'digitalNebula':
        for(let j=0; j<60; j++) {
          const x = (Math.random()-0.5)*180;
          const y = (Math.random()-0.5)*180;
          const grd18 = ctx.createRadialGradient(x,y,0,x,y,10);
          grd18.addColorStop(0, `rgba(${100 + Math.random()*155},${50 + Math.random()*100},255,0.5)`);
          grd18.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = grd18;
          ctx.fillRect(x-10, y-10, 20, 20);
        }
        break;
        
      case 'neonMatrix':
        ctx.strokeStyle = 'rgba(255,0,255,0.4)';
        ctx.lineWidth = 2;
        for(let j=-3; j<=3; j++) {
          for(let k=-3; k<=3; k++) {
            ctx.strokeRect(j*28-10, k*28-10, 20, 20);
          }
        }
        ctx.fillStyle = 'rgba(0,240,255,0.6)';
        for(let j=-3; j<=3; j++) {
          for(let k=-3; k<=3; k++) {
            if(Math.random() > 0.7) {
              ctx.fillRect(j*28-8, k*28-8, 16, 16);
            }
          }
        }
        break;
        
      case 'energyFlow':
        for(let j=0; j<8; j++) {
          ctx.strokeStyle = `rgba(255,255,0,${0.7 - j*0.08})`;
          ctx.lineWidth = 3;
          ctx.beginPath();
          for(let x=-120; x<=120; x+=8) {
            const y = Math.sin(x*0.05 + j*0.8)*25 + (j-4)*12;
            if(x===-120) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
        break;
        
      case 'particleStorm':
        for(let j=0; j<80; j++) {
          const x = (Math.random()-0.5)*200;
          const y = (Math.random()-0.5)*200;
          const size = 1 + Math.random()*4;
          ctx.fillStyle = `rgba(${150 + Math.random()*105},${100 + Math.random()*155},255,${0.4 + Math.random()*0.4})`;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI*2);
          ctx.fill();
        }
        break;
        
      case 'cyberSphere':
        ctx.beginPath();
        ctx.arc(0, 0, 70, 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(0,240,255,0.6)';
        ctx.lineWidth = 3;
        ctx.stroke();
        for(let j=0; j<6; j++) {
          ctx.beginPath();
          ctx.ellipse(0, 0, 70, 20 + j*10, (j/6)*Math.PI, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(176,67,255,${0.4 - j*0.05})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        break;
        
      case 'quantumBurst':
        for(let j=0; j<20; j++) {
          const ang = (j/20)*Math.PI*2;
          const len = 40 + Math.random()*40;
          ctx.strokeStyle = `rgba(176,67,255,${0.8 - Math.random()*0.3})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(ang)*len, Math.sin(ang)*len);
          ctx.stroke();
        }
        break;
        
      case 'laserWeb':
        for(let j=0; j<6; j++) {
          const ang1 = (j/6)*Math.PI*2;
          const ang2 = ((j+1)/6)*Math.PI*2;
          ctx.strokeStyle = 'rgba(255,0,0,0.5)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(Math.cos(ang1)*80, Math.sin(ang1)*80);
          ctx.lineTo(Math.cos(ang2)*80, Math.sin(ang2)*80);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(ang1)*80, Math.sin(ang1)*80);
          ctx.stroke();
        }
        break;
        
      case 'digitalVortex':
        for(let j=0; j<60; j++) {
          const ang = j*0.25;
          const r = j*1.2;
          const x = Math.cos(ang)*r;
          const y = Math.sin(ang)*r;
          ctx.fillStyle = `rgba(0,240,255,${0.7 - j*0.01})`;
          ctx.fillRect(x-2, y-2, 4, 4);
        }
        break;
        
      case 'neonFlow':
        for(let j=0; j<6; j++) {
          ctx.strokeStyle = `rgba(255,0,255,${0.7 - j*0.1})`;
          ctx.lineWidth = 4;
          ctx.beginPath();
          for(let x=-120; x<=120; x+=6) {
            const y = Math.sin(x*0.04 + j*1.0)*35 + (j-3)*15;
            if(x===-120) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
        break;
        
      case 'energyRings':
        for(let j=0; j<6; j++) {
          ctx.beginPath();
          ctx.arc(0, 0, 18 + j*16, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(255,255,0,${0.7 - j*0.1})`;
          ctx.lineWidth = 3;
          ctx.stroke();
        }
        break;
        
      case 'particleWeb':
        const nodes3 = [];
        for(let j=0; j<15; j++) {
          nodes3.push({x: (Math.random()-0.5)*160, y: (Math.random()-0.5)*160});
        }
        ctx.strokeStyle = 'rgba(0,240,255,0.3)';
        ctx.lineWidth = 1;
        for(let j=0; j<nodes3.length; j++) {
          for(let k=j+1; k<nodes3.length; k++) {
            const d = Math.hypot(nodes3[j].x-nodes3[k].x, nodes3[j].y-nodes3[k].y);
            if(d < 80) {
              ctx.beginPath();
              ctx.moveTo(nodes3[j].x, nodes3[j].y);
              ctx.lineTo(nodes3[k].x, nodes3[k].y);
              ctx.stroke();
            }
          }
        }
        ctx.fillStyle = 'rgba(255,0,255,0.7)';
        nodes3.forEach(n => {
          ctx.beginPath();
          ctx.arc(n.x, n.y, 3, 0, Math.PI*2);
          ctx.fill();
        });
        break;
        
      case 'cyberAurora':
        for(let j=0; j<7; j++) {
          ctx.strokeStyle = `rgba(${50 + j*30},${150 + j*15},255,${0.5 - j*0.05})`;
          ctx.lineWidth = 10;
          ctx.beginPath();
          for(let x=-120; x<=120; x+=8) {
            const y = Math.sin(x*0.04 + j*0.6)*35 + Math.cos(x*0.02)*15 + (j-3)*8;
            if(x===-120) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
        break;

			case 'fractalFern':
				ctx.strokeStyle = 'rgba(50,255,100,0.4)';
				ctx.lineWidth = 1;
				function drawFern(x,y,len,angle,depth){
					if(depth===0) return;
					const x2=x+Math.cos(angle)*len, y2=y+Math.sin(angle)*len;
					ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x2,y2); ctx.stroke();
					drawFern(x2,y2,len*0.8,angle-0.3,depth-1);
					drawFern(x2,y2,len*0.6,angle+0.5,depth-1);
				}
				drawFern(0,100,40,-Math.PI/2,6);
				ctx.restore();
				break;

			case 'fractalSnowflake':
				ctx.strokeStyle = 'rgba(100,200,255,0.5)';
				ctx.lineWidth = 2;
				function drawKoch(x1,y1,x2,y2,depth){
					if(depth===0){
						ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
						return;
					}
					const dx=(x2-x1)/3, dy=(y2-y1)/3;
					const x3=x1+dx, y3=y1+dy;
					const x4=x1+2*dx, y4=y1+2*dy;
					const x5=x3+dx*0.5-dy*Math.sqrt(3)/2, y5=y3+dy*0.5+dx*Math.sqrt(3)/2;
					drawKoch(x1,y1,x3,y3,depth-1);
					drawKoch(x3,y3,x5,y5,depth-1);
					drawKoch(x5,y5,x4,y4,depth-1);
					drawKoch(x4,y4,x2,y2,depth-1);
				}
				const r1=80;
				for(let i=0;i<3;i++){
					const a1=i*Math.PI*2/3-Math.PI/2, a2=(i+1)*Math.PI*2/3-Math.PI/2;
					drawKoch(Math.cos(a1)*r1,Math.sin(a1)*r1,Math.cos(a2)*r1,Math.sin(a2)*r1,2);
				}
				ctx.restore();
				break;

			case 'fractalDragon':
				ctx.strokeStyle = 'rgba(255,100,150,0.5)';
				ctx.lineWidth = 1;
				let dragonSeq = [1];
				for(let i=0;i<8;i++){
					dragonSeq = [...dragonSeq, 1, ...dragonSeq.reverse().map(x=>-x)];
				}
				let dx=0, dy=0, angle=0;
				ctx.beginPath(); ctx.moveTo(dx,dy);
				dragonSeq.forEach(turn=>{
					angle += turn*Math.PI/2;
					dx += Math.cos(angle)*2;
					dy += Math.sin(angle)*2;
					ctx.lineTo(dx,dy);
				});
				ctx.stroke();
				ctx.restore();
				break;

			case 'fractalSpiral':
				ctx.strokeStyle = 'rgba(255,200,0,0.4)';
				ctx.lineWidth = 2;
				function drawSpiral(x,y,r,angle,depth){
					if(depth===0||r<1) return;
					const x2=x+Math.cos(angle)*r, y2=y+Math.sin(angle)*r;
					ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x2,y2); ctx.stroke();
					drawSpiral(x2,y2,r*0.85,angle+0.5,depth-1);
				}
				drawSpiral(0,0,60,0,20);
				ctx.restore();
				break;

			case 'fractalTriangle':
				ctx.fillStyle = 'rgba(255,100,255,0.4)';
				function drawSierpinski(x,y,size,depth){
					if(depth===0){
						ctx.beginPath();
						ctx.moveTo(x,y);
						ctx.lineTo(x+size,y);
						ctx.lineTo(x+size/2,y-size*Math.sqrt(3)/2);
						ctx.fill();
						return;
					}
					const half=size/2;
					drawSierpinski(x,y,half,depth-1);
					drawSierpinski(x+half,y,half,depth-1);
					drawSierpinski(x+half/2,y-half*Math.sqrt(3)/2,half,depth-1);
				}
				drawSierpinski(-80,80,160,4);
				ctx.restore();
				break;

			case 'fractalBranch':
				ctx.strokeStyle = 'rgba(150,255,150,0.4)';
				ctx.translate(0, 40);
				function drawBranch(x,y,len,angle,depth){
					if(depth===0) return;
					const x2=x+Math.cos(angle)*len, y2=y+Math.sin(angle)*len;
					ctx.lineWidth = depth*0.5;
					ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x2,y2); ctx.stroke();
					drawBranch(x2,y2,len*0.75,angle-0.4,depth-1);
					drawBranch(x2,y2,len*0.75,angle+0.4,depth-1);
					drawBranch(x2,y2,len*0.6,angle,depth-1);
				}
				drawBranch(0,0,50,-Math.PI/2,6);
				ctx.restore();
				break;

			case 'fractalLightning':
				ctx.strokeStyle = 'rgba(150,200,255,0.6)';
				ctx.lineWidth = 2;
				function drawLightning(x1,y1,x2,y2,depth){
					if(depth===0){
						ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
						return;
					}
					const mx=(x1+x2)/2+(Math.random()-0.5)*30;
					const my=(y1+y2)/2+(Math.random()-0.5)*30;
					drawLightning(x1,y1,mx,my,depth-1);
					drawLightning(mx,my,x2,y2,depth-1);
				}
				drawLightning(0,-100,0,100,4);
				ctx.restore();
				break;

			case 'fractalVine':
				ctx.strokeStyle = 'rgba(100,255,150,0.4)';
				function drawVine(x,y,len,angle,depth){
					if(depth===0) return;
					const x2=x+Math.cos(angle)*len, y2=y+Math.sin(angle)*len;
					ctx.lineWidth = depth*0.8;
					ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x2,y2); ctx.stroke();
					drawVine(x2,y2,len*0.8,angle-0.6,depth-1);
					drawVine(x2,y2,len*0.7,angle+0.3,depth-1);
				}
				drawVine(-50,50,40,0,7);
				ctx.restore();
				break;

			case 'fractalCrystal':
				ctx.strokeStyle = 'rgba(150,220,255,0.4)';
				ctx.lineWidth = 1;
				function drawCrystal(x,y,r,angle,depth){
					if(depth===0) return;
					for(let i=0;i<6;i++){
						const a=angle+i*Math.PI/3;
						const x2=x+Math.cos(a)*r, y2=y+Math.sin(a)*r;
						ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x2,y2); ctx.stroke();
					}
				}
				drawCrystal(0,0,40,0,3);
				ctx.restore();
				break;

			case 'fractalWeb':
				ctx.strokeStyle = 'rgba(200,200,255,0.3)';
				ctx.lineWidth = 1;
				function drawWeb(x,y,r,depth){
					if(depth===0) return;
					for(let i=0;i<8;i++){
						const a=i*Math.PI/4;
						const x2=x+Math.cos(a)*r, y2=y+Math.sin(a)*r;
						ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x2,y2); ctx.stroke();
						drawWeb(x2,y2,r*0.6,depth-1);
					}
				}
				drawWeb(0,0,50,3);
				ctx.restore();
				break;
    }
    
    ctx.restore();
    
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(0, h-40, w, 40);
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.font = '14px Rajdhani, sans-serif';
    ctx.fillText(TEMPLATE_META[id].name, 12, h-16);
  }, 50 + i*20);
});

const overlay = $('#overlay');
const canvasWrap = $('#canvasWrap');
const overlayUI = $('#overlayUI');
const backBtn = $('#backBtn');
const currentLabel = $('#currentLabel');
const autoplayToggle = $('#autoplayToggle');
const autoplayIntervalSelect = $('#autoplayInterval');
const nextBtn = $('#nextBtn');
const autoplayDot = $('#autoplayDot');
const picControlsContainer = $('#picControlsContainer');
const randomBtn = $('#randomBtn');
const helpBtn = $('#helpBtn');

canvasWrap.addEventListener('click', (e)=> {
  if(e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
  uiVisible = !uiVisible;
  if(uiVisible) {
    overlayUI.classList.remove('hidden');
  } else {
    overlayUI.classList.add('hidden');
  }
});

backBtn.addEventListener('click', closeOverlay);
autoplayToggle.addEventListener('click', ()=> {
  autoplay = !autoplay;
  autoplayToggle.classList.toggle('toggled', autoplay);
  autoplayDot.style.display = autoplay ? 'block' : 'none';
  if(autoplay) startAutoplay(); else stopAutoplay();
});
nextBtn.addEventListener('click', ()=> nextTemplate());
randomBtn.addEventListener('click', ()=> {
  const idx = Math.floor(Math.random()*TEMPLATE_IDS.length);
  openTemplate(idx);
});
helpBtn.addEventListener('click', ()=> {
  alert(`LumaGEN — Nice templates for dGEN1. Click cards to view. Click canvas to hide/show controls. Autoplay switches every 20s.`);
});

function startAutoplay(){
  stopAutoplay();
	const interval = parseInt(autoplayIntervalSelect.value, 10);
	nextTemplate();
  autoplayTimer = setInterval(()=> {
    nextTemplate();
  }, interval);
}
function stopAutoplay(){
  if(autoplayTimer){ clearInterval(autoplayTimer); autoplayTimer = null; }
}

function openTemplate(index){
  index = (index + TEMPLATE_IDS.length) % TEMPLATE_IDS.length;
  currentIndex = index;
  const id = TEMPLATE_IDS[index];
  currentLabel.textContent = TEMPLATE_META[id].name;
  overlay.classList.add('active');
  overlay.setAttribute('aria-hidden','false');
  uiVisible = true;
  overlayUI.classList.remove('hidden');

  canvasWrap.innerHTML = '';
  const canvas = create('canvas', {width:window.innerWidth, height:window.innerHeight});
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  canvasWrap.appendChild(canvas);

  const tmpl = templates[id];
  if(!tmpl) return;
  activeInstance = tmpl.mount(canvas, {onExit: closeOverlay});
  picControlsContainer.innerHTML = '';
}

function closeOverlay(){
  if(autoplay) stopAutoplay();
	
  overlay.classList.remove('active');
  overlay.setAttribute('aria-hidden','true');
  if(activeInstance && typeof activeInstance.unmount === 'function') {
    activeInstance.unmount();
    activeInstance = null;
  }
  canvasWrap.innerHTML = '';
}

function nextTemplate(){
  const idx = (currentIndex + 1) % TEMPLATE_IDS.length;
  if(overlay.classList.contains('active')){
    if(activeInstance && typeof activeInstance.unmount === 'function') activeInstance.unmount();
    currentIndex = idx;
    const id = TEMPLATE_IDS[idx];
    currentLabel.textContent = TEMPLATE_META[id].name;
    canvasWrap.innerHTML = '';
    const canvas = create('canvas', {width:window.innerWidth, height:window.innerHeight});
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvasWrap.appendChild(canvas);
    const tmpl = templates[id];
    activeInstance = tmpl.mount(canvas, {onExit: closeOverlay});
    picControlsContainer.innerHTML = '';
  } else {
    openTemplate(idx);
  }
}

function makeRunner(renderFn){
  let running = true;
  let rafId = null;
  function loop(t){
    if(!running) return;
    renderFn(t);
    rafId = requestAnimationFrame(loop);
  }
  rafId = requestAnimationFrame(loop);
  return {
    stop(){ running = false; if(rafId) cancelAnimationFrame(rafId); }
  };
}

function cyberMinimalMount(canvas){
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (t - t0)/1000;
    ctx.clearRect(0,0,w,h);
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, 'rgba(0,0,0,0.9)');
    g.addColorStop(1, 'rgba(10,10,12,0.95)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
    ctx.save();
    ctx.translate(w/2, h/2);
    ctx.rotate(tt*0.18);
    ctx.strokeStyle = 'rgba(0,240,255,0.14)';
    ctx.lineWidth = 6;
    for(let i=0;i<4;i++){
      const s = 220 + Math.sin(tt*0.9 + i)*10;
      ctx.strokeRect(-s/2, -s/2, s, s);
    }
    ctx.restore();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(176,67,255,0.06)';
    ctx.beginPath();
    for(let i=0;i<6;i++){
      const y = h*(i+1)/7 + Math.sin(tt*0.6 + i)*6;
      ctx.moveTo(40, y); ctx.lineTo(w-40, y);
    }
    ctx.stroke();
  });
  return { unmount(){ runner.stop(); } };
}

function cryptoOrbMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const N = 220;
  const pts = new Array(N).fill(0).map((_,i)=>({
    a: Math.random()*Math.PI*2,
    r: 60 + Math.random()*220,
    s: 0.4 + Math.random()*1.4,
    phase: Math.random()*10
  }));
  const runner = makeRunner((t)=>{
    const tsec = (performance.now() - t0)/1000;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = 'rgba(0,0,0,0.96)';
    ctx.fillRect(0,0,W,H);
    const cx = W/2, cy = H/2;
    const grd = ctx.createRadialGradient(cx,cy,10,cx,cy,260);
    grd.addColorStop(0, 'rgba(0,200,255,0.08)');
    grd.addColorStop(0.45, 'rgba(176,67,255,0.03)');
    grd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grd; ctx.fillRect(0,0,W,H);
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0;i<N;i++){
      const p = pts[i];
      const a = p.a + tsec*0.2*(0.6 + p.s*0.3);
      const r = p.r + Math.sin(tsec*0.9 + p.phase)*6;
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r;
      const size = 0.8 + p.s*1.8;
      ctx.beginPath();
      ctx.fillStyle = `rgba(0,240,255,${0.02 + p.s*0.06})`;
      ctx.arc(x,y,size,0,Math.PI*2);
      ctx.fill();
    }
    ctx.globalCompositeOperation = 'source-over';
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,240,255,0.06)';
    ctx.arc(cx, cy, 62 + Math.sin(tsec*0.8)*6, 0, Math.PI*2);
    ctx.fill();
  });
  return { unmount(){ runner.stop(); } };
}

function retroTerminalMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const lines = Array.from({length:30}, ()=> '');
  const ch = 18;
  function randomLine(){
    const hex = '0123456789abcdef';
    let s = '';
    if(Math.random() < 0.2){
      s = 'block ' + Math.floor(Math.random()*999999) + ' detected';
    } else {
      for(let i=0;i<40;i++) s += hex[Math.floor(Math.random()*16)];
    }
    return s;
  }
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.98)';
    ctx.fillRect(0,0,W,H);
    if(Math.random() < 0.28){
      lines.pop();
      lines.unshift(randomLine());
    }
    ctx.font = '16px "Courier New", monospace';
    for(let i=0;i<lines.length;i++){
      const y = 60 + i*ch;
      ctx.fillStyle = (i===0)? 'rgba(0,255,140,0.85)' : 'rgba(0,255,140,0.22)';
      ctx.fillText(lines[i], 22, y);
    }
  });
  return { unmount(){ runner.stop(); } };
}

function zenSpaceMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let s = 0;
  const runner = makeRunner((t)=>{
    const tt = t/1000;
    s = Math.sin(tt*0.12)*0.5 + 0.5;
    const g = ctx.createLinearGradient(0,0,W,H);
    g.addColorStop(0, `rgba(34,36,40,${0.16 + s*0.04})`);
    g.addColorStop(1, `rgba(8,10,12,0.98)`);
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
    ctx.beginPath();
    ctx.fillStyle = `rgba(176,67,255,${0.04 + s*0.06})`;
    ctx.arc(W/2, H/2 - 20, 220 + s*20, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.02)';
    ctx.lineWidth = 1.2;
    for(let i=0;i<5;i++){
      ctx.beginPath();
      const off = Math.sin(tt*0.3 + i)*18;
      ctx.ellipse(W/2, H/2 + off, 200 - i*30, 60, Math.PI/6, 0, Math.PI*2);
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function liquidWavesMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now() - t0)/1000;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#040405'; ctx.fillRect(0,0,W,H);
    for(let k=0;k<4;k++){
      ctx.beginPath();
      const amp = 12 + k*8;
      ctx.moveTo(0, H/2);
      for(let x=0;x<=W;x+=6){
        const y = H/2 + Math.sin((x*0.02) + tt*(0.6 + k*0.12) + k)*amp*Math.cos(k*0.2);
        ctx.lineTo(x,y + k*8);
      }
      ctx.strokeStyle = `rgba(0,240,255,${0.8 - k*0.05})`;
      ctx.lineWidth = 1.8;
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function matrixRainMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const cols = Math.floor(W/14);
  const drops = new Array(cols).fill(0).map(()=>Math.floor(Math.random()*H));
  const letters = '01';
  let running = true;
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(0,0,W,H);
    ctx.font = '14px monospace';
    for(let i=0;i<cols;i++){
      const x = i*14;
      ctx.fillStyle = 'rgba(0,255,140,0.5)';
      const text = letters[Math.floor(Math.random()*letters.length)];
      ctx.fillText(text, x, drops[i]);
      drops[i] += 14 + Math.random()*10;
      if(drops[i] > H + 20) drops[i] = -20*Math.random();
    }
  });
  return { unmount(){ running=false; runner.stop(); } };
}

function hexGridPulseMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const size = 36;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#070708'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    const cols = Math.ceil(W/size)+4;
    for(let x=-cols;x<cols;x++){
      for(let y=-cols;y<cols;y++){
        const px = x*size*0.86 + (y%2? size*0.43:0);
        const py = y*(size*0.75);
        const d = Math.hypot(px,py);
        const pulse = 0.6 + 0.4*Math.sin(d*0.06 - tt*2);
        const a = 0.03 + 0.06*(1-pulse);
        ctx.beginPath();
        ctx.moveTo(px + size*0.5, py);
        for(let k=1;k<6;k++){
          const ang = (Math.PI*2/6)*k;
          ctx.lineTo(px + Math.cos(ang)*size*0.5, py + Math.sin(ang)*size*0.5);
        }
        ctx.closePath();
        ctx.fillStyle = `rgba(0,240,255,${a})`;
        ctx.fill();
      }
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function clockSyncMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let running = true;
  const runner = makeRunner((t)=>{
    ctx.fillStyle = '#010101'; ctx.fillRect(0,0,W,H);
    const now = new Date();
    const s = now.getSeconds(), m = now.getMinutes(), hr = now.getHours()%12;
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.beginPath(); ctx.arc(0,0,220,0,Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.02)'; ctx.fill();
    for(let i=0;i<60;i++){
      const ang = i*(Math.PI*2/60) - Math.PI/2;
      const r1 = 200, r2 = (i%5===0 ? 190 : 194);
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.lineWidth = (i%5===0)?2:1;
      ctx.beginPath();
      ctx.moveTo(Math.cos(ang)*r1, Math.sin(ang)*r1);
      ctx.lineTo(Math.cos(ang)*r2, Math.sin(ang)*r2);
      ctx.stroke();
    }
    const angS = s*(Math.PI*2/60) - Math.PI/2;
    const angM = (m + s/60)*(Math.PI*2/60) - Math.PI/2;
    const angH = (hr + m/60)*(Math.PI*2/12) - Math.PI/2;
    ctx.strokeStyle = 'rgba(176,67,255,0.9)'; ctx.lineWidth=6;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(angH)*110, Math.sin(angH)*110); ctx.stroke();
    ctx.strokeStyle = 'rgba(0,240,255,0.96)'; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(angM)*150, Math.sin(angM)*150); ctx.stroke();
    ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth=1.6;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(angS)*180, Math.sin(angS)*180); ctx.stroke();
    ctx.restore();
  });
  return { unmount(){ running=false; runner.stop(); } };
}

function codeVerseMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const snippets = [
    'function syncBlock(){ /* destiny */ }',
    'const tx = broadcast(wallet.sign(tx))',
    'for await (const block of chain) { /* listen */ }',
    'if (nonce++ > 100) { revive(); }',
    'let entropy = crypto.getRandomValues(new Uint8Array(32))'
  ];
  let lines = new Array(24).fill('');
  const runner = makeRunner((t)=>{
    ctx.fillStyle = '#040405'; ctx.fillRect(0,0,W,H);
    if(Math.random() < 0.35){
      lines.pop();
      lines.unshift(snippets[Math.floor(Math.random()*snippets.length)]);
    }
    ctx.font = '14px "Courier New", monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    for(let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], 22, 60 + i*20);
    }
  });
  return { unmount(){ runner.stop(); } };
}

function aiBloomMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#050507'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let k=0;k<18;k++){
      const ang = (k/18)*Math.PI*2 + tt*0.06;
      const r = 80 + Math.sin(tt*0.9 + k)*80;
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(Math.cos(ang)*r/2, Math.sin(ang)*r/2, r*0.6, ang-0.8, ang+0.8);
      ctx.fillStyle = `rgba(176,67,255,${0.03 + k*0.002})`;
      ctx.fill();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function signatureLoopMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const lines = [];
  for(let i=0;i<6;i++){
    const pts = [];
    for(let j=0;j<30;j++){
      pts.push({x: Math.random()*W, y: Math.random()*H});
    }
    lines.push(pts);
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#020202'; ctx.fillRect(0,0,W,H);
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0;i<lines.length;i++){
      const pts = lines[i];
      ctx.beginPath();
      for(let j=0;j<pts.length;j++){
        const p = pts[j];
        const nx = p.x + Math.sin(tt*0.6 + i + j)*12;
        const ny = p.y + Math.cos(tt*0.4 + i - j)*12;
        if(j===0) ctx.moveTo(nx, ny); else ctx.lineTo(nx, ny);
      }
      ctx.strokeStyle = `rgba(0,240,255,${0.03 + i*0.03})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.globalCompositeOperation = 'source-over';
  });
  return { unmount(){ runner.stop(); } };
}

function neonCityMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const buildings = Array.from({length:20}, ()=>({
    x: Math.random()*W,
    h: 100 + Math.random()*300,
    w: 40 + Math.random()*60,
    color: Math.random() > 0.5 ? 'rgba(255,0,255,0.6)' : 'rgba(0,240,255,0.6)'
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    for(let i=0;i<buildings.length;i++){
      const b = buildings[i];
      const flicker = 0.8 + Math.sin(tt*3 + i)*0.2;
      ctx.fillStyle = b.color.replace('0.6', (0.3*flicker).toString());
      ctx.fillRect(b.x, H-b.h, b.w, b.h);
      ctx.strokeStyle = b.color;
      ctx.lineWidth = 2;
      ctx.strokeRect(b.x, H-b.h, b.w, b.h);
      for(let j=0;j<5;j++){
        if(Math.random() > 0.3){
          ctx.fillStyle = 'rgba(255,255,200,0.4)';
          ctx.fillRect(b.x + 10, H-b.h + 20 + j*40, 10, 10);
        }
      }
    }
    ctx.fillStyle = 'rgba(255,0,255,0.3)';
    ctx.fillRect(0, H-10, W, 10);
  });
  return { unmount(){ runner.stop(); } };
}

function glitchArtMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    if(Math.random() > 0.7){
      const slices = 10 + Math.floor(Math.random()*20);
      for(let i=0;i<slices;i++){
        const y = Math.random()*H;
        const h = 5 + Math.random()*30;
        const offset = (Math.random()-0.5)*50;
        ctx.fillStyle = `rgba(${Math.random()*255},${Math.random()*255},255,0.3)`;
        ctx.fillRect(offset, y, W, h);
      }
    }
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = 'rgba(255,0,0,0.1)';
    ctx.fillRect(W/2 - 100 + Math.sin(tt*2)*10, H/2 - 100, 200, 200);
    ctx.fillStyle = 'rgba(0,255,0,0.1)';
    ctx.fillRect(W/2 - 100, H/2 - 100 + Math.cos(tt*2)*10, 200, 200);
    ctx.fillStyle = 'rgba(0,0,255,0.1)';
    ctx.fillRect(W/2 - 100 - Math.sin(tt*2)*10, H/2 - 100, 200, 200);
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function vaporwaveMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    const grd = ctx.createLinearGradient(0,0,0,H);
    grd.addColorStop(0, '#ff00ff');
    grd.addColorStop(0.5, '#00ffff');
    grd.addColorStop(1, '#000');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H*0.7);
    ctx.rotate(-0.3);
    ctx.strokeStyle = 'rgba(255,0,255,0.3)';
    ctx.lineWidth = 2;
    for(let i=-10;i<=10;i++){
      const y = i*40;
      const scale = 1 + y*0.002;
      ctx.beginPath();
      ctx.moveTo(-W*scale, y);
      ctx.lineTo(W*scale, y);
      ctx.stroke();
    }
    for(let i=-10;i<=10;i++){
      ctx.beginPath();
      ctx.moveTo(i*60, -200);
      ctx.lineTo(i*60*1.5, 400);
      ctx.stroke();
    }
    ctx.restore();
    const sunY = H*0.3 + Math.sin(tt*0.5)*20;
    const grd2 = ctx.createRadialGradient(W/2,sunY,0,W/2,sunY,150);
    grd2.addColorStop(0, 'rgba(255,200,0,0.8)');
    grd2.addColorStop(0.5, 'rgba(255,0,255,0.4)');
    grd2.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grd2;
    ctx.fillRect(0,0,W,H);
  });
  return { unmount(){ runner.stop(); } };
}

function hologramMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<8; i++){
      const r = 50 + i*40 + Math.sin(tt + i)*10;
      const alpha = 0.4 - i*0.04;
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(0,240,255,${alpha})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    for(let i=0; i<12; i++){
      const ang = (i/12)*Math.PI*2 + tt*0.5;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(Math.cos(ang)*300, Math.sin(ang)*300);
      ctx.strokeStyle = `rgba(0,240,255,${0.1 + Math.sin(tt + i)*0.05})`;
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function pixelStormMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const pixels = Array.from({length:200}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    vx: (Math.random()-0.5)*4,
    vy: (Math.random()-0.5)*4,
    size: 4 + Math.random()*8,
    color: `rgb(${Math.random()*255},${Math.random()*255},255)`
  }));
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    for(let i=0;i<pixels.length;i++){
      const p = pixels[i];
      p.x += p.vx;
      p.y += p.vy;
      if(p.x < 0 || p.x > W) p.vx *= -1;
      if(p.y < 0 || p.y > H) p.vy *= -1;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    }
  });
  return { unmount(){ runner.stop(); } };
}

function scanlinesMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = 'rgba(0,255,140,0.2)';
    ctx.lineWidth = 1;
    for(let y=0;y<H;y+=3){
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }
    const scanY = (tt*100) % H;
    ctx.fillStyle = 'rgba(0,255,140,0.3)';
    ctx.fillRect(0, scanY, W, 20);
    ctx.fillStyle = 'rgba(0,240,255,0.2)';
    ctx.fillRect(W/2-150, H/2-150, 300, 300);
    ctx.strokeStyle = 'rgba(0,240,255,0.6)';
    ctx.lineWidth = 2;
    ctx.strokeRect(W/2-150, H/2-150, 300, 300);
  });
  return { unmount(){ runner.stop(); } };
}

function dataStreamMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const streams = Array.from({length:30}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    speed: 1 + Math.random()*3,
    data: Array.from({length:10}, ()=>Math.random().toString(2).substr(2,8))
  }));
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    ctx.font = '12px monospace';
    for(let i=0;i<streams.length;i++){
      const s = streams[i];
      s.y += s.speed;
      if(s.y > H) s.y = -100;
      for(let j=0;j<s.data.length;j++){
        const alpha = 0.8 - j*0.08;
        ctx.fillStyle = `rgba(0,240,255,${alpha})`;
        ctx.fillText(s.data[j], s.x, s.y + j*15);
      }
    }
  });
  return { unmount(){ runner.stop(); } };
}

function particleNebulaMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const particles = Array.from({length:500}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    vx: (Math.random()-0.5)*0.5,
    vy: (Math.random()-0.5)*0.5,
    size: Math.random()*3,
    alpha: Math.random()
  }));
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0;i<particles.length;i++){
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      if(p.x < 0) p.x = W;
      if(p.x > W) p.x = 0;
      if(p.y < 0) p.y = H;
      if(p.y > H) p.y = 0;
      ctx.fillStyle = `rgba(176,67,255,${p.alpha*0.5})`;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    }
    ctx.globalCompositeOperation = 'source-over';
  });
  return { unmount(){ runner.stop(); } };
}

function geometricDanceMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<8; i++){
      ctx.save();
      ctx.rotate((i/8)*Math.PI*2);
      ctx.translate(150 + Math.sin(tt + i)*50, 0);
      ctx.rotate(tt*2);
      const size = 40 + Math.sin(tt*3 + i)*20;
      ctx.strokeStyle = `rgba(0,240,255,${0.4 + Math.sin(tt + i)*0.2})`;
      ctx.lineWidth = 3;
      if(i % 2 === 0){
        ctx.strokeRect(-size/2, -size/2, size, size);
      } else {
        ctx.beginPath();
        ctx.arc(0, 0, size/2, 0, Math.PI*2);
        ctx.stroke();
      }
      ctx.restore();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function synthwaveMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    const grd = ctx.createLinearGradient(0,0,0,H);
    grd.addColorStop(0, '#1a0033');
    grd.addColorStop(0.5, '#330066');
    grd.addColorStop(1, '#000');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H*0.8);
    ctx.scale(1, 0.5);
    ctx.strokeStyle = 'rgba(255,0,255,0.4)';
    ctx.lineWidth = 2;
    for(let i=-15;i<=15;i++){
      const y = i*30 - (tt*50 % 30);
      ctx.beginPath();
      ctx.moveTo(-W, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }
    for(let i=-10;i<=10;i++){
      ctx.beginPath();
      ctx.moveTo(i*60, -300);
      ctx.lineTo(i*60, 300);
      ctx.stroke();
    }
    ctx.restore();
    ctx.fillStyle = 'rgba(255,0,128,0.3)';
    ctx.beginPath();
    ctx.moveTo(0, H*0.6);
    for(let x=0;x<=W;x+=20){
      const y = H*0.6 - Math.sin(x*0.01 + tt)*50 - Math.cos(x*0.02)*30;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(W, H);
    ctx.lineTo(0, H);
    ctx.fill();
  });
  return { unmount(){ runner.stop(); } };
}

function digitalRainMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const cols = Math.floor(W/20);
  const drops = Array.from({length:cols}, ()=>({
    y: Math.random()*H,
    speed: 3 + Math.random()*7,
    chars: Array.from({length:15}, ()=>String.fromCharCode(0x30A0 + Math.random()*96))
  }));
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    ctx.font = '16px monospace';
    for(let i=0;i<cols;i++){
      const d = drops[i];
      d.y += d.speed;
      if(d.y > H + 200) d.y = -200;
      for(let j=0;j<d.chars.length;j++){
        const alpha = 0.8 - j*0.05;
        ctx.fillStyle = `rgba(0,255,140,${alpha})`;
        ctx.fillText(d.chars[j], i*20, d.y + j*20);
      }
    }
  });
  return { unmount(){ runner.stop(); } };
}

function cosmicVoidMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const stars = Array.from({length:200}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    z: Math.random()*1000,
    size: Math.random()*2
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    for(let i=0;i<stars.length;i++){
      const s = stars[i];
      s.z -= 5;
      if(s.z <= 0) s.z = 1000;
      const x = (s.x - W/2) * (1000/s.z) + W/2;
      const y = (s.y - H/2) * (1000/s.z) + H/2;
      const size = s.size * (1000/s.z);
      const alpha = 1 - s.z/1000;
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.fillRect(x, y, size, size);
    }
    const grd = ctx.createRadialGradient(W/2,H/2,0,W/2,H/2,200);
    grd.addColorStop(0, 'rgba(128,0,255,0.3)');
    grd.addColorStop(0.5, 'rgba(0,0,128,0.1)');
    grd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,W,H);
  });
  return { unmount(){ runner.stop(); } };
}

function fractalTreeMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  function drawBranch(x, y, len, angle, depth, t) {
    if(depth === 0) return;
    const x2 = x + Math.cos(angle) * len;
    const y2 = y + Math.sin(angle) * len;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x2, y2);
    const alpha = 0.6 - depth*0.08;
    ctx.strokeStyle = `rgba(0,240,255,${alpha})`;
    ctx.lineWidth = depth;
    ctx.stroke();
    const angleOffset = Math.sin(t + depth)*0.2;
    drawBranch(x2, y2, len*0.7, angle-0.5+angleOffset, depth-1, t);
    drawBranch(x2, y2, len*0.7, angle+0.5+angleOffset, depth-1, t);
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    drawBranch(W/2, H-50, 100, -Math.PI/2, 8, tt);
  });
  return { unmount(){ runner.stop(); } };
}

function waveformMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    for(let layer=0;layer<5;layer++){
      ctx.beginPath();
      for(let x=0;x<=W;x+=5){
        const y = H/2 + 
          Math.sin((x*0.01) + tt*(1 + layer*0.2))*30 +
          Math.cos((x*0.02) + tt*(0.5 + layer*0.1))*20 +
          layer*15;
        if(x===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.strokeStyle = `rgba(0,240,255,${0.5 - layer*0.08})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.fillStyle = 'rgba(176,67,255,0.3)';
    for(let i=0;i<50;i++){
      const h = 50 + Math.sin(tt*3 + i*0.5)*40 + Math.random()*20;
      ctx.fillRect(i*(W/50), H-h, W/50-2, h);
    }
  });
  return { unmount(){ runner.stop(); } };
}

function starfieldMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const stars = Array.from({length:300}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    size: Math.random()*2 + 0.5,
    speed: Math.random()*0.5 + 0.1,
    brightness: Math.random()
  }));
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,5,0.2)'; ctx.fillRect(0,0,W,H);
    for(let i=0;i<stars.length;i++){
      const s = stars[i];
      s.y += s.speed;
      if(s.y > H) {
        s.y = 0;
        s.x = Math.random()*W;
      }
      s.brightness = 0.3 + Math.sin(t*0.001 + i)*0.7;
      ctx.fillStyle = `rgba(255,255,255,${s.brightness})`;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
      ctx.fill();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function cyberpunkGridMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = 'rgba(255,0,255,0.2)';
    ctx.lineWidth = 1;
    const gridSize = 40;
    for(let x=0;x<W;x+=gridSize){
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, H);
      ctx.stroke();
    }
    for(let y=0;y<H;y+=gridSize){
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }
    for(let i=0;i<10;i++){
      const x = ((tt*50 + i*100) % W);
      const y = ((tt*30 + i*80) % H);
      const grd = ctx.createRadialGradient(x,y,0,x,y,60);
      grd.addColorStop(0, 'rgba(0,240,255,0.4)');
      grd.addColorStop(1, 'rgba(0,240,255,0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x-60, y-60, 120, 120);
    }
    ctx.fillStyle = 'rgba(255,0,255,0.2)';
    ctx.fillRect(W/2-100, H/2-100, 200, 200);
    ctx.strokeStyle = 'rgba(0,240,255,0.8)';
    ctx.lineWidth = 3;
    ctx.strokeRect(W/2-100, H/2-100, 200, 200);
  });
  return { unmount(){ runner.stop(); } };
}

function dnaHelixMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    const segments = 40;
    for(let i=0; i<segments; i++){
      const y = -H/3 + (i/segments)*H*0.66;
      const phase = tt*2 + i*0.3;
      const x1 = Math.sin(phase)*W*0.15;
      const x2 = Math.sin(phase + Math.PI)*W*0.15;
      ctx.fillStyle = 'rgba(0,240,255,0.8)';
      ctx.beginPath();
      ctx.arc(x1, y, 8, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = 'rgba(176,67,255,0.8)';
      ctx.beginPath();
      ctx.arc(x2, y, 8, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x1, y);
      ctx.lineTo(x2, y);
      ctx.stroke();
    }
    ctx.strokeStyle = 'rgba(0,240,255,0.4)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    for(let i=0; i<segments; i++){
      const y = -H/3 + (i/segments)*H*0.66;
      const x = Math.sin(tt*2 + i*0.3)*W*0.15;
      if(i===0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.strokeStyle = 'rgba(176,67,255,0.4)';
    ctx.beginPath();
    for(let i=0; i<segments; i++){
      const y = -H/3 + (i/segments)*H*0.66;
      const x = Math.sin(tt*2 + i*0.3 + Math.PI)*W*0.15;
      if(i===0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function liquidMetalMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const blobs = Array.from({length:5}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    vx: (Math.random()-0.5)*2,
    vy: (Math.random()-0.5)*2,
    r: 50 + Math.random()*100
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0; i<blobs.length; i++){
      const b = blobs[i];
      b.x += b.vx;
      b.y += b.vy;
      if(b.x < 0 || b.x > W) b.vx *= -1;
      if(b.y < 0 || b.y > H) b.vy *= -1;
      const grd = ctx.createRadialGradient(b.x,b.y,0,b.x,b.y,b.r);
      grd.addColorStop(0, 'rgba(200,220,255,0.6)');
      grd.addColorStop(0.5, 'rgba(100,150,255,0.3)');
      grd.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grd;
      ctx.fillRect(b.x-b.r, b.y-b.r, b.r*2, b.r*2);
    }
    ctx.globalCompositeOperation = 'source-over';
  });
  return { unmount(){ runner.stop(); } };
}

function quantumEntangleMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const particles = Array.from({length:20}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    vx: (Math.random()-0.5)*3,
    vy: (Math.random()-0.5)*3,
    partner: -1
  }));
  for(let i=0; i<particles.length; i+=2){
    if(i+1 < particles.length){
      particles[i].partner = i+1;
      particles[i+1].partner = i;
    }
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<particles.length; i++){
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      if(p.x < 0 || p.x > W) p.vx *= -1;
      if(p.y < 0 || p.y > H) p.vy *= -1;
      if(p.partner >= 0){
        const p2 = particles[p.partner];
        ctx.strokeStyle = 'rgba(176,67,255,0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }
      const grd = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,15);
      grd.addColorStop(0, 'rgba(0,240,255,0.8)');
      grd.addColorStop(1, 'rgba(0,240,255,0)');
      ctx.fillStyle = grd;
      ctx.fillRect(p.x-15, p.y-15, 30, 30);
    }
  });
  return { unmount(){ runner.stop(); } };
}

function neuralNetMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const nodes = Array.from({length:50}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    vx: (Math.random()-0.5)*0.5,
    vy: (Math.random()-0.5)*0.5
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<nodes.length; i++){
      const n = nodes[i];
      n.x += n.vx;
      n.y += n.vy;
      if(n.x < 0 || n.x > W) n.vx *= -1;
      if(n.y < 0 || n.y > H) n.vy *= -1;
    }
    ctx.strokeStyle = 'rgba(0,240,255,0.2)';
    ctx.lineWidth = 1;
    for(let i=0; i<nodes.length; i++){
      for(let j=i+1; j<nodes.length; j++){
        const dx = nodes[i].x - nodes[j].x;
        const dy = nodes[i].y - nodes[j].y;
        const d = Math.sqrt(dx*dx + dy*dy);
        if(d < 150){
          ctx.beginPath();
          ctx.moveTo(nodes[i].x, nodes[i].y);
          ctx.lineTo(nodes[j].x, nodes[j].y);
          ctx.stroke();
        }
      }
    }
    ctx.fillStyle = 'rgba(176,67,255,0.8)';
    for(let i=0; i<nodes.length; i++){
      ctx.beginPath();
      ctx.arc(nodes[i].x, nodes[i].y, 4, 0, Math.PI*2);
      ctx.fill();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function crystalGrowthMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let layer=0; layer<6; layer++){
      const scale = 1 + layer*0.3 + Math.sin(tt + layer)*0.1;
      ctx.save();
      ctx.scale(scale, scale);
      ctx.rotate(tt*0.2 + layer*0.5);
      ctx.strokeStyle = `rgba(0,240,255,${0.6 - layer*0.08})`;
      ctx.lineWidth = 2;
      for(let i=0; i<6; i++){
        const ang = (i/6)*Math.PI*2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(ang)*100, Math.sin(ang)*100);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(Math.cos(ang)*50, Math.sin(ang)*50);
        ctx.lineTo(Math.cos(ang+Math.PI/6)*70, Math.sin(ang+Math.PI/6)*70);
        ctx.stroke();
      }
      ctx.restore();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function radarScanMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const targets = Array.from({length:15}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    size: 3 + Math.random()*5
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=1; i<=5; i++){
      ctx.beginPath();
      ctx.arc(0, 0, i*H/6, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,255,140,0.3)';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.strokeStyle = 'rgba(0,255,140,0.2)';
    for(let i=0; i<12; i++){
      const ang = (i/12)*Math.PI*2;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(Math.cos(ang)*H/2, Math.sin(ang)*H/2);
      ctx.stroke();
    }
    const scanAngle = tt*2;
    const grd = ctx.createLinearGradient(0,0,Math.cos(scanAngle)*H/2,Math.sin(scanAngle)*H/2);
    grd.addColorStop(0, 'rgba(0,255,140,0.6)');
    grd.addColorStop(0.3, 'rgba(0,255,140,0.3)');
    grd.addColorStop(1, 'rgba(0,255,140,0)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.arc(0, 0, H/2, scanAngle-0.5, scanAngle);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.fillStyle = 'rgba(0,255,140,0.8)';
    for(let i=0; i<targets.length; i++){
      const t = targets[i];
      ctx.beginPath();
      ctx.arc(t.x, t.y, t.size, 0, Math.PI*2);
      ctx.fill();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function energyShieldMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const hexagons = [];
  const hexSize = 30;
  for(let x=-W/2; x<W/2; x+=hexSize*1.5){
    for(let y=-H/2; y<H/2; y+=hexSize*Math.sqrt(3)){
      hexagons.push({
        x: x + (Math.floor(y/(hexSize*Math.sqrt(3)))%2 ? hexSize*0.75 : 0),
        y: y,
        phase: Math.random()*Math.PI*2
      });
    }
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<hexagons.length; i++){
      const h = hexagons[i];
      const d = Math.sqrt(h.x*h.x + h.y*h.y);
      const pulse = Math.sin(tt*2 - d*0.01 + h.phase)*0.5 + 0.5;
      ctx.beginPath();
      for(let j=0; j<6; j++){
        const ang = (j/6)*Math.PI*2;
        const x = h.x + Math.cos(ang)*hexSize*0.5;
        const y = h.y + Math.sin(ang)*hexSize*0.5;
        if(j===0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.strokeStyle = `rgba(0,240,255,${0.2 + pulse*0.4})`;
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function spectrumAnalyzerMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const bars = 64;
  const barHeights = new Array(bars).fill(0);
  const barVels = new Array(bars).fill(0);
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<bars; i++){
      const target = Math.abs(Math.sin(tt*3 + i*0.2))*0.8 + Math.random()*0.2;
      barVels[i] += (target - barHeights[i])*0.1;
      barVels[i] *= 0.9;
      barHeights[i] += barVels[i];
      barHeights[i] = Math.max(0, Math.min(1, barHeights[i]));
    }
    const barWidth = W/bars;
    for(let i=0; i<bars; i++){
      const h = barHeights[i]*H*0.8;
      const hue = (i/bars)*360;
      ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.8)`;
      ctx.fillRect(i*barWidth, H-h, barWidth-2, h);
      const grd = ctx.createLinearGradient(i*barWidth, H-h, i*barWidth, H);
      grd.addColorStop(0, `hsla(${hue}, 80%, 80%, 0.6)`);
      grd.addColorStop(1, `hsla(${hue}, 80%, 40%, 0.6)`);
      ctx.fillStyle = grd;
      ctx.fillRect(i*barWidth, H-h, barWidth-2, h);
    }
  });
  return { unmount(){ runner.stop(); } };
}

function particleExplosionMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const particles = Array.from({length:200}, ()=>({
    ang: Math.random()*Math.PI*2,
    speed: 2 + Math.random()*8,
    life: 1,
    size: 2 + Math.random()*6,
    color: `rgba(${200 + Math.random()*55},${100 + Math.random()*155},0,`
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<particles.length; i++){
      const p = particles[i];
      const r = p.speed*tt*60;
      const x = W/2 + Math.cos(p.ang)*r;
      const y = H/2 + Math.sin(p.ang)*r;
      p.life = Math.max(0, 1 - tt*0.3);
      ctx.fillStyle = p.color + p.life + ')';
      ctx.beginPath();
      ctx.arc(x, y, p.size*p.life, 0, Math.PI*2);
      ctx.fill();
    }
    if(tt > 3){
      t0 = performance.now();
      for(let i=0; i<particles.length; i++){
        particles[i].ang = Math.random()*Math.PI*2;
        particles[i].speed = 2 + Math.random()*8;
        particles[i].life = 1;
      }
    }
  });
  return { unmount(){ runner.stop(); } };
}

function rippleEffectMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const ripples = [];
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    if(Math.random() < 0.05){
      ripples.push({
        x: Math.random()*W,
        y: Math.random()*H,
        r: 0,
        maxR: 100 + Math.random()*200,
        life: 1
      });
    }
    for(let i=ripples.length-1; i>=0; i--){
      const rip = ripples[i];
      rip.r += 3;
      rip.life = 1 - rip.r/rip.maxR;
      if(rip.life <= 0){
        ripples.splice(i, 1);
        continue;
      }
      ctx.beginPath();
      ctx.arc(rip.x, rip.y, rip.r, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(0,240,255,${rip.life*0.6})`;
      ctx.lineWidth = 3;
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function nebulaSwirlMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const particles = Array.from({length:500}, ()=>({
    ang: Math.random()*Math.PI*2,
    r: Math.random()*W*0.4,
    speed: 0.01 + Math.random()*0.02,
    size: 1 + Math.random()*3,
    color: Math.random()
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.02)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0; i<particles.length; i++){
      const p = particles[i];
      p.ang += p.speed;
      const x = Math.cos(p.ang)*p.r;
      const y = Math.sin(p.ang)*p.r;
      const hue = p.color*360;
      ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.6)`;
      ctx.fillRect(x, y, p.size, p.size);
    }
    ctx.globalCompositeOperation = 'source-over';
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function binaryClockMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const runner = makeRunner((t)=>{
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    const now = new Date();
    const h = now.getHours();
    const m = now.getMinutes();
    const s = now.getSeconds();
    const values = [
      Math.floor(h/10), h%10,
      Math.floor(m/10), m%10,
      Math.floor(s/10), s%10
    ];
    ctx.save();
    ctx.translate(W/2 - 150, H/2 - 80);
    for(let col=0; col<6; col++){
      const val = values[col];
      for(let row=0; row<4; row++){
        const bit = (val >> (3-row)) & 1;
        ctx.fillStyle = bit ? 'rgba(0,255,140,0.9)' : 'rgba(255,255,255,0.1)';
        ctx.fillRect(col*50, row*40, 40, 30);
      }
    }
    ctx.restore();
    ctx.font = '20px monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.fillText(`${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`, W/2-60, H/2+120);
  });
  return { unmount(){ runner.stop(); } };
}

function magneticFieldMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    const d = 200;
    ctx.fillStyle = 'rgba(255,0,0,0.8)';
    ctx.beginPath();
    ctx.arc(-d/2, 0, 20, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(0,0,255,0.8)';
    ctx.beginPath();
    ctx.arc(d/2, 0, 20, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(176,67,255,0.4)';
    ctx.lineWidth = 2;
    for(let i=-8; i<=8; i++){
      ctx.beginPath();
      for(let t=0; t<=1; t+=0.02){
        const x = (t-0.5)*W*0.8;
        const y = i*30 + Math.sin(t*Math.PI*2 + tt)*40*Math.exp(-Math.abs(i)*0.1);
        if(t===0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function fiberNetworkMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const nodes = Array.from({length:20}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H
  }));
  const connections = [];
  for(let i=0; i<nodes.length; i++){
    const numConn = 2 + Math.floor(Math.random()*3);
    for(let j=0; j<numConn; j++){
      const target = Math.floor(Math.random()*nodes.length);
      if(target !== i){
        connections.push({from: i, to: target, phase: Math.random()*Math.PI*2});
      }
    }
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<connections.length; i++){
      const c = connections[i];
      const n1 = nodes[c.from];
      const n2 = nodes[c.to];
      const pulse = Math.sin(tt*2 + c.phase)*0.5 + 0.5;
      ctx.strokeStyle = `rgba(0,240,255,${0.2 + pulse*0.4})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(n1.x, n1.y);
      const cx = (n1.x + n2.x)/2 + (Math.random()-0.5)*100;
      const cy = (n1.y + n2.y)/2 + (Math.random()-0.5)*100;
      ctx.quadraticCurveTo(cx, cy, n2.x, n2.y);
      ctx.stroke();
    }
    ctx.fillStyle = 'rgba(0,240,255,0.8)';
    for(let i=0; i<nodes.length; i++){
      ctx.beginPath();
      ctx.arc(nodes[i].x, nodes[i].y, 6, 0, Math.PI*2);
      ctx.fill();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function quantumWaveMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let layer=0; layer<5; layer++){
      ctx.strokeStyle = `rgba(176,67,255,${0.6 - layer*0.1})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      for(let x=-W/2; x<=W/2; x+=5){
        const k = 0.01;
        const omega = 2;
        const y = 80*Math.sin(k*x - omega*tt + layer*0.5)*Math.exp(-Math.abs(x)*0.002);
        if(x===-W/2) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.fillStyle = `rgba(176,67,255,${0.1 - layer*0.02})`;
      ctx.beginPath();
      for(let x=-W/2; x<=W/2; x+=5){
        const k = 0.01;
        const omega = 2;
        const y = 80*Math.sin(k*x - omega*tt + layer*0.5)*Math.exp(-Math.abs(x)*0.002);
        if(x===-W/2) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.lineTo(W/2, 0);
      ctx.lineTo(-W/2, 0);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function cyberEyeMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.beginPath();
    ctx.ellipse(0, 0, 250, 150, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(10,10,20,0.9)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,240,255,0.8)';
    ctx.lineWidth = 3;
    ctx.stroke();
    const irisSize = 80 + Math.sin(tt*2)*20;
    const grd = ctx.createRadialGradient(0,0,0,0,0,irisSize);
    grd.addColorStop(0, 'rgba(0,240,255,0.9)');
    grd.addColorStop(0.3, 'rgba(176,67,255,0.7)');
    grd.addColorStop(0.6, 'rgba(100,30,150,0.5)');
    grd.addColorStop(1, 'rgba(0,0,0,0.8)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(0, 0, irisSize, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(0,0,0,0.9)';
    ctx.beginPath();
    ctx.arc(0, 0, 30, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.beginPath();
    ctx.arc(-10, -10, 12, 0, Math.PI*2);
    ctx.fill();
    for(let i=0; i<12; i++){
      const ang = (i/12)*Math.PI*2 + tt;
      ctx.strokeStyle = 'rgba(0,240,255,0.3)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(Math.cos(ang)*irisSize, Math.sin(ang)*irisSize);
      ctx.lineTo(Math.cos(ang)*30, Math.sin(ang)*30);
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function pulseWaveMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let layer=0; layer<6; layer++){
      ctx.strokeStyle = `rgba(0,240,255,${0.7 - layer*0.1})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      for(let x=-W/2; x<=W/2; x+=8){
        let y = 0;
        const pulseWidth = 150;
        const offset = (tt*200 - layer*50) % W - W/2;
        if(Math.abs(x - offset) < pulseWidth){
          const t = (x - offset)/pulseWidth;
          y = Math.sin(t*Math.PI*4)*100*Math.exp(-Math.abs(t)*2);
        }
        if(x===-W/2) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function mandelbrotSetMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    const zoom = 1 + Math.sin(tt*0.3)*0.5;
    const offsetX = Math.cos(tt*0.2)*0.5;
    const offsetY = Math.sin(tt*0.2)*0.3;
    for(let px=0; px<W; px+=2){
      for(let py=0; py<H; py+=2){
        const x0 = (px - W/2)/(W/4)*zoom/zoom + offsetX;
        const y0 = (py - H/2)/(H/4)*zoom/zoom + offsetY;
        let x = 0, y = 0, iteration = 0;
        const maxIter = 50;
        while(x*x + y*y <= 4 && iteration < maxIter){
          const xtemp = x*x - y*y + x0;
          y = 2*x*y + y0;
          x = xtemp;
          iteration++;
        }
        if(iteration < maxIter){
          const hue = (iteration/maxIter)*360;
          ctx.fillStyle = `hsla(${hue}, 80%, 50%, 0.8)`;
        } else {
          ctx.fillStyle = '#000';
        }
        ctx.fillRect(px, py, 2, 2);
      }
    }
  });
  return { unmount(){ runner.stop(); } };
}

function kaleidoscopeMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    const segments = 12;
    for(let i=0; i<segments; i++){
      ctx.save();
      ctx.rotate((i/segments)*Math.PI*2);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(W/2, 0);
      ctx.lineTo(W/2, H/2);
      ctx.closePath();
      ctx.clip();
      for(let j=0; j<5; j++){
        const x = 50 + j*80 + Math.sin(tt + j)*30;
        const y = 50 + Math.cos(tt*1.5 + j)*50;
        const size = 40 + Math.sin(tt*2 + j)*20;
        const hue = (tt*50 + j*60) % 360;
        ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.6)`;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function laserShowMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const lasers = Array.from({length:12}, (_, i)=>({
    ang: (i/12)*Math.PI*2,
    speed: 0.5 + Math.random()*1,
    color: `hsla(${Math.random()*360}, 80%, 60%, `
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.globalCompositeOperation = 'lighter';
    for(let i=0; i<lasers.length; i++){
      const l = lasers[i];
      l.ang += l.speed*0.02;
      const x = Math.cos(l.ang)*W*0.4;
      const y = Math.sin(l.ang)*H*0.4;
      const grd = ctx.createLinearGradient(0, 0, x, y);
      grd.addColorStop(0, l.color + '0.8)');
      grd.addColorStop(0.5, l.color + '0.4)');
      grd.addColorStop(1, l.color + '0)');
      ctx.strokeStyle = grd;
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(x, y);
      ctx.stroke();
    }
    ctx.globalCompositeOperation = 'source-over';
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function blackHoleMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const particles = Array.from({length:300}, ()=>({
    ang: Math.random()*Math.PI*2,
    r: W*0.3 + Math.random()*W*0.2,
    speed: 0.5 + Math.random()*1.5,
    size: 1 + Math.random()*3
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<particles.length; i++){
      const p = particles[i];
      p.ang += p.speed*0.01;
      p.r -= p.speed*0.5;
      if(p.r < 50){
        p.r = W*0.3 + Math.random()*W*0.2;
        p.ang = Math.random()*Math.PI*2;
      }
      const x = Math.cos(p.ang)*p.r;
      const y = Math.sin(p.ang)*p.r;
      const brightness = 1 - p.r/(W*0.5);
      ctx.fillStyle = `rgba(${100 + brightness*155},${50 + brightness*100},255,${0.6 + brightness*0.4})`;
      ctx.fillRect(x, y, p.size, p.size);
    }
    for(let i=0; i<2; i++){
      ctx.beginPath();
      ctx.arc(0, 0, 30 + i*20, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(176,67,255,${0.4 - i*0.04})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    const grd = ctx.createRadialGradient(0,0,0,0,0,60);
    grd.addColorStop(0, 'rgba(0,0,0,1)');
    grd.addColorStop(0.7, 'rgba(0,0,0,0.8)');
    grd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(0, 0, 60, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function circuitBoardMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const nodes = Array.from({length:30}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    connections: []
  }));
  for(let i=0; i<nodes.length; i++){
    const numConn = 2 + Math.floor(Math.random()*3);
    for(let j=0; j<numConn; j++){
      const target = Math.floor(Math.random()*nodes.length);
      if(target !== i && !nodes[i].connections.includes(target)){
        nodes[i].connections.push(target);
      }
    }
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,10,0,0.05)'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = 'rgba(0,255,140,0.4)';
    ctx.lineWidth = 2;
    for(let i=0; i<nodes.length; i++){
      const n1 = nodes[i];
      for(let j=0; j<n1.connections.length; j++){
        const n2 = nodes[n1.connections[j]];
        const pulse = Math.sin(tt*2 + i + j)*0.5 + 0.5;
        ctx.strokeStyle = `rgba(0,255,140,${0.2 + pulse*0.3})`;
        ctx.beginPath();
        ctx.moveTo(n1.x, n1.y);
        const mx = (n1.x + n2.x)/2;
        const my = (n1.y + n2.y)/2;
        if(Math.abs(n1.x - n2.x) > Math.abs(n1.y - n2.y)){
          ctx.lineTo(mx, n1.y);
          ctx.lineTo(mx, n2.y);
        } else {
          ctx.lineTo(n1.x, my);
          ctx.lineTo(n2.x, my);
        }
        ctx.lineTo(n2.x, n2.y);
        ctx.stroke();
      }
    }
    for(let i=0; i<nodes.length; i++){
      const n = nodes[i];
      const pulse = Math.sin(tt*3 + i)*0.5 + 0.5;
      ctx.fillStyle = `rgba(0,240,255,${0.6 + pulse*0.4})`;
      ctx.beginPath();
      ctx.arc(n.x, n.y, 6, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,255,140,0.8)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function audioVisualizerMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const bars = 128;
  const barHeights = new Array(bars).fill(0);
  const barVels = new Array(bars).fill(0);
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<bars; i++){
      const target = Math.abs(Math.sin(tt*2 + i*0.1))*0.8 + Math.random()*0.2;
      barVels[i] += (target - barHeights[i])*0.1;
      barVels[i] *= 0.9;
      barHeights[i] += barVels[i];
      barHeights[i] = Math.max(0, Math.min(1, barHeights[i]));
    }
    const barWidth = W/bars;
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<bars; i++){
      const h = barHeights[i]*H*0.4;
      const ang = (i/bars)*Math.PI*2;
      const r1 = 100;
      const r2 = r1 + h;
      const x1 = Math.cos(ang)*r1;
      const y1 = Math.sin(ang)*r1;
      const x2 = Math.cos(ang)*r2;
      const y2 = Math.sin(ang)*r2;
      const hue = (i/bars)*360;
      const grd = ctx.createLinearGradient(x1,y1,x2,y2);
      grd.addColorStop(0, `hsla(${hue}, 80%, 60%, 0.8)`);
      grd.addColorStop(1, `hsla(${hue}, 80%, 40%, 0.8)`);
      ctx.strokeStyle = grd;
      ctx.lineWidth = barWidth*0.8;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function timeTunnelMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const rings = Array.from({length:20}, (_, i)=>({
    z: i*50,
    rotation: Math.random()*Math.PI*2
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<rings.length; i++){
      const ring = rings[i];
      ring.z -= 3;
      if(ring.z < 0){
        ring.z = 1000;
        ring.rotation = Math.random()*Math.PI*2;
      }
      const scale = 1000/(ring.z + 1);
      const alpha = Math.min(1, scale*0.5);
      ring.rotation += 0.01;
      ctx.save();
      ctx.rotate(ring.rotation);
      ctx.beginPath();
      ctx.arc(0, 0, 100*scale, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(0,240,255,${alpha*0.6})`;
      ctx.lineWidth = 3*scale;
      ctx.stroke();
      for(let j=0; j<12; j++){
        const ang = (j/12)*Math.PI*2;
        ctx.beginPath();
        ctx.moveTo(Math.cos(ang)*80*scale, Math.sin(ang)*80*scale);
        ctx.lineTo(Math.cos(ang)*120*scale, Math.sin(ang)*120*scale);
        ctx.strokeStyle = `rgba(176,67,255,${alpha*0.4})`;
        ctx.lineWidth = 2*scale;
        ctx.stroke();
      }
      ctx.restore();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function plasmaStormMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    ctx.globalCompositeOperation = 'lighter';
    for(let x=0; x<W; x+=8){
      for(let y=0; y<H; y+=8){
        const v = Math.sin(x*0.02 + tt)*Math.cos(y*0.02 + tt*1.3) +
                  Math.sin(Math.sqrt((x-W/2)**2 + (y-H/2)**2)*0.02 - tt*2);
        const hue = (v*180 + tt*50) % 360;
        const brightness = (v + 2)/4;
        ctx.fillStyle = `hsla(${hue}, 80%, ${brightness*60}%, ${brightness*0.6})`;
        ctx.fillRect(x, y, 8, 8);
      }
    }
    ctx.globalCompositeOperation = 'source-over';
  });
  return { unmount(){ runner.stop(); } };
}


function neonTunnelMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<20; i++){
      const scale = 1 - i*0.05 + Math.sin(tt + i*0.3)*0.02;
      const alpha = 0.6 - i*0.03;
      ctx.save();
      ctx.scale(scale, scale);
      ctx.rotate(tt*0.1 + i*0.1);
      ctx.strokeStyle = `rgba(255,0,255,${alpha})`;
      ctx.lineWidth = 3;
      ctx.strokeRect(-200, -200, 400, 400);
      ctx.restore();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function gravityWellMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const particles = Array.from({length:150}, ()=>({
    angle: Math.random()*Math.PI*2,
    radius: 100 + Math.random()*300,
    speed: 0.5 + Math.random()*1
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<particles.length; i++){
      const p = particles[i];
      p.angle += 0.01 * p.speed;
      p.radius -= 0.3;
      if(p.radius < 20){
        p.radius = 400;
        p.angle = Math.random()*Math.PI*2;
      }
      const x = Math.cos(p.angle) * p.radius;
      const y = Math.sin(p.angle) * p.radius;
      ctx.fillStyle = `rgba(0,240,255,${1 - p.radius/400})`;
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function prismRefractMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    const colors = ['rgba(255,0,0,0.3)', 'rgba(0,255,0,0.3)', 'rgba(0,0,255,0.3)', 
                    'rgba(255,255,0,0.3)', 'rgba(255,0,255,0.3)', 'rgba(0,255,255,0.3)'];
    for(let i=0; i<6; i++){
      ctx.save();
      ctx.rotate((i/6)*Math.PI*2 + tt*0.2);
      ctx.translate(Math.sin(tt + i)*30, 0);
      ctx.fillStyle = colors[i];
      ctx.beginPath();
      ctx.moveTo(0, -150);
      ctx.lineTo(100, 150);
      ctx.lineTo(-100, 150);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function quantumFoamMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const bubbles = Array.from({length:80}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    r: 10 + Math.random()*40,
    speed: 0.2 + Math.random()*0.5,
    phase: Math.random()*Math.PI*2
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<bubbles.length; i++){
      const b = bubbles[i];
      b.y -= b.speed;
      if(b.y < -50) b.y = H + 50;
      const pulse = Math.sin(tt*2 + b.phase)*0.3 + 0.7;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r*pulse, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(0,240,255,${0.3*pulse})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function cyberRainMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const drops = Array.from({length:100}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    speed: 2 + Math.random()*5,
    len: 20 + Math.random()*40
  }));
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<drops.length; i++){
      const d = drops[i];
      d.y += d.speed;
      if(d.y > H + 50){
        d.y = -50;
        d.x = Math.random()*W;
      }
      const grd = ctx.createLinearGradient(d.x, d.y-d.len, d.x, d.y);
      grd.addColorStop(0, 'rgba(0,240,255,0)');
      grd.addColorStop(1, 'rgba(0,240,255,0.8)');
      ctx.strokeStyle = grd;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(d.x, d.y-d.len);
      ctx.lineTo(d.x, d.y);
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function spiralMatrixMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<200; i++){
      const angle = i*0.3 + tt;
      const radius = i*2;
      const x = Math.cos(angle)*radius;
      const y = Math.sin(angle)*radius;
      const alpha = 1 - i/200;
      ctx.fillStyle = `rgba(176,67,255,${alpha*0.6})`;
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function energyVortexMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.08)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<12; i++){
      const angle = (i/12)*Math.PI*2 + tt;
      ctx.save();
      ctx.rotate(angle);
      for(let j=0; j<10; j++){
        const r = j*30 + Math.sin(tt*2 + j)*10;
        const alpha = 0.5 - j*0.04;
        ctx.strokeStyle = `rgba(255,0,255,${alpha})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI/3);
        ctx.stroke();
      }
      ctx.restore();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function digitalHorizonMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    const grd = ctx.createLinearGradient(0,0,0,H);
    grd.addColorStop(0, '#000033');
    grd.addColorStop(0.5, '#000066');
    grd.addColorStop(1, '#000000');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = 'rgba(0,240,255,0.4)';
    ctx.lineWidth = 2;
    for(let i=0; i<20; i++){
      const y = H*0.6 + i*10;
      ctx.beginPath();
      ctx.moveTo(0, y);
      for(let x=0; x<=W; x+=20){
        const wave = Math.sin((x*0.01) + tt + i*0.2)*5;
        ctx.lineTo(x, y + wave);
      }
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function particleSwarmMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const particles = Array.from({length:200}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    vx: (Math.random()-0.5)*2,
    vy: (Math.random()-0.5)*2
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    const centerX = W/2 + Math.cos(tt)*100;
    const centerY = H/2 + Math.sin(tt)*100;
    for(let i=0; i<particles.length; i++){
      const p = particles[i];
      const dx = centerX - p.x;
      const dy = centerY - p.y;
      p.vx += dx*0.0001;
      p.vy += dy*0.0001;
      p.x += p.vx;
      p.y += p.vy;
      if(p.x < 0 || p.x > W) p.vx *= -0.5;
      if(p.y < 0 || p.y > H) p.vy *= -0.5;
      ctx.fillStyle = 'rgba(0,240,255,0.6)';
      ctx.beginPath();
      ctx.arc(p.x, p.y, 2, 0, Math.PI*2);
      ctx.fill();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function neonPulseMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<8; i++){
      const pulse = Math.sin(tt*2 - i*0.5)*0.5 + 0.5;
      const r = 50 + i*40 + pulse*20;
      const alpha = 0.6 - i*0.06;
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(255,0,255,${alpha*pulse})`;
      ctx.lineWidth = 4;
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function fractalZoomMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    const zoom = 1 + Math.sin(tt)*0.3;
    ctx.scale(zoom, zoom);
    ctx.rotate(tt*0.1);
    for(let i=0; i<5; i++){
      const scale = Math.pow(0.6, i);
      ctx.save();
      ctx.scale(scale, scale);
      ctx.strokeStyle = `rgba(0,240,255,${0.6 - i*0.1})`;
      ctx.lineWidth = 3/scale;
      ctx.strokeRect(-200, -200, 400, 400);
      ctx.beginPath();
      ctx.moveTo(-200, 0);
      ctx.lineTo(200, 0);
      ctx.moveTo(0, -200);
      ctx.lineTo(0, 200);
      ctx.stroke();
      ctx.restore();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function laserGridMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = 'rgba(255,0,0,0.6)';
    ctx.lineWidth = 2;
    const spacing = 50;
    for(let x=0; x<W; x+=spacing){
      const offset = Math.sin(tt + x*0.01)*10;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x + offset, H);
      ctx.stroke();
    }
    for(let y=0; y<H; y+=spacing){
      const offset = Math.cos(tt + y*0.01)*10;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y + offset);
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function quantumTunnelMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<30; i++){
      const z = i/30;
      const scale = z + Math.sin(tt + i*0.2)*0.05;
      const alpha = 1 - z;
      ctx.save();
      ctx.scale(scale, scale);
      ctx.rotate(tt*0.5 + i*0.1);
      ctx.strokeStyle = `rgba(176,67,255,${alpha*0.5})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0, 0, 200, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function cyberWavesMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    for(let layer=0; layer<8; layer++){
      ctx.beginPath();
      for(let x=0; x<=W; x+=5){
        const y = H/2 + layer*30 + 
          Math.sin((x*0.01) + tt*(1 + layer*0.1))*40 +
          Math.cos((x*0.02) - tt*(0.5 + layer*0.05))*20;
        if(x===0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = `rgba(0,240,255,${0.6 - layer*0.06})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function plasmaRingsMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<10; i++){
      const r = 50 + i*40;
      const hue = (tt*50 + i*36) % 360;
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI*2);
      ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${0.5 - i*0.04})`;
      ctx.lineWidth = 8;
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function digitalWaterfallMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const cols = Math.floor(W/10);
  const drops = new Array(cols).fill(0).map(()=>({
    y: Math.random()*H,
    speed: 2 + Math.random()*3
  }));
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<cols; i++){
      const d = drops[i];
      const x = i*10;
      ctx.fillStyle = `rgba(0,240,255,${0.6 + Math.random()*0.4})`;
      ctx.fillRect(x, d.y, 8, 20);
      d.y += d.speed;
      if(d.y > H) d.y = -20;
    }
  });
  return { unmount(){ runner.stop(); } };
}

function neonSpiralMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.beginPath();
    for(let i=0; i<300; i++){
      const angle = i*0.1 + tt;
      const radius = i*1.5;
      const x = Math.cos(angle)*radius;
      const y = Math.sin(angle)*radius;
      if(i===0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.strokeStyle = 'rgba(255,0,255,0.6)';
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function energyBurstMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    const burst = Math.sin(tt*2)*0.5 + 0.5;
    for(let i=0; i<24; i++){
      const angle = (i/24)*Math.PI*2;
      const len = 100 + burst*150;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(Math.cos(angle)*len, Math.sin(angle)*len);
      ctx.strokeStyle = `rgba(255,200,0,${0.6*burst})`;
      ctx.lineWidth = 3;
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function particleTrailsMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const particles = Array.from({length:50}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    vx: (Math.random()-0.5)*3,
    vy: (Math.random()-0.5)*3,
    trail: []
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<particles.length; i++){
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      if(p.x < 0 || p.x > W) p.vx *= -1;
      if(p.y < 0 || p.y > H) p.vy *= -1;
      p.trail.push({x: p.x, y: p.y});
      if(p.trail.length > 20) p.trail.shift();
      for(let j=0; j<p.trail.length-1; j++){
        const alpha = j/p.trail.length;
        ctx.strokeStyle = `rgba(0,240,255,${alpha*0.6})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p.trail[j].x, p.trail[j].y);
        ctx.lineTo(p.trail[j+1].x, p.trail[j+1].y);
        ctx.stroke();
      }
    }
  });
  return { unmount(){ runner.stop(); } };
}

function cyberBloomMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<12; i++){
      const angle = (i/12)*Math.PI*2 + tt*0.5;
      const len = 100 + Math.sin(tt*2 + i)*50;
      ctx.save();
      ctx.rotate(angle);
      for(let j=0; j<5; j++){
        const scale = 1 - j*0.15;
        ctx.fillStyle = `rgba(255,0,255,${0.4 - j*0.06})`;
        ctx.beginPath();
        ctx.ellipse(len, 0, 30*scale, 60*scale, 0, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function quantumRipplesMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const ripples = [];
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    if(Math.random() < 0.02){
      ripples.push({x: Math.random()*W, y: Math.random()*H, r: 0, age: 0});
    }
    for(let i=ripples.length-1; i>=0; i--){
      const rip = ripples[i];
      rip.r += 2;
      rip.age += 0.016;
      if(rip.age > 2) {
        ripples.splice(i, 1);
        continue;
      }
      const alpha = 1 - rip.age/2;
      ctx.beginPath();
      ctx.arc(rip.x, rip.y, rip.r, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(0,240,255,${alpha*0.6})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function laserBeamsMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const beams = Array.from({length:12}, (_, i)=>({
    angle: (i/12)*Math.PI*2,
    speed: 0.5 + Math.random()*0.5
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<beams.length; i++){
      const b = beams[i];
      b.angle += 0.01*b.speed;
      const x = Math.cos(b.angle)*500;
      const y = Math.sin(b.angle)*500;
      const grd = ctx.createLinearGradient(0, 0, x, y);
      grd.addColorStop(0, 'rgba(255,0,0,0.6)');
      grd.addColorStop(1, 'rgba(255,0,0,0)');
      ctx.strokeStyle = grd;
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(x, y);
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function digitalSmokeMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const particles = Array.from({length:100}, ()=>({
    x: W/2 + (Math.random()-0.5)*50,
    y: H,
    vx: (Math.random()-0.5)*2,
    vy: -1 - Math.random()*2,
    size: 10 + Math.random()*20,
    alpha: 0.6
  }));
  const runner = makeRunner((t)=>{
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<particles.length; i++){
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.alpha -= 0.005;
      p.size += 0.2;
      if(p.alpha <= 0 || p.y < -50){
        p.x = W/2 + (Math.random()-0.5)*50;
        p.y = H;
        p.alpha = 0.6;
        p.size = 10 + Math.random()*20;
      }
      ctx.fillStyle = `rgba(0,240,255,${p.alpha*0.3})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fill();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function neonRingsMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<15; i++){
      const r = 50 + i*30;
      const rotation = tt*0.5 + i*0.3;
      ctx.save();
      ctx.rotate(rotation);
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI);
      ctx.strokeStyle = `rgba(255,0,255,${0.6 - i*0.03})`;
      ctx.lineWidth = 4;
      ctx.stroke();
      ctx.restore();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function energyWebMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const nodes = Array.from({length:30}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = 'rgba(255,200,0,0.3)';
    ctx.lineWidth = 1;
    for(let i=0; i<nodes.length; i++){
      for(let j=i+1; j<nodes.length; j++){
        const dx = nodes[i].x - nodes[j].x;
        const dy = nodes[i].y - nodes[j].y;
        const d = Math.sqrt(dx*dx + dy*dy);
        if(d < 200){
          ctx.beginPath();
          ctx.moveTo(nodes[i].x, nodes[i].y);
          ctx.lineTo(nodes[j].x, nodes[j].y);
          ctx.stroke();
        }
      }
    }
    for(let i=0; i<nodes.length; i++){
      const n = nodes[i];
      n.x += Math.sin(tt + i)*0.5;
      n.y += Math.cos(tt + i*0.5)*0.5;
      ctx.fillStyle = 'rgba(255,200,0,0.8)';
      ctx.beginPath();
      ctx.arc(n.x, n.y, 4, 0, Math.PI*2);
      ctx.fill();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function particleDanceMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const particles = Array.from({length:100}, (_, i)=>({
    angle: (i/100)*Math.PI*2,
    radius: 100 + Math.random()*100,
    speed: 0.5 + Math.random()*0.5
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<particles.length; i++){
      const p = particles[i];
      p.angle += 0.01*p.speed;
      const x = Math.cos(p.angle)*p.radius;
      const y = Math.sin(p.angle)*p.radius;
      ctx.fillStyle = `rgba(176,67,255,${0.6 + Math.sin(tt + i)*0.3})`;
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function cyberPulseMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    const pulse = Math.sin(tt*3)*0.5 + 0.5;
    ctx.save();
    ctx.translate(W/2, H/2);
    const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, 200*pulse);
    grd.addColorStop(0, `rgba(0,240,255,${0.6*pulse})`);
    grd.addColorStop(1, 'rgba(0,240,255,0)');
    ctx.fillStyle = grd;
    ctx.fillRect(-W/2, -H/2, W, H);
    for(let i=0; i<6; i++){
      const r = 50 + i*50 + pulse*30;
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(0,240,255,${(0.6 - i*0.08)*pulse})`;
      ctx.lineWidth = 3;
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function quantumStringsMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const strings = Array.from({length:20}, (_, i)=>({
    y: (i/20)*H,
    phase: Math.random()*Math.PI*2
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<strings.length; i++){
      const s = strings[i];
      ctx.beginPath();
      for(let x=0; x<=W; x+=5){
        const y = s.y + Math.sin((x*0.02) + tt + s.phase)*30;
        if(x===0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = `rgba(176,67,255,${0.5 - i*0.02})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function laserSpiralMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.rotate(tt*0.5);
    for(let i=0; i<3; i++){
      ctx.save();
      ctx.rotate((i/3)*Math.PI*2);
      ctx.beginPath();
      for(let j=0; j<100; j++){
        const angle = j*0.1;
        const radius = j*2;
        const x = Math.cos(angle)*radius;
        const y = Math.sin(angle)*radius;
        if(j===0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = `rgba(255,0,0,${0.6 - i*0.15})`;
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.restore();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function digitalAuroraMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,10,0.05)'; ctx.fillRect(0,0,W,H);
    for(let layer=0; layer<5; layer++){
      ctx.beginPath();
      for(let x=0; x<=W; x+=10){
        const y = H*0.4 + layer*30 + 
          Math.sin((x*0.008) + tt*1.5 + layer)*70 +
          Math.cos((x*0.012) - tt + layer*0.5)*50;
        if(x===0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      const hue = (tt*30 + layer*60) % 360;
      ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${0.4 - layer*0.05})`;
      ctx.lineWidth = 3;
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function neonWavesMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<10; i++){
      ctx.beginPath();
      for(let x=0; x<=W; x+=5){
        const y = H/2 + i*20 + Math.sin((x*0.01) + tt + i*0.5)*30;
        if(x===0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = `rgba(255,0,255,${0.6 - i*0.05})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function energySphereMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    const pulse = Math.sin(tt*2)*0.3 + 0.7;
    const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, 150*pulse);
    grd.addColorStop(0, `rgba(255,200,0,${0.8*pulse})`);
    grd.addColorStop(0.5, `rgba(255,100,0,${0.4*pulse})`);
    grd.addColorStop(1, 'rgba(255,0,0,0)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(0, 0, 150*pulse, 0, Math.PI*2);
    ctx.fill();
    for(let i=0; i<8; i++){
      const angle = (i/8)*Math.PI*2 + tt;
      const x = Math.cos(angle)*100*pulse;
      const y = Math.sin(angle)*100*pulse;
      ctx.fillStyle = 'rgba(255,255,0,0.6)';
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function particleFountainMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const particles = [];
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    if(Math.random() < 0.3){
      particles.push({
        x: W/2,
        y: H,
        vx: (Math.random()-0.5)*5,
        vy: -5 - Math.random()*5,
        life: 1
      });
    }
    for(let i=particles.length-1; i>=0; i--){
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.1;
      p.life -= 0.01;
      if(p.life <= 0){
        particles.splice(i, 1);
        continue;
      }
      ctx.fillStyle = `rgba(0,240,255,${p.life*0.6})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
      ctx.fill();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function cyberVortexMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<100; i++){
      const angle = i*0.2 + tt*2;
      const radius = i*2.5;
      const x = Math.cos(angle)*radius;
      const y = Math.sin(angle)*radius;
      const alpha = 1 - i/100;
      ctx.fillStyle = `rgba(0,240,255,${alpha*0.6})`;
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function quantumGridMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    const spacing = 40;
    ctx.strokeStyle = 'rgba(176,67,255,0.8)';
    ctx.lineWidth = 1;
    for(let x=0; x<W; x+=spacing){
      for(let y=0; y<H; y+=spacing){
        const wave = Math.sin(tt + x*0.01 + y*0.01)*10;
        ctx.beginPath();
        ctx.arc(x, y + wave, 3, 0, Math.PI*2);
        ctx.stroke();
      }
    }
  });
  return { unmount(){ runner.stop(); } };
}

function laserPulseMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    const pulse = Math.sin(tt*4)*0.5 + 0.5;
    for(let i=0; i<16; i++){
      const angle = (i/16)*Math.PI*2;
      const len = 50 + pulse*200;
      const x = Math.cos(angle)*len;
      const y = Math.sin(angle)*len;
      ctx.fillStyle = `rgba(255,0,0,${0.6*pulse})`;
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function digitalNebulaMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const particles = Array.from({length:300}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    size: Math.random()*3,
    speed: 0.1 + Math.random()*0.3
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,10,0.05)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<particles.length; i++){
      const p = particles[i];
      p.x += Math.sin(tt + i)*p.speed;
      p.y += Math.cos(tt + i*0.5)*p.speed;
      if(p.x < 0) p.x = W;
      if(p.x > W) p.x = 0;
      if(p.y < 0) p.y = H;
      if(p.y > H) p.y = 0;
      const hue = (tt*20 + i) % 360;
      ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.6)`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fill();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function neonMatrixMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    const spacing = 30;
    ctx.strokeStyle = 'rgba(255,0,255,0.4)';
    ctx.lineWidth = 2;
    for(let x=0; x<W; x+=spacing){
      const offset = Math.sin(tt + x*0.01)*20;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x + offset, H);
      ctx.stroke();
    }
    for(let y=0; y<H; y+=spacing){
      const offset = Math.cos(tt + y*0.01)*20;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y + offset);
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function energyFlowMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<5; i++){
      ctx.beginPath();
      for(let x=0; x<=W; x+=5){
        const y = H/2 + i*50 + 
          Math.sin((x*0.01) + tt*2 + i)*40 +
          Math.cos((x*0.02) - tt + i)*30;
        if(x===0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = `rgba(255,200,0,${0.6 - i*0.1})`;
      ctx.lineWidth = 3;
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function particleStormMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const particles = Array.from({length:200}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    vx: (Math.random()-0.5)*5,
    vy: (Math.random()-0.5)*5,
    size: 1 + Math.random()*3
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<particles.length; i++){
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      if(p.x < 0 || p.x > W) p.vx *= -1;
      if(p.y < 0 || p.y > H) p.vy *= -1;
      ctx.fillStyle = 'rgba(176,67,255,0.6)';
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fill();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function cyberSphereMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let lat=-90; lat<=90; lat+=15){
      ctx.beginPath();
      for(let lon=0; lon<=360; lon+=5){
        const latRad = lat*Math.PI/180;
        const lonRad = (lon + tt*30)*Math.PI/180;
        const r = 150;
        const x = Math.cos(latRad)*Math.cos(lonRad)*r;
        const y = Math.cos(latRad)*Math.sin(lonRad)*r;
        if(lon===0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = 'rgba(0,240,255,0.4)';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function quantumBurstMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    const burst = (Math.sin(tt*3) + 1)/2;
    for(let i=0; i<32; i++){
      const angle = (i/32)*Math.PI*2;
      const len = 50 + burst*200;
      const x = Math.cos(angle)*len;
      const y = Math.sin(angle)*len;
      ctx.fillStyle = `rgba(176,67,255,${0.6*burst})`;
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function laserWebMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const nodes = Array.from({length:20}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    vx: (Math.random()-0.5)*0.5,
    vy: (Math.random()-0.5)*0.5
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<nodes.length; i++){
      const n = nodes[i];
      n.x += n.vx;
      n.y += n.vy;
      if(n.x < 0 || n.x > W) n.vx *= -1;
      if(n.y < 0 || n.y > H) n.vy *= -1;
    }
    ctx.strokeStyle = 'rgba(255,0,0,0.3)';
    ctx.lineWidth = 1;
    for(let i=0; i<nodes.length; i++){
      for(let j=i+1; j<nodes.length; j++){
        const dx = nodes[i].x - nodes[j].x;
        const dy = nodes[i].y - nodes[j].y;
        const d = Math.sqrt(dx*dx + dy*dy);
        if(d < 150){
          ctx.beginPath();
          ctx.moveTo(nodes[i].x, nodes[i].y);
          ctx.lineTo(nodes[j].x, nodes[j].y);
          ctx.stroke();
        }
      }
    }
    for(let i=0; i<nodes.length; i++){
      ctx.fillStyle = 'rgba(255,0,0,0.8)';
      ctx.beginPath();
      ctx.arc(nodes[i].x, nodes[i].y, 4, 0, Math.PI*2);
      ctx.fill();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function digitalVortexMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<150; i++){
      const angle = i*0.15 + tt*3;
      const radius = i*2.5;
      const x = Math.cos(angle)*radius;
      const y = Math.sin(angle)*radius;
      const alpha = 1 - i/150;
      ctx.fillStyle = `rgba(0,240,255,${alpha*0.6})`;
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function neonFlowMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<8; i++){
      ctx.beginPath();
      for(let x=0; x<=W; x+=5){
        const y = H/2 + i*30 + 
          Math.sin((x*0.01) + tt*1.5 + i)*50;
        if(x===0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = `rgba(255,0,255,${0.6 - i*0.06})`;
      ctx.lineWidth = 3;
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function energyRingsMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.save();
    ctx.translate(W/2, H/2);
    for(let i=0; i<12; i++){
      const r = 40 + i*35;
      const pulse = Math.sin(tt*2 - i*0.3)*0.3 + 0.7;
      ctx.beginPath();
      ctx.arc(0, 0, r*pulse, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(255,200,0,${(0.6 - i*0.04)*pulse})`;
      ctx.lineWidth = 4;
      ctx.stroke();
    }
    ctx.restore();
  });
  return { unmount(){ runner.stop(); } };
}

function particleWebMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const particles = Array.from({length:40}, ()=>({
    x: Math.random()*W,
    y: Math.random()*H,
    vx: (Math.random()-0.5)*0.3,
    vy: (Math.random()-0.5)*0.3
  }));
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    for(let i=0; i<particles.length; i++){
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      if(p.x < 0 || p.x > W) p.vx *= -1;
      if(p.y < 0 || p.y > H) p.vy *= -1;
    }
    ctx.strokeStyle = 'rgba(176,67,255,0.2)';
    ctx.lineWidth = 1;
    for(let i=0; i<particles.length; i++){
      for(let j=i+1; j<particles.length; j++){
        const dx = particles[i].x - particles[j].x;
        const dy = particles[i].y - particles[j].y;
        const d = Math.sqrt(dx*dx + dy*dy);
        if(d < 180){
          ctx.beginPath();
          ctx.moveTo(particles[i].x, particles[i].y);
          ctx.lineTo(particles[j].x, particles[j].y);
          ctx.stroke();
        }
      }
    }
    for(let i=0; i<particles.length; i++){
      ctx.fillStyle = 'rgba(176,67,255,0.8)';
      ctx.beginPath();
      ctx.arc(particles[i].x, particles[i].y, 4, 0, Math.PI*2);
      ctx.fill();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function cyberAuroraMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = 'rgba(0,0,0,0.05)'; ctx.fillRect(0,0,W,H);
    for(let layer=0; layer<6; layer++){
      ctx.beginPath();
      for(let x=0; x<=W; x+=10){
        const y = H*0.4 + layer*30 + 
          Math.sin((x*0.008) + tt*1.5 + layer)*70 +
          Math.cos((x*0.012) - tt + layer*0.5)*50;
        if(x===0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      const colors = ['rgba(0,240,255,', 'rgba(176,67,255,', 'rgba(255,0,255,'];
      const color = colors[layer % 3];
      ctx.strokeStyle = color + (0.5 - layer*0.06) + ')';
      ctx.lineWidth = 3;
      ctx.stroke();
    }
  });
  return { unmount(){ runner.stop(); } };
}

function fractalFernMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  function drawFern(x, y, len, angle, depth, t) {
    if(depth === 0 || len < 1) return;
    const x2 = x + Math.cos(angle) * len;
    const y2 = y + Math.sin(angle) * len;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x2, y2);
    const alpha = 0.5 - depth*0.05;
    ctx.strokeStyle = `rgba(50,255,100,${alpha})`;
    ctx.lineWidth = depth*0.5;
    ctx.stroke();
    const offset = Math.sin(t + depth)*0.15;
    drawFern(x2, y2, len*0.8, angle-0.3+offset, depth-1, t);
    drawFern(x2, y2, len*0.6, angle+0.5+offset, depth-1, t);
    drawFern(x2, y2, len*0.5, angle+offset, depth-1, t);
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    drawFern(W/2, H-50, 120, -Math.PI/2, 9, tt);
  });
  return { unmount(){ runner.stop(); } };
}

function fractalSnowflakeMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  function drawKoch(x1, y1, x2, y2, depth) {
    if(depth === 0){
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      return;
    }
    const dx = (x2-x1)/3, dy = (y2-y1)/3;
    const x3 = x1+dx, y3 = y1+dy;
    const x4 = x1+2*dx, y4 = y1+2*dy;
    const x5 = x3+dx*0.5-dy*Math.sqrt(3)/2;
    const y5 = y3+dy*0.5+dx*Math.sqrt(3)/2;
    drawKoch(x1,y1,x3,y3,depth-1);
    drawKoch(x3,y3,x5,y5,depth-1);
    drawKoch(x5,y5,x4,y4,depth-1);
    drawKoch(x4,y4,x2,y2,depth-1);
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = `rgba(100,200,255,${0.6+Math.sin(tt)*0.2})`;
    ctx.lineWidth = 2;
    const cx = W/2, cy = H/2, r = 200 + Math.sin(tt)*20;
    for(let i=0;i<3;i++){
      const a1 = i*Math.PI*2/3-Math.PI/2+tt*0.1;
      const a2 = (i+1)*Math.PI*2/3-Math.PI/2+tt*0.1;
      drawKoch(cx+Math.cos(a1)*r, cy+Math.sin(a1)*r, cx+Math.cos(a2)*r, cy+Math.sin(a2)*r, 4);
    }
  });
  return { unmount(){ runner.stop(); } };
}

function fractalDragonMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    let seq = [1];
    for(let i=0;i<12;i++){
      seq = [...seq, 1, ...seq.reverse().map(x=>-x)];
    }
    let x = W/2-100, y = H/2;
    let angle = tt*0.5;
    ctx.strokeStyle = `rgba(255,100,150,0.6)`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x, y);
    seq.forEach(turn=>{
      angle += turn*Math.PI/2;
      x += Math.cos(angle)*1.5;
      y += Math.sin(angle)*1.5;
      ctx.lineTo(x, y);
    });
    ctx.stroke();
  });
  return { unmount(){ runner.stop(); } };
}

function fractalSpiralMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  function drawSpiral(x, y, r, angle, depth, t) {
    if(depth === 0 || r < 1) return;
    const x2 = x + Math.cos(angle) * r;
    const y2 = y + Math.sin(angle) * r;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x2, y2);
    const alpha = 0.6 - depth*0.02;
    ctx.strokeStyle = `rgba(255,200,0,${alpha})`;
    ctx.lineWidth = 3;
    ctx.stroke();
    drawSpiral(x2, y2, r*0.85, angle+0.5+Math.sin(t)*0.1, depth-1, t);
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    drawSpiral(W/2, H/2, 200, tt, 30, tt);
  });
  return { unmount(){ runner.stop(); } };
}

function fractalTriangleMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  function drawSierpinski(x, y, size, depth) {
    if(depth === 0){
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x+size, y);
      ctx.lineTo(x+size/2, y-size*Math.sqrt(3)/2);
      ctx.fill();
      return;
    }
    const half = size/2;
    drawSierpinski(x, y, half, depth-1);
    drawSierpinski(x+half, y, half, depth-1);
    drawSierpinski(x+half/2, y-half*Math.sqrt(3)/2, half, depth-1);
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    const hue = (tt*30)%360;
    ctx.fillStyle = `hsla(${hue},80%,60%,0.6)`;
    const size = 400 + Math.sin(tt)*50;
    drawSierpinski(W/2-size/2, H/2+size*Math.sqrt(3)/4, size, 6);
  });
  return { unmount(){ runner.stop(); } };
}

function fractalBranchMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  function drawBranch(x, y, len, angle, depth, t) {
    if(depth === 0) return;
    const x2 = x + Math.cos(angle) * len;
    const y2 = y + Math.sin(angle) * len;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x2, y2);
    ctx.lineWidth = depth;
    const alpha = 0.6 - depth*0.06;
    ctx.strokeStyle = `rgba(150,255,150,${alpha})`;
    ctx.stroke();
    const offset = Math.sin(t + depth)*0.2;
    drawBranch(x2, y2, len*0.75, angle-0.4+offset, depth-1, t);
    drawBranch(x2, y2, len*0.75, angle+0.4+offset, depth-1, t);
    drawBranch(x2, y2, len*0.6, angle+offset*0.5, depth-1, t);
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    drawBranch(W/2, H-50, 120, -Math.PI/2, 9, tt);
  });
  return { unmount(){ runner.stop(); } };
}

function fractalLightningMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  function drawLightning(x1, y1, x2, y2, depth, seed) {
    if(depth === 0){
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      return;
    }
    const mx = (x1+x2)/2 + (Math.sin(seed)*0.5-0.25)*80;
    const my = (y1+y2)/2 + (Math.cos(seed)*0.5-0.25)*80;
    drawLightning(x1, y1, mx, my, depth-1, seed*1.3);
    drawLightning(mx, my, x2, y2, depth-1, seed*1.7);
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = `rgba(150,200,255,${0.7+Math.sin(tt*5)*0.3})`;
    ctx.lineWidth = 3;
    for(let i=0;i<3;i++){
      drawLightning(W/2+i*50-50, 50, W/2+i*50-50, H-50, 6, tt+i);
    }
  });
  return { unmount(){ runner.stop(); } };
}

function fractalVineMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  function drawVine(x, y, len, angle, depth, t) {
    if(depth === 0) return;
    const x2 = x + Math.cos(angle) * len;
    const y2 = y + Math.sin(angle) * len;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x2, y2);
    ctx.lineWidth = depth*0.8;
    const alpha = 0.6 - depth*0.05;
    ctx.strokeStyle = `rgba(100,255,150,${alpha})`;
    ctx.stroke();
    const offset = Math.sin(t + depth)*0.2;
    drawVine(x2, y2, len*0.8, angle-0.6+offset, depth-1, t);
    drawVine(x2, y2, len*0.7, angle+0.3+offset, depth-1, t);
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    drawVine(100, H/2, 100, 0+Math.sin(tt)*0.3, 10, tt);
  });
  return { unmount(){ runner.stop(); } };
}

function fractalCrystalMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  function drawCrystal(x, y, r, angle, depth, t) {
    if(depth === 0 || r < 2) return;
    for(let i=0;i<6;i++){
      const a = angle + i*Math.PI/3 + Math.sin(t)*0.1;
      const x2 = x + Math.cos(a) * r;
      const y2 = y + Math.sin(a) * r;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x2, y2);
      const alpha = 0.5 - depth*0.1;
      ctx.strokeStyle = `rgba(150,220,255,${alpha})`;
      ctx.lineWidth = depth;
      ctx.stroke();
      drawCrystal(x2, y2, r*0.5, a, depth-1, t);
    }
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    drawCrystal(W/2, H/2, 120, tt*0.5, 4, tt);
  });
  return { unmount(){ runner.stop(); } };
}

function fractalWebMount(canvas){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  let t0 = performance.now();
  function drawWeb(x, y, r, depth, t) {
    if(depth === 0 || r < 3) return;
    for(let i=0;i<8;i++){
      const a = i*Math.PI/4 + Math.sin(t)*0.1;
      const x2 = x + Math.cos(a) * r;
      const y2 = y + Math.sin(a) * r;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x2, y2);
      const alpha = 0.5 - depth*0.08;
      ctx.strokeStyle = `rgba(200,200,255,${alpha})`;
      ctx.lineWidth = depth*0.5;
      ctx.stroke();
      drawWeb(x2, y2, r*0.6, depth-1, t);
    }
  }
  const runner = makeRunner((t)=>{
    const tt = (performance.now()-t0)/1000;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    drawWeb(W/2, H/2, 180, 4, tt);
  });
  return { unmount(){ runner.stop(); } };
}

const templates = {
  cyberMinimal: { mount: cyberMinimalMount },
  cryptoOrb: { mount: cryptoOrbMount },
  retroTerminal: { mount: retroTerminalMount },
  zenSpace: { mount: zenSpaceMount },
  liquidWaves: { mount: liquidWavesMount },
  matrixRain: { mount: matrixRainMount },
  hexGridPulse: { mount: hexGridPulseMount },
  clockSync: { mount: clockSyncMount },
  codeVerse: { mount: codeVerseMount },
  aiBloom: { mount: aiBloomMount },
  signatureLoop: { mount: signatureLoopMount },
  neonCity: { mount: neonCityMount },
  glitchArt: { mount: glitchArtMount },
  vaporwave: { mount: vaporwaveMount },
  hologram: { mount: hologramMount },
  pixelStorm: { mount: pixelStormMount },
  scanlines: { mount: scanlinesMount },
  dataStream: { mount: dataStreamMount },
  particleNebula: { mount: particleNebulaMount },
  geometricDance: { mount: geometricDanceMount },
  synthwave: { mount: synthwaveMount },
  digitalRain: { mount: digitalRainMount },
  cosmicVoid: { mount: cosmicVoidMount },
  fractalTree: { mount: fractalTreeMount },
  waveform: { mount: waveformMount },
  starfield: { mount: starfieldMount },
  cyberpunkGrid: { mount: cyberpunkGridMount },
  dnaHelix: { mount: dnaHelixMount },
  liquidMetal: { mount: liquidMetalMount },
  quantumEntangle: { mount: quantumEntangleMount },
  neuralNet: { mount: neuralNetMount },
  crystalGrowth: { mount: crystalGrowthMount },
  radarScan: { mount: radarScanMount },
  energyShield: { mount: energyShieldMount },
  spectrumAnalyzer: { mount: spectrumAnalyzerMount },
  particleExplosion: { mount: particleExplosionMount },
  rippleEffect: { mount: rippleEffectMount },
  nebulaSwirl: { mount: nebulaSwirlMount },
  binaryClock: { mount: binaryClockMount },
  magneticField: { mount: magneticFieldMount },
  fiberNetwork: { mount: fiberNetworkMount },
  quantumWave: { mount: quantumWaveMount },
  cyberEye: { mount: cyberEyeMount },
  pulseWave: { mount: pulseWaveMount },
  mandelbrotSet: { mount: mandelbrotSetMount },
  kaleidoscope: { mount: kaleidoscopeMount },
  laserShow: { mount: laserShowMount },
  blackHole: { mount: blackHoleMount },
  circuitBoard: { mount: circuitBoardMount },
  audioVisualizer: { mount: audioVisualizerMount },
  timeTunnel: { mount: timeTunnelMount },
  plasmaStorm: { mount: plasmaStormMount },
  neonTunnel: { mount: neonTunnelMount },
  gravityWell: { mount: gravityWellMount },
  prismRefract: { mount: prismRefractMount },
  quantumFoam: { mount: quantumFoamMount },
  cyberRain: { mount: cyberRainMount },
  spiralMatrix: { mount: spiralMatrixMount },
  energyVortex: { mount: energyVortexMount },
  digitalHorizon: { mount: digitalHorizonMount },
  particleSwarm: { mount: particleSwarmMount },
  neonPulse: { mount: neonPulseMount },
  fractalZoom: { mount: fractalZoomMount },
  laserGrid: { mount: laserGridMount },
  quantumTunnel: { mount: quantumTunnelMount },
  cyberWaves: { mount: cyberWavesMount },
  plasmaRings: { mount: plasmaRingsMount },
  digitalWaterfall: { mount: digitalWaterfallMount },
  neonSpiral: { mount: neonSpiralMount },
  energyBurst: { mount: energyBurstMount },
  particleTrails: { mount: particleTrailsMount },
  cyberBloom: { mount: cyberBloomMount },
  quantumRipples: { mount: quantumRipplesMount },
  laserBeams: { mount: laserBeamsMount },
  digitalSmoke: { mount: digitalSmokeMount },
  neonRings: { mount: neonRingsMount },
  energyWeb: { mount: energyWebMount },
  particleDance: { mount: particleDanceMount },
  cyberPulse: { mount: cyberPulseMount },
  quantumStrings: { mount: quantumStringsMount },
  laserSpiral: { mount: laserSpiralMount },
  digitalAurora: { mount: digitalAuroraMount },
  neonWaves: { mount: neonWavesMount },
  energySphere: { mount: energySphereMount },
  particleFountain: { mount: particleFountainMount },
  cyberVortex: { mount: cyberVortexMount },
  quantumGrid: { mount: quantumGridMount },
  laserPulse: { mount: laserPulseMount },
  digitalNebula: { mount: digitalNebulaMount },
  neonMatrix: { mount: neonMatrixMount },
  energyFlow: { mount: energyFlowMount },
  particleStorm: { mount: particleStormMount },
  cyberSphere: { mount: cyberSphereMount },
  quantumBurst: { mount: quantumBurstMount },
  laserWeb: { mount: laserWebMount },
  digitalVortex: { mount: digitalVortexMount },
  neonFlow: { mount: neonFlowMount },
  energyRings: { mount: energyRingsMount },
  particleWeb: { mount: particleWebMount },
  cyberAurora: { mount: cyberAuroraMount },
  fractalFern: { mount: fractalFernMount },
  fractalSnowflake: { mount: fractalSnowflakeMount },
  fractalDragon: { mount: fractalDragonMount },
  fractalSpiral: { mount: fractalSpiralMount },
  fractalTriangle: { mount: fractalTriangleMount },
  fractalBranch: { mount: fractalBranchMount },
  fractalLightning: { mount: fractalLightningMount },
  fractalVine: { mount: fractalVineMount },
  fractalCrystal: { mount: fractalCrystalMount },
  fractalWeb: { mount: fractalWebMount }
};

window.addEventListener('beforeunload', ()=>{
  stopAutoplay();
  if(activeInstance && typeof activeInstance.unmount === 'function') activeInstance.unmount();
});

window.addEventListener('keydown', (e)=>{
  if(e.key === 'Escape') closeOverlay();
  if(e.key === 'ArrowRight') nextTemplate();
  if(e.key === 'ArrowLeft') {
    const idx = (currentIndex - 1 + TEMPLATE_IDS.length) % TEMPLATE_IDS.length;
    openTemplate(idx);
  }
});

autoplayToggle.classList.toggle('toggled', autoplay);

</script>
</body>
</html>
